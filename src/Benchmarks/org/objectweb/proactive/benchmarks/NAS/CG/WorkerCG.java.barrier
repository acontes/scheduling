/*
 * ################################################################
 *
 * ProActive: The Java(TM) library for Parallel, Distributed,
 *            Concurrent computing with Security and Mobility
 *
 * Copyright (C) 1997-2006 INRIA/University of Nice-Sophia Antipolis
 * Contact: proactive@objectweb.org
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
 * USA
 *
 *  Initial developer(s):               The ProActive Team
 *                        http://www.inria.fr/oasis/ProActive/contacts.html
 *  Contributor(s):
 *
 * ################################################################
 */
package org.objectweb.proactive.benchmarks.NAS.CG;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Vector;

import org.objectweb.proactive.ProActive;
import org.objectweb.proactive.benchmarks.NAS.util.Random;
import org.objectweb.proactive.benchmarks.timit.TimIt;
import org.objectweb.proactive.benchmarks.timit.util.Timed;
import org.objectweb.proactive.benchmarks.timit.util.TimerCounter;
import org.objectweb.proactive.benchmarks.timit.util.observing.Event;
import org.objectweb.proactive.benchmarks.timit.util.observing.EventObserver;
import org.objectweb.proactive.benchmarks.timit.util.observing.commobserv.CommEvent;
import org.objectweb.proactive.benchmarks.timit.util.observing.commobserv.CommEventObserver;
import org.objectweb.proactive.benchmarks.timit.util.observing.defaultobserver.DefaultEventData;
import org.objectweb.proactive.benchmarks.timit.util.observing.defaultobserver.DefaultEventObserver;
import org.objectweb.proactive.core.group.Group;
import org.objectweb.proactive.core.group.ProActiveGroup;
import org.objectweb.proactive.core.group.spmd.ProSPMD;
import org.objectweb.proactive.core.mop.ClassNotReifiableException;


/**
 * NAS PARALLEL BENCHMARKS
 *
 * Kernel CG
 *
 * A conjugate gradient method is used to compute an approximation
 * to the smallest eigenvalue of a large, sparse, symmetric positive
 * definite matrix. This kernel is typical of unstructured grid
 * computations in that it tests irregular long distance communication,
 * employing unstructured matrix vector multiplication.
 *
 * @author        Brian Amedro, Vladimir Bodnartchouk, Didier Dalmasso
 *
 */
public class WorkerCG extends Timed {
    private static final long serialVersionUID = 2784624024382450983L;
    public static final boolean COMMUNICATION_PATTERN_OBSERVING_MODE = false;

    /* Timer counters */
    private TimerCounter T_total = new TimerCounter("Total");
    private TimerCounter T_computation = new TimerCounter("Computation");
    private TimerCounter T_communication = new TimerCounter("Communication");
    
    /* Event observers */
    public DefaultEventObserver E_mflops;

    /** An observer the communication observer */
    private CommEventObserver nbCommObserver;
    private CommEventObserver commSizeObserver;
    private double tran;
    private double amult = 1220703125.0d;

    /** Group Information */
    private int rank;
    private WorkerCG typedGroup;
    private Group group;
    private WorkerCG leadWorker;
    private WorkerCG asyncRefToMe;
    private int groupSize;
    private CGProblemClass clss;
    private Random rng;
    private int npcols;
    private int nprows;
    private int naa;
    private int firstcol;
    private int lastcol;
    private int firstrow;
    private int lastrow;
    private double zeta;
    private int nzz;
    private double[] a;
    private int[] colidx;
    private int[] rowstr;
    private double[] x;
    private int l2npcols;
    private int[] reduce_exch_proc;
    private int[] reduce_send_starts;
    private int[] reduce_send_lengths;
    private int[] reduce_recv_starts;
    private int[] reduce_recv_lengths;
    private int send_start;
    private int send_len;
    private int exch_proc;
    private int exch_recv_length;
    private double rnorm;
    private double[] z;
    private double[] p;
    private double[] q;
    private double[] r;
    private double[] w;
    private WorkerCG[] reduce_exch_workers;
    final int cgitmax = 25;
    double[] norm_temp1;
    double[] norm_temp2;
    private int global_i;
    private int cgit = 1;
    private double rho;
    private boolean free_iteration = true;
    private int iteration = 1;
    private double sum_field;
    
    private int currentIter_ = 0;

    /** Precalculated number of rows and columns */
    private int numberOfRows;
    private int numberOfColumns;

    /** The group of workers without me */
    private Group groupWithoutMe;
    private WorkerCG typedGroupWithoutMe;
    private WorkerCG typedSyncGroup;
    private Group syncGroup;
    private Vector syncGroupRanks;
    private WorkerCG typedBlockGroup;
    private Group blockGroup;

    /** The array of values received from unwaited states */
    private StateWrapper[] stateWrapperArray;
    private int currentIter;

    /** Some temporary arrays for malloc avoidance **/
    private double[] tempArray;
    private double[] tempArray2;
    private int mySubGroupNumber;

    /**
     * Don't use
     */
    public WorkerCG() {
    }

    /**
     * Constructor
     */
    public WorkerCG(CGProblemClass clss, Integer npcols, Integer nprows,
        Integer nzz) {
        this.clss = clss;

        this.npcols = npcols;
        this.nprows = nprows;
        this.naa = clss.na; // short writing
        this.nzz = nzz;
    }

    public int getMySubGroup() {
        if ((this.rank < 0) || (this.rank >= this.clss.NUM_PROCS)) {
            System.err.println("Bad rank ! : " + this.rank);
            System.exit(1);
        }
        if (this.rank == 0) {
            return 1;
        }
        int j = 1;
        while (j <= (this.clss.NUM_PROCS / this.npcols)) {
            if (this.rank < (this.npcols * j)) {
                return j;
            }
            j++;
        }
        return -1;
    }

    private void setup_submatrix_info() {
        int proc_row;
        int proc_col;
        int col_size;
        int row_size;
        int local_i;
        int j;
        int div_factor;

        proc_row = rank / npcols;
        proc_col = rank - (proc_row * npcols);

        // --------------------------------------------------------------------
        // If naa evenly divisible by npcols, { it is evenly divisible
        // by nprows
        // --------------------------------------------------------------------
        if ((naa / npcols * npcols) == naa) { // .eq.
            col_size = naa / npcols;
            firstcol = (proc_col * col_size) + 1;
            lastcol = firstcol - 1 + col_size;
            row_size = naa / nprows;
            firstrow = (proc_row * row_size) + 1;
            lastrow = firstrow - 1 + row_size;
            // --------------------------------------------------------------------
            // If naa not evenly divisible by npcols, { first subdivide for
            // nprows
            // and {, if npcols not equal to nprows (local_i.e., not a sq number of
            // procs),
            // get col subdivisions by dividing by 2 each row subdivision.
            // --------------------------------------------------------------------
        } else {
            if (proc_row < (naa - (naa / nprows * nprows))) { // .lt.
                row_size = (naa / nprows) + 1;
                firstrow = (proc_row * row_size) + 1;
                lastrow = firstrow - 1 + row_size;
            } else {
                row_size = naa / nprows;
                firstrow = ((naa - (naa / nprows * nprows)) * (row_size + 1)) +
                    ((proc_row - (naa - (naa / nprows * nprows))) * row_size) +
                    1;
                lastrow = firstrow - 1 + row_size;
            }
            if (npcols == nprows) {
                if (proc_col < (naa - (naa / npcols * npcols))) {
                    col_size = (naa / npcols) + 1;
                    firstcol = (proc_col * col_size) + 1;
                    lastcol = firstcol - 1 + col_size;
                } else {
                    col_size = naa / npcols;
                    firstcol = ((naa - (naa / npcols * npcols)) * (col_size +
                        1)) +
                        ((proc_col - (naa - (naa / npcols * npcols))) * col_size) +
                        1;
                    lastcol = firstcol - 1 + col_size;
                }
            } else {
                if ((proc_col / 2) < (naa -
                        (naa / (npcols / 2) * (npcols / 2)))) {
                    col_size = (naa / (npcols / 2)) + 1;
                    firstcol = ((proc_col / 2) * col_size) + 1;
                    lastcol = firstcol - 1 + col_size;
                } else {
                    col_size = naa / (npcols / 2);
                    firstcol = ((naa - (naa / (npcols / 2) * (npcols / 2))) * (col_size +
                        1)) +
                        (((proc_col / 2) -
                        (naa - (naa / (npcols / 2) * (npcols / 2)))) * col_size) +
                        1;
                    lastcol = firstcol - 1 + col_size;
                }

                if ((rank & 1) == 0) { //if ((rank % 2) == 0) {
                    lastcol = firstcol - 1 + ((col_size - 1) / 2) + 1;
                } else {
                    firstcol = firstcol + ((col_size - 1) / 2) + 1;
                    lastcol = firstcol - 1 + (col_size / 2);
                }
            }
        }
        this.numberOfRows = this.lastrow - this.firstrow + 1; // added
        this.numberOfColumns = this.lastcol - this.firstcol + 1; // added

        if (npcols == nprows) {
            send_start = 1;
            send_len = this.numberOfRows; //lastrow - firstrow + 1;
        } else {
            if ((rank & 1) == 0) { //if ((rank % 2) == 0) {
                send_start = 1;
                send_len = ((1 + lastrow) - firstrow + 1) / 2;
            } else {
                send_start = (((1 + lastrow) - firstrow + 1) / 2) + 1;
                send_len = this.numberOfRows / 2; //(lastrow - firstrow + 1) / 2;
            }
        }

        // --------------------------------------------------------------------
        // Transpose exchange processor
        // --------------------------------------------------------------------
        if (npcols == nprows) {
            exch_proc = ((rank % nprows) * nprows) + (rank / nprows);
        } else {
            exch_proc = (2 * ((((rank / 2) % nprows) * nprows) +
                (rank / 2 / nprows))) + (rank % 2);
        }

        local_i = npcols / 2;
        l2npcols = 0;
        while (local_i > 0) {
            l2npcols++; //l2npcols = l2npcols + 1;
            local_i = local_i / 2;
        }

        // --------------------------------------------------------------------
        // Set up the reduce phase schedules...
        // --------------------------------------------------------------------
        div_factor = npcols;
        for (local_i = 1; local_i <= l2npcols; local_i++) {
            j = ((proc_col + (div_factor / 2)) % div_factor) +
                (proc_col / div_factor * div_factor);
            reduce_exch_proc[local_i] = (proc_row * npcols) + j;

            div_factor = div_factor / 2;
        }

        for (local_i = l2npcols; local_i >= 1; local_i--) {
            if (nprows == npcols) {
                reduce_send_starts[local_i] = send_start;
                reduce_send_lengths[local_i] = send_len;
                reduce_recv_lengths[local_i] = lastrow - firstrow + 1;
            } else {
                reduce_recv_lengths[local_i] = send_len;
                if (local_i == l2npcols) {
                    reduce_send_lengths[local_i] = (lastrow - firstrow + 1) -
                        send_len;
                    if ((rank & 1) == 0) { //if ((rank / 2 * 2) == rank) {
                        reduce_send_starts[local_i] = send_start + send_len;
                    } else {
                        reduce_send_starts[local_i] = 1;
                    }
                } else {
                    reduce_send_lengths[local_i] = send_len;
                    reduce_send_starts[local_i] = send_start;
                }
            }
            reduce_recv_starts[local_i] = send_start;
        }
        this.exch_recv_length = this.numberOfColumns; // added
                                                      //exch_recv_length = lastcol - firstcol + 1;
    }

    private void makea(int n, int nz, double[] a, int[] colidx, int[] rowstr,
        int nonzer, double rcond, 
    /** int[] arow, int[] acol, double[] aelt, double[] v, int[] iv,**/
    double shift) {
        // ---------------------------------------------------------------------
        // generate the test problem for benchmark 6
        // makea generates a sparse matrix with a
        // prescribed sparsity distribution
        //
        // parameter type usage
        //
        // input
        //
        // n i number of cols/rows of matrix
        // nz i nonzeros as declared array size
        // rcond r*8 condition number
        // shift r*8 main diagonal shift
        //
        // output
        //
        // a r*8 array for nonzeros
        // colidx i col indices
        // rowstr i row pointers
        //
        // workspace
        //
        // iv, arow, acol i
        // v, aelt r*8
        // ---------------------------------------------------------------------
        int i;
        int nnza;
        int ivelt;
        int ivelt1;
        int irow;
        int nzv;
        int jcol;
        int iouter;

        int[] iv = new int[(2 * naa) + 1 + 1];
        double[] v = new double[naa + 1 + 1];
        int[] acol = new int[nzz + 1];
        int[] arow = new int[nzz + 1];
        double[] aelt = new double[nzz + 1];

        // ---------------------------------------------------------------------
        // nonzer is approximately (int(sqrt(nnza /n)));
        // ---------------------------------------------------------------------
        double size;
        double ratio;
        double scale;

        size = 1.0d;
        ratio = Math.pow(rcond, (1.0 / (float) n));
        nnza = 0;

        // ---------------------------------------------------------------------
        // Initialize colidx(n+1 .. 2n) to zero.
        // Used by sprnvc to mark nonzero positions
        // ---------------------------------------------------------------------
        //for (i = 1; i <= n; i++) { colidx[n + i] = 0; }
        Arrays.fill(colidx, n + 1, (2 * n) + 1, 0);

        for (iouter = 1; iouter <= n; iouter++) {
            nzv = nonzer;
            sprnvc(n, nzv, v, iv, colidx, 0, colidx, n);
            nzv = vecset(n, v, iv, nzv, iouter, .5);

            for (ivelt = 1; ivelt <= nzv; ivelt++) {
                jcol = iv[ivelt];
                if ((jcol >= firstcol) && (jcol <= lastcol)) {
                    scale = size * v[ivelt];
                    for (ivelt1 = 1; ivelt1 <= nzv; ivelt1++) {
                        irow = iv[ivelt1];
                        if ((irow >= firstrow) && (irow <= lastrow)) {
                            nnza++; // nnza = nnza + 1;
                            if (nnza > nz) {
                                System.out.println(
                                    "Space for matrix elements exceeded in makea");
                                System.out.println("nnza, nzmax = " + nnza +
                                    ", " + nz);
                                System.out.println(" iouter = " + iouter);
                                this.terminate(); // return
                            }
                            acol[nnza] = jcol;
                            arow[nnza] = irow;
                            aelt[nnza] = v[ivelt1] * scale;
                        }
                    }
                }
            }
            size = size * ratio;
        }

        // ---------------------------------------------------------------------
        // ... add the identity * rcond to the generated matrix to bound
        // the smallest eigenvalue from below by rcond
        // ---------------------------------------------------------------------
        for (i = firstrow; i <= lastrow; i++) {
            if ((i >= firstcol) && (i <= lastcol)) {
                iouter = n + i;
                nnza++; //nnza = nnza + 1;
                if (nnza > nz) {
                    System.out.println(
                        "Space for matrix elements exceeded in makea");
                    System.out.println("nnza, nzmax = " + nnza + ", " + nz);
                    System.out.println(" iouter = " + iouter);
                    this.terminate();
                    return;
                }
                acol[nnza] = i;
                arow[nnza] = i;
                aelt[nnza] = rcond - shift;
            }
        }

        // ---------------------------------------------------------------------
        // ... make the sparse matrix from list of elements with duplicates
        // (v and iv are used as workspace)
        // ---------------------------------------------------------------------
        sparse(a, colidx, rowstr, n, arow, acol, aelt, v, iv, 0, iv, n, nnza);
    }

    private void sparse(double[] a, int[] colidx, int[] rowstr, int n,
        int[] arow, int[] acol, double[] aelt, double[] x, int[] mark,
        int mark_offst, int[] nzloc, int nzloc_offst, int nnza) {
        // ---------------------------------------------------------------------
        // rows range from firstrow to lastrow
        // the rowstr pointers are defined for nrows = lastrow-firstrow+1 values
        // ---------------------------------------------------------------------
        //int nrows;

        // ---------------------------------------------------
        // generate a sparse matrix from a list of
        // [col, row, element] tri
        // ---------------------------------------------------
        int ind;
        int j;
        int jajp1;
        int nza;
        int k;
        int nzrow;
        double xi;
        int temp;

        // ---------------------------------------------------------------------
        // how many rows of result
        // ---------------------------------------------------------------------
        //nrows = lastrow - firstrow + 1;

        // ---------------------------------------------------------------------
        // ...count the number of triples in each row
        // ---------------------------------------------------------------------
        for (j = 1; j <= n; j++) {
            rowstr[j] = 0;
            mark[j + mark_offst] = 0;
        }
        rowstr[n + 1] = 0;

        for (nza = 1; nza <= nnza; nza++) {
            j = (arow[nza] - firstrow + 1) + 1;
            rowstr[j]++; //rowstr[j] = rowstr[j] + 1;
        }

        rowstr[1] = 1;
        temp = this.numberOfRows + 1;
        for (j = 2; j <= temp; j++) { // for (j = 2; j <= (nrows+1); j++) {
            rowstr[j] = rowstr[j] + rowstr[j - 1];
        }

        // ---------------------------------------------------------------------
        // ... rowstr(j) now is the location of the first nonzero
        // of row j of a
        // ---------------------------------------------------------------------
        // ---------------------------------------------------------------------
        // ... do a bucket sort of the triples on the row index
        // ---------------------------------------------------------------------
        for (nza = 1; nza <= nnza; nza++) {
            j = arow[nza] - firstrow + 1;
            k = rowstr[j];
            a[k] = aelt[nza];
            colidx[k] = acol[nza];
            rowstr[j] = rowstr[j] + 1;
        }

        // ---------------------------------------------------------------------
        // ... rowstr(j) now points to the first element of row j+1
        // ---------------------------------------------------------------------
        for (j = this.numberOfRows; j >= 1; j--) { //for (j = nrows; j >= 1; j--) {
            rowstr[j + 1] = rowstr[j];
        }
        rowstr[1] = 1;

        // ---------------------------------------------------------------------
        // ... generate the actual output rows by adding elements
        // ---------------------------------------------------------------------
        nza = 0;
        for (ind = 1; ind <= n; ind++) {
            x[ind] = 0.0d;
            mark[ind + mark_offst] = 0;
        }

        jajp1 = rowstr[1];
        for (j = 1; j <= this.numberOfRows; j++) { //for (j = 1; j <= nrows; j++) {
            nzrow = 0;

            // ---------------------------------------------------------------------
            // ...loop over the jth row of a
            // ---------------------------------------------------------------------
            for (k = jajp1; k <= (rowstr[j + 1] - 1); k++) {
                ind = colidx[k];
                x[ind] = x[ind] + a[k];
                if ((mark[ind + mark_offst] == 0) && (x[ind] != 0)) {
                    mark[ind + mark_offst] = 1;
                    nzrow = nzrow + 1;
                    nzloc[nzrow + nzloc_offst] = ind;
                }
            }

            // ---------------------------------------------------------------------
            // ... extract the nonzeros of this row
            // ---------------------------------------------------------------------
            for (k = 1; k <= nzrow; k++) {
                ind = nzloc[k + nzloc_offst];
                mark[ind + mark_offst] = 0;
                xi = x[ind];
                x[ind] = 0.;
                if (xi != 0.) {
                    nza = nza + 1;
                    a[nza] = xi;
                    colidx[nza] = ind;
                }
            }

            jajp1 = rowstr[j + 1];
            rowstr[j + 1] = nza + rowstr[1];
        }

        //return; <--- ??
    }

    private int vecset(int n, double[] v, int[] iv, int nzv, int i, double val) {
        boolean set = false;
        for (int k = 1; k <= nzv; k++) {
            if (iv[k] == i) {
                v[k] = val;
                set = true;
            }
        }
        if (!set) {
            nzv = nzv + 1;
            v[nzv] = val;
            iv[nzv] = i;
        }
        return nzv;
    }

    // --------------------------------------------------------------------
    // generate a sparse n-vector (v, iv)
    // having nzv nonzeros
    //
    // mark(i) is set to 1 if position i is nonzero.
    // mark is all zero on entry and is reset to all zero before exit
    // this corrects a performance bug found by John G. Lewis, caused by
    // reinitialization of mark on every one of the n calls to sprnvc
    // --------------------------------------------------------------------
    private void sprnvc(int n, int nz, double[] v, int[] iv, int[] nzloc,
        int nzloc_offst, int[] mark, int mark_offst) {
        int nzrow = 0;
        int nzv = 0;
        int i;
        int ii;
        int nn1 = 1;
        double vecelt;
        double vecloc;

        while (true) {
            nn1 <<= 1; // nn1 = 2 * nn1;
            if (nn1 >= n) {
                break;
            }
        }

        // --------------------------------------------------------------------
        // nn1 is the smallest power of two not less than n
        // --------------------------------------------------------------------
        while (true) {
            if (nzv >= nz) {
                for (ii = 1; ii <= nzrow; ii++) {
                    i = nzloc[ii + nzloc_offst];
                    mark[i + mark_offst] = 0;
                }
                return;
            }

            rng.setSeed(tran);
            rng.setGmult(amult);
            vecelt = rng.randlc();

            // --------------------------------------------------------------------
            // generate an integer between 1 and n in a portable manner
            // --------------------------------------------------------------------
            vecloc = rng.randlc(); //tran, amult);
            tran = rng.getSeed();
            i = (int) (nn1 * vecloc) + 1;
            if (i > n) {
                continue;
            }

            if (mark[i + mark_offst] == 0) {
                mark[i + mark_offst] = 1;
                nzrow = nzrow + 1;
                nzloc[nzrow + nzloc_offst] = i;
                nzv = nzv + 1;
                v[nzv] = vecelt;
                iv[nzv] = i;
            }
        }
    }

    private void init() {
        this.asyncRefToMe = (WorkerCG) ProActive.getStubOnThis();
        this.typedGroup = (WorkerCG) ProSPMD.getSPMDGroup();
        this.group = ProActiveGroup.getGroup(this.typedGroup);
        this.typedGroupWithoutMe = (WorkerCG) ProActiveGroup.captureView(this.typedGroup);
        this.groupWithoutMe = ProActiveGroup.getGroup(this.typedGroupWithoutMe);
        this.groupSize = ProSPMD.getMySPMDGroupSize();
        this.leadWorker = (WorkerCG) (ProActiveGroup.getGroup(this.typedGroup)
                                                    .get(0));
        this.rank = ProSPMD.getMyRank();
        this.groupWithoutMe.remove(this.asyncRefToMe);

        if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
            // Create a observer to observe the number of communication
            this.nbCommObserver = new CommEventObserver("nbCommObserver",
                    groupSize, rank);

            // Create a observer to observe the size of the communication
            this.commSizeObserver = new CommEventObserver("commSizeObserver",
                    this.groupSize, rank);

            super.activate(new EventObserver[] { nbCommObserver, commSizeObserver });
        }

        // Setup the timing system
        E_mflops = new DefaultEventObserver("mflops", DefaultEventData.MIN,
                DefaultEventData.MIN);
        super.activate(new TimerCounter[] {
                T_total, T_computation, T_communication
            }, new EventObserver[] { E_mflops });

        rng = new Random();
        tran = 314159265.0d;
        
    }

    public void start() {
        this.init();

        /* Printout initial NPB info */
        if (rank == 0) {
            KernelCG.printStarted(clss.KERNEL_NAME, clss.PROBLEM_CLASS_NAME,
                new long[] { clss.na }, clss.niter, groupSize, clss.nonzer,
                clss.shift);
        }

        // add 1 to all size to conserve fortran index
        a = new double[nzz + 1];
        colidx = new int[nzz + 1];
        rowstr = new int[naa + 1 + 1];
        x = new double[(naa / nprows) + 2 + 1];
        reduce_exch_proc = new int[npcols + 1];
        reduce_send_starts = new int[npcols + 1];
        reduce_send_lengths = new int[npcols + 1];
        reduce_recv_starts = new int[npcols + 1];
        reduce_recv_lengths = new int[npcols + 1];
        z = new double[(naa / nprows) + 2 + 1];
        p = new double[(naa / nprows) + 2 + 1];
        q = new double[(naa / nprows) + 2 + 1];
        r = new double[(naa / nprows) + 2 + 1];
        w = new double[(naa / nprows) + 2 + 1];
        norm_temp1 = new double[2 + 1];
        norm_temp2 = new double[2 + 1];

        int i;

        this.stateWrapperArray = new StateWrapper[400];
        for (i = 0; i < this.stateWrapperArray.length; i++) {
            this.stateWrapperArray[i] = new StateWrapper();
        }

        reduce_exch_workers = (WorkerCG[]) ProActiveGroup.getGroup(typedGroup)
                                                         .toArray(new WorkerCG[0]);
        // this.reduce_exch_workers[this.rank] = this; <---- BAD FOR TIMERS due to RECURSIVE CALLS !!!
        this.mySubGroupNumber = this.getMySubGroup();

        // --------------------------------------------------------------------
        // Set up partition's submatrix info: firstcol, lastcol, firstrow,
        // lastrow
        // --------------------------------------------------------------------
        setup_submatrix_info();

        try {
            this.typedSyncGroup = (WorkerCG) ProActiveGroup.newGroup(WorkerCG.class.getName());
            this.typedBlockGroup = (WorkerCG) ProActiveGroup.newGroup(WorkerCG.class.getName());

            this.blockGroup = ProActiveGroup.getGroup(this.typedBlockGroup);
            this.syncGroup = ProActiveGroup.getGroup(this.typedSyncGroup);
        } catch (ClassNotReifiableException ex) {
            ex.printStackTrace();
        } catch (ClassNotFoundException ex) {
            ex.printStackTrace();
        }
        ////////////////////////////////////////////////////////////////////////
        // Fill the groups with the workers
        this.syncGroupRanks = new Vector();
        //String s = "" + this.rank + " reduce_exch : " + Arrays.toString(this.reduce_exch_proc) + " adding : ";
        for (i = 1; i < (this.l2npcols + 1); i++) {
            //if ( arrayOfGroup[i] )
            Object o = this.group.get(this.reduce_exch_proc[i]);
            this.syncGroupRanks.add(this.reduce_exch_proc[i]); // fill the ranks for this sub group
            if (!this.syncGroup.containsValue(o)) {
                //s+=" " + this.reduce_exch_proc[i];
                this.syncGroup.add(o);
            }
        }
        // Add me to syncGroup to make the barrier a total barrier on this syncGroup
        this.syncGroup.add(this.asyncRefToMe);
        this.syncGroupRanks.add(this.rank);

        // --------------------------------------------------------------------
        // Fill my subGroup for synchronizations
        // --------------------------------------------------------------------
        for (i = (this.mySubGroupNumber - 1) * this.npcols;
                i < (this.mySubGroupNumber * this.npcols); i++) {
            this.blockGroup.add(reduce_exch_workers[i]);
        }

        // --------------------------------------------------------------------
        // Inialize random number generator
        // --------------------------------------------------------------------
        rng.setSeed(tran);
        rng.setGmult(amult);
        zeta = rng.randlc(); //tran, amult);
        tran = rng.getSeed();

        // --------------------------------------------------------------------
        // Set up partition's sparse random matrix for given class size
        // --------------------------------------------------------------------
        makea(naa, nzz, a, colidx, rowstr, clss.nonzer, clss.rcond, 
        /** arow, acol, aelt, v, iv,**/
        clss.shift);

        // ---------------------------------------------------------------------
        // Note: as a result of the above call to makea:
        // values of j used in indexing rowstr go from 1 --> lastrow-firstrow+1
        // values of colidx which are col indexes go from firstcol --> lastcol
        // So:
        // Shift the col index vals from actual (firstcol --> lastcol )
        // to local, i.e., (1 --> lastcol-firstcol+1)
        // ---------------------------------------------------------------------
        int k;

        // ---------------------------------------------------------------------
        // Note: as a result of the above call to makea:
        // values of j used in indexing rowstr go from 1 --> lastrow-firstrow+1
        // values of colidx which are col indexes go from firstcol --> lastcol
        // So:
        // Shift the col index vals from actual (firstcol --> lastcol )
        // to local, i.e., (1 --> lastcol-firstcol+1)
        // ---------------------------------------------------------------------
        int temp;

        for (i = 1; i <= this.numberOfRows; i++) { //for ( j = 1; j <= (lastrow - firstrow + 1); j++) {
            temp = (rowstr[i + 1] - 1);
            for (k = rowstr[i]; k <= temp; k++) { //for (int k = rowstr[j]; k <= (rowstr[j + 1] - 1); k++) {
                colidx[k] -= this.firstcol; // colidx[k] = colidx[k] - firstcol + 1;
                colidx[k]++;
            }
        }

        // ---------------------------------------------------------------------
        // set starting vector to (1, 1, .... 1)
        // ---------------------------------------------------------------------
        // for ( i = 1; i <= ((clss.na / nprows) + 1); i++) { x[i] = 1.0; }
        java.util.Arrays.fill(this.x, 1, ((clss.na / nprows) + 1) + 1, 1.0d);

        this.zeta = 0.0d;
        ////////////////////////////////////////////////////////////////////////
        this.tempArray2 = new double[this.send_len];
        this.tempArray = new double[this.reduce_send_lengths[this.global_i]];
        this.currentIter = 1;

        if (this.rank == 0) {
            System.out.println(" Warning !! l2npcols = " + this.l2npcols);
        }

        ////////////////////////////////////////////////////////////////////////
        // IF THERE IS A NULLPOINTER EXCEPTION BEFORE THE FIRST ITERATION in
        // the method recv_conj_grad_step1_bis JUST PUT A TOTAL BARRIER HERE !!
        ////////////////////////////////////////////////////////////////////////
        ProSPMD.barrier("start", this.typedSyncGroup);

        this.conj_grad_step1();
    }

    public void normalize_step1() {
        this.T_computation.start();
        int j;
        // --------------------------------------------------------------------
        // zeta = shift + 1/(x.z)
        // So, first: (x.z)
        // Also, find norm of z
        // So, first: (z.z)
        // --------------------------------------------------------------------
        this.norm_temp1[1] = 0.d;
        this.norm_temp1[2] = 0.d;

        // do j=1, lastcol-firstcol+1        
        for (j = 1; j <= this.numberOfColumns; j++) {
            this.norm_temp1[1] += (x[j] * z[j]); //norm_temp1[1] = norm_temp1[1] + (x[j] * z[j]);
            this.norm_temp1[2] += (z[j] * z[j]); //norm_temp1[2] = norm_temp1[2] + (z[j] * z[j]);
        }

        if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
            ///////////////////////////////////////////////
            /// Notification on a comm with syncGroup ranks
            this.notifySyncGroupRanks(TimIt.getObjectSize("normalize_step1" +
                    this.currentIter));
            ///////////////////////////////////////////////
        }

        this.T_computation.stop();
        this.T_communication.start();
        long s = System.currentTimeMillis();
        //this.stopCompStartComm();
        ProSPMD.barrier("normalize_step1" + this.currentIter,
            this.typedSyncGroup);
        this.addM(s);
        //this.stopCommStartComp();
        this.T_communication.stop();
        this.T_computation.start();

        this.global_i = 1;

        // If we are at the end of the free loop realloc the memory size
        if (this.free_iteration) {
            this.stateWrapperArray = new StateWrapper[this.currentIter + 10];
            for (j = 0; j < this.stateWrapperArray.length; j++) {
                this.stateWrapperArray[j] = new StateWrapper();
            }
        } else {
            for (j = 0; j < this.stateWrapperArray.length; ++j) {
                this.stateWrapperArray[j].value = 0d;
                this.stateWrapperArray[j].array = null;
            }
        }

        this.currentIter = 1;

        if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
            ///////////////////////////////////////////////
            /// Notification on a comm with one rank
            this.notifyOneRank(this.reduce_exch_proc[1],
                4 // size of an int
                 +TimIt.getObjectSize(
                    new double[] { this.norm_temp1[1], this.norm_temp1[2] }));
            ///////////////////////////////////////////////
        }

        this.T_computation.stop();
        this.T_communication.start();
        s = System.currentTimeMillis();
        this.reduce_exch_workers[this.reduce_exch_proc[1]].recv_norm_loop1_bis(1,
            new double[] { this.norm_temp1[1], this.norm_temp1[2] });
        this.addM(s);
        this.T_communication.stop();
    }

    // 0)
    public void recv_norm_loop1_bis(int from, double[] tab) {
        this.T_computation.start();
        if (from > this.currentIter) { //  reception d'une requete en avance
            this.stateWrapperArray[from].array = tab;
            this.T_computation.stop();
        } else { // reception de la requete attendue
            this.norm_temp1[1] += tab[0];
            this.norm_temp1[2] += tab[1];
            this.global_i++;
            this.currentIter++;
            if (this.global_i > this.l2npcols) { // plus d'envoi a faire : c'est fini
                if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
                    ///////////////////////////////////////////////
                    /// Notification on a comm with all ranks
                    this.notifyAllGroupRanks(TimIt.getObjectSize(
                            "normalize_step2" + this.currentIter));
                    ///////////////////////////////////////////////
                }

                this.T_computation.stop();
                this.T_communication.start();
                long s = System.currentTimeMillis();                
                ProSPMD.barrier("normalize_step2" + this.currentIter,
                    this.typedGroup);
                this.addM(s);
                this.T_communication.stop();
                //this.stopCommStartComp();
                this.normalize_step2();
            } else { // send
                if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
                    ///////////////////////////////////////////////
                    /// Notification on a comm with one rank
                    this.notifyOneRank(this.reduce_exch_proc[this.global_i],
                        4 // size of an int
                         +TimIt.getObjectSize(
                            new double[] { this.norm_temp1[1], this.norm_temp1[2] }));
                    ///////////////////////////////////////////////
                }

                this.T_computation.stop();
                this.T_communication.start();
                long s = System.currentTimeMillis();
                this.reduce_exch_workers[this.reduce_exch_proc[this.global_i]].recv_norm_loop1_bis(this.currentIter,
                    new double[] { this.norm_temp1[1], this.norm_temp1[2] });
                this.addM(s);
                this.T_communication.stop();

                if (this.stateWrapperArray[this.currentIter].array != null) { // verification de reception anterieure de la requete attendue
                    this.recv_norm_loop1_bis(this.currentIter,
                        this.stateWrapperArray[this.currentIter].array);
                }
            }
        }
    }

    /** Normalize step2 if max iter reached stop benchmark **/
    public void normalize_step2() {
        this.T_computation.start();
        int j;

        this.norm_temp1[2] = 1.0d / Math.sqrt(this.norm_temp1[2]);

        if ((rank == 0) && !this.free_iteration) {
            this.zeta = this.clss.shift + (1.d / this.norm_temp1[1]);
            if (this.iteration == 1) {
                System.out.println(
                    "   iteration           ||r||                 zeta");
            }
            System.out.println("   " + this.iteration + "            " +
                this.rnorm + "       " + this.zeta);
        }

        // --------------------------------------------------------------------
        // Normalize z to obtain x
        // --------------------------------------------------------------------
        for (j = 1; j <= this.numberOfColumns; j++) { //for (int j = 1; j <= (lastcol - firstcol + 1); j++) {
            x[j] = norm_temp1[2] * z[j];
        }

        // end main iteration
        if (this.free_iteration) {
            this.free_iteration = false;
            // ---------------------------------------------------------------------
            // set starting vector to (1, 1, .... 1)
            // ---------------------------------------------------------------------
            Arrays.fill(x, 1, (this.clss.na / nprows) + 2, 1.0d);

            this.zeta = 0.0d;

            // Start timers
            this.T_computation.stop();
            this.T_communication.reset();
            this.T_computation.reset();
            T_total.start();
            //T_computation.start();
            this.conj_grad_step1();
        } else {
            this.T_computation.stop();
            this.iteration++;

            if (this.iteration <= this.clss.niter) {
                this.conj_grad_step1();
            } else {
                T_total.stop();

                super.getEventObservable()
                     .notifyObservers(new Event(E_mflops, getMflops()));

                if (rank == 0) {
                    this.end();
                } else {
                    super.finalizeTimed(this.rank, "");
                }
            }
        }
    } // -> no barrier AND call to conj_grad_step1

    /**
     * Computation starts here (restarts at each iteration)
     * result is in this.rnorm only for the root worker
     */
    private void conj_grad_step1() {
        this.T_computation.start();
        // --------------------------------------------------------------------
        // Initialize the CG algorithm:
        // --------------------------------------------------------------------
        int temp = ((naa / nprows) + 1);
        for (int j = 1; j <= temp; j++) {
            this.q[j] = 0.0d;
            this.z[j] = 0.0d;
            this.r[j] = this.x[j];
            this.p[j] = this.r[j];
            this.w[j] = 0.0d;
        }

        // --------------------------------------------------------------------
        // rho = r.r
        // Now, obtain the norm of r: First, sum squares of r elements
        // locally...
        // --------------------------------------------------------------------
        this.sum_field = 0.0d;
        for (int j = 1; j <= this.numberOfColumns; j++) {
            sum_field += (r[j] * r[j]); //sum_field = sum_field + (r[j] * r[j]);
        }

        this.global_i = 1;

        if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
            ///////////////////////////////////////////////
            /// Notification on a comm with one rank
            this.notifyOneRank(this.reduce_exch_proc[1], 4 + 8);
            ///////////////////////////////////////////////
        }

        this.T_computation.stop();
        this.T_communication.start();
        // Communication here
        long s = System.currentTimeMillis();
        this.reduce_exch_workers[this.reduce_exch_proc[1]].recv_conj_grad_step1_bis(this.currentIter,        		
            sum_field);
        this.addM(s);
        this.T_communication.stop();
    } // -> START ITER HERE !

    // 1)
    public void recv_conj_grad_step1_bis(int from, double val) {
        this.T_computation.start();
        if (from > this.currentIter) { //  reception d'une requete en avance
            this.stateWrapperArray[from].value = val;
            this.T_computation.stop();
        } else { // reception de la requete attendue
            this.global_i++;
            this.currentIter++;
            this.sum_field += val;
            if (this.global_i > this.l2npcols) { // plus d'envoi a faire : c'est fini
                this.T_computation.stop();
                this.conj_grad_step1_1();
            } else { // faire envoi et continuer
                if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
                    ///////////////////////////////////////////////
                    /// Notification on a comm with one rank
                    this.notifyOneRank(this.reduce_exch_proc[this.global_i],
                        4 + 8);
                    ///////////////////////////////////////////////
                }

                this.T_computation.stop();
                this.T_communication.start();
                long s = System.currentTimeMillis();
                this.reduce_exch_workers[this.reduce_exch_proc[this.global_i]].recv_conj_grad_step1_bis(this.currentIter,
                    this.sum_field);
                this.addM(s);
                this.T_communication.stop();

                if (this.stateWrapperArray[this.currentIter].value != 0d) { // verification de reception anterieure de la requete attendue
                    this.recv_conj_grad_step1_bis(this.currentIter,
                        this.stateWrapperArray[this.currentIter].value);
                }
            }
        }
    }

    private void conj_grad_step1_1() {
        this.rho = this.sum_field;
        this.cgit = 1;
        this.conj_grad_loop_step1();
    } // -> no barrier

    // --------------------------------------------------------------------
    // --->
    // The conj grad iteration loop
    // --->
    // --------------------------------------------------------------------
    private void conj_grad_loop_step1() { ////////////////////////////////////// OK
        if (this.cgit > cgitmax) {
            // rest
            this.conj_grad_step2();
            return;
        }
        this.T_computation.start();
        // do cgit = 1, cgitmax
        // --------------------------------------------------------------------
        // q = A.p
        // The partition submatrix-vector multiply: use workspace w
        // --------------------------------------------------------------------
        // TODO compare different versions
        // NOTE: this version of the multiply is actually (slightly: maybe
        // %5)
        // faster on the sp2 on 16 nodes than is the unrolled-by-2 version
        // below. On the Cray t3d, the reverse is true, i.e., the
        // unrolled-by-two version is some 10% faster.
        // The unrolled-by-8 version below is significantly faster
        // on the Cray t3d - overall speed of code is 1.5 times faster.
        //
        int j;

        // do cgit = 1, cgitmax
        // --------------------------------------------------------------------
        // q = A.p
        // The partition submatrix-vector multiply: use workspace w
        // --------------------------------------------------------------------
        // TODO compare different versions
        // NOTE: this version of the multiply is actually (slightly: maybe
        // %5)
        // faster on the sp2 on 16 nodes than is the unrolled-by-2 version
        // below. On the Cray t3d, the reverse is true, i.e., the
        // unrolled-by-two version is some 10% faster.
        // The unrolled-by-8 version below is significantly faster
        // on the Cray t3d - overall speed of code is 1.5 times faster.
        //
        int k;

        // do cgit = 1, cgitmax
        // --------------------------------------------------------------------
        // q = A.p
        // The partition submatrix-vector multiply: use workspace w
        // --------------------------------------------------------------------
        // TODO compare different versions
        // NOTE: this version of the multiply is actually (slightly: maybe
        // %5)
        // faster on the sp2 on 16 nodes than is the unrolled-by-2 version
        // below. On the Cray t3d, the reverse is true, i.e., the
        // unrolled-by-two version is some 10% faster.
        // The unrolled-by-8 version below is significantly faster
        // on the Cray t3d - overall speed of code is 1.5 times faster.
        //
        int temp;
        double sum;
        for (j = 1; j <= this.numberOfRows; j++) {
            sum = 0.0d; //double sum = 0.;
            temp = (rowstr[j + 1] - 1); // added
            for (k = rowstr[j]; k <= temp; k++) {
                sum += (a[k] * p[colidx[k]]); // sum = sum + (a[k] * p[colidx[k]]);
            }
            w[j] = sum;
        }

        this.global_i = this.l2npcols; // init next loop

        if (this.tempArray.length != this.reduce_send_lengths[this.global_i]) {
            this.tempArray = new double[this.reduce_send_lengths[this.global_i]];
        }
        System.arraycopy(this.w, this.reduce_send_starts[this.global_i],
            this.tempArray, 0, this.reduce_send_lengths[this.global_i]);

        if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
            ///////////////////////////////////////////////
            /// Notification of a comm with sync group ranks
            this.notifySyncGroupRanks(TimIt.getObjectSize(
                    "conj_grad_loop_step1" + this.currentIter));
            this.notifyOneRank(this.reduce_exch_proc[this.global_i],
                4 + TimIt.getObjectSize(this.tempArray));
            ///////////////////////////////////////////////
        }

        this.T_computation.stop();
        this.T_communication.start();
        long s = System.currentTimeMillis();
        ProSPMD.barrier("conj_grad_loop_step1" + this.currentIter,
            this.typedSyncGroup);        
        this.reduce_exch_workers[this.reduce_exch_proc[this.global_i]].recv_cgit_loop1_bis(this.currentIter,
            this.tempArray);
        this.addM(s);
        this.T_communication.stop();
    } // -> no barrier AND call to conj_grad_step2

    // 2)
    public void recv_cgit_loop1_bis(int from, double[] w_tab) {
        this.T_computation.start();
        if (from > this.currentIter) { //  reception d'une requete en avance
            this.stateWrapperArray[from].array = w_tab; // placement de la valeur en attente
            this.T_computation.stop();
        } else { // reception de la requete attendue
            int j;
            int temp;

            System.arraycopy(w_tab, 0, this.q,
                this.reduce_recv_starts[this.global_i],
                this.reduce_recv_lengths[this.global_i]);

            temp = ((this.send_start + this.reduce_recv_lengths[this.global_i]) -
                1);
            for (j = this.send_start; j <= temp; j++) {
                this.w[j] += this.q[j];
            }

            this.global_i--;
            this.currentIter++;

            if (this.global_i < 1) { // plus d'envoi a faire : c'est fini
                this.T_computation.stop();
                this.conj_grad_loop_step2();
            } else { // faire envoi et continuer
                if (this.tempArray.length != this.reduce_send_lengths[this.global_i]) {
                    this.tempArray = new double[this.reduce_send_lengths[this.global_i]];
                }

                System.arraycopy(this.w,
                    this.reduce_send_starts[this.global_i], this.tempArray, 0,
                    this.reduce_send_lengths[this.global_i]);

                if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
                    ///////////////////////////////////////////////
                    /// Notification of a comm with one rank
                    this.notifyOneRank(this.reduce_exch_proc[this.global_i],
                        4 + TimIt.getObjectSize(this.tempArray));
                    ///////////////////////////////////////////////
                }

                this.T_computation.stop();
                this.T_communication.start();
                long s = System.currentTimeMillis();
                this.reduce_exch_workers[this.reduce_exch_proc[this.global_i]].recv_cgit_loop1_bis(this.currentIter,
                    this.tempArray);
                this.addM(s);
                this.T_communication.stop();

                if (this.stateWrapperArray[this.currentIter].array != null) { // verification de reception anterieure de la requete attendue
                    this.recv_cgit_loop1_bis(this.currentIter,
                        this.stateWrapperArray[this.currentIter].array);
                }
            }
        }
    } // -> no barrier AND call to send_cgit_loop1

    private void conj_grad_loop_step2() { ////////////////////////////////////// OK
        this.T_computation.start();
        if (this.stateWrapperArray[this.currentIter].array != null) { // Si il y valeur dans memoire
            System.arraycopy(this.stateWrapperArray[this.currentIter].array, 0,
                this.q, 1, this.exch_recv_length); //  on la lit
            System.arraycopy(this.w, this.send_start, this.tempArray2, 0,
                this.send_len); // on prepare l'envoi

            if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
                //////////////////////////////////////////////
                /// Notification of a comm with one rank
                this.notifyOneRank(this.exch_proc,
                    4 + TimIt.getObjectSize(this.tempArray2));
                ///////////////////////////////////////////////
            }

            this.T_computation.stop();
            this.T_communication.start();
            long s = System.currentTimeMillis();            
            this.reduce_exch_workers[this.exch_proc].recv_cgit2(this.currentIter,
                this.tempArray2); // on envoi
            this.addM(s);
            this.T_communication.stop();

            this.currentIter++;
            this.conj_grad_loop_end();
        } else {
            System.arraycopy(this.w, this.send_start, this.tempArray2, 0,
                this.send_len);

            this.T_computation.stop();
            if (this.exch_proc == this.rank) {
                this.recv_cgit2(this.currentIter, this.tempArray2);
                return;
            }

            if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
                //////////////////////////////////////////////
                /// Notification of a comm with one rank
                this.notifyOneRank(this.exch_proc,
                    4 + TimIt.getObjectSize(this.tempArray2));
                ///////////////////////////////////////////////
            }

            this.T_communication.start();
            long s = System.currentTimeMillis();
            this.reduce_exch_workers[this.exch_proc].recv_cgit2(this.currentIter,
                this.tempArray2);
            this.addM(s);
            this.T_communication.stop();
        }
    } // -> no barrier AND recv_cgit2

    public void recv_cgit2(int from, double[] tab) { ///////////////////////////////////// OK
        this.T_computation.start();
        if (from > this.currentIter) {
            this.stateWrapperArray[from].array = tab;
            this.T_computation.stop();
        } else {
            System.arraycopy(tab, 0, this.q, 1, this.exch_recv_length);
            this.currentIter++;

            this.T_computation.stop();
            this.conj_grad_loop_end();
        }
    } // -> no barrier and ASYNC call

    public void conj_grad_loop_end() { ///////////////////////////////////////// OK
        this.T_computation.start();
        // --------------------------------------------------------------------
        // Clear w for reuse...
        // --------------------------------------------------------------------
        Arrays.fill(w, 1,
            Math.max(this.numberOfRows, this.numberOfColumns) + 1, 0.0d);

        // --------------------------------------------------------------------
        // Obtain p.q
        // --------------------------------------------------------------------
        //double sum = 0.0d;
        this.sum_field = 0.0d;
        for (int j = 1; j <= this.numberOfColumns; j++) {
            this.sum_field += (this.p[j] * this.q[j]); //sum = sum + (p[j] * q[j]);
        }

        this.global_i = 1;

        if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
            ///////////////////////////////////////////////
            /// Notification of a comm with sync group ranks
            this.notifySyncGroupRanks(TimIt.getObjectSize(
                    "recv_cgit_loop_end_1_bis" + this.currentIter));
            this.notifyOneRank(this.reduce_exch_proc[this.global_i], 4 + 8);
            ///////////////////////////////////////////////
        }

        this.T_computation.stop();
        this.T_communication.start();
        long s = System.currentTimeMillis();
        ProSPMD.barrier("recv_cgit_loop_end_1_bis" + this.currentIter,
            this.typedSyncGroup);
        this.reduce_exch_workers[this.reduce_exch_proc[this.global_i]].recv_cgit_loop_end_1_bis(this.currentIter,
            sum_field);
        this.addM(s);
        this.T_communication.stop();
    } // -> no barrier

    // 3)
    public void recv_cgit_loop_end_1_bis(int from, double val) {
        this.T_computation.start();
        if (from > this.currentIter) { //  reception d'une requete en avance
            this.stateWrapperArray[from].value = val;
            this.T_computation.stop();
        } else { // reception de la requete attendue
            this.global_i++;
            this.currentIter++;
            this.sum_field += val;

            if (this.global_i > this.l2npcols) { // plus d'envoi a faire : c'est fini
                this.T_computation.stop();
                this.conj_grad_loop_endXXX(); // passer a l'etape suivante
            } else { // faire envoi et continuer
                if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
                    ///////////////////////////////////////////////
                    /// Notification of a comm with one rank
                    this.notifyOneRank(this.reduce_exch_proc[this.global_i],
                        4 + 8);
                    ///////////////////////////////////////////////
                }

                this.T_computation.stop();
                this.T_communication.start();
                long s = System.currentTimeMillis();
                this.reduce_exch_workers[this.reduce_exch_proc[this.global_i]].recv_cgit_loop_end_1_bis(this.currentIter,
                    this.sum_field);
                this.addM(s);
                this.T_communication.stop();

                if (this.stateWrapperArray[this.currentIter].value != 0d) { // verification de reception anterieure de la requete attendue
                    this.recv_cgit_loop_end_1_bis(this.currentIter,
                        this.stateWrapperArray[this.currentIter].value);
                }
            }
        }
    }

    private void conj_grad_loop_endXXX() { ///////////////////////////////////// OK
        this.T_computation.start();
        int j;
        double sum;
        double alpha;
        sum = 0.0d;

        alpha = this.rho / this.sum_field;
        // --------------------------------------------------------------------
        // Obtain alpha = rho / (p.q)
        // --------------------------------------------------------------------

        // --------------------------------------------------------------------
        // Obtain z = z + alpha*p
        // and r = r - alpha*q
        // --------------------------------------------------------------------
        for (j = 1; j <= this.numberOfColumns; j++) {
            this.z[j] += (alpha * this.p[j]); //z[j] = z[j] + (alpha * p[j]);
            this.r[j] -= (alpha * this.q[j]); //r[j] = r[j] - (alpha * q[j]);
        }

        // --------------------------------------------------------------------
        // rho = r.r
        // Now, obtain the norm of r: First, sum squares of r elements
        // locally...
        // --------------------------------------------------------------------
        for (j = 1; j <= this.numberOfColumns; j++) {
            sum += (this.r[j] * this.r[j]); //sum = sum + (r[j] * r[j]);
        }

        this.sum_field = sum;
        this.global_i = 1;

        if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
            ///////////////////////////////////////////////
            /// Notification of a comm with sync group ranks
            this.notifySyncGroupRanks(TimIt.getObjectSize(
                    "recv_cgit_loop_end_2_bis" + this.currentIter));
            this.notifyOneRank(this.reduce_exch_proc[this.global_i], 4 + 8);
            ///////////////////////////////////////////////
        }

        this.T_computation.stop();
        this.T_communication.start();
        long s = System.currentTimeMillis();
        ProSPMD.barrier("recv_cgit_loop_end_2_bis" + this.currentIter,
            this.typedSyncGroup);
        this.reduce_exch_workers[this.reduce_exch_proc[this.global_i]].recv_cgit_loop_end_2_bis(this.currentIter,
            sum_field);
        this.addM(s);
        this.T_communication.stop();
    } // -> no barrier AND call to send_cgit_loop_end_2

    // 4)
    public void recv_cgit_loop_end_2_bis(int from, double val) {
        this.T_computation.start();
        if (from > this.currentIter) { //  reception d'une requete en avance
            this.stateWrapperArray[from].value = val;
            this.T_computation.stop();
        } else { // reception de la requete attendue
            this.global_i++;
            this.currentIter++;
            this.sum_field += val;
            if (this.global_i > this.l2npcols) { // plus d'envoi a faire : c'est fini
                this.T_computation.stop();
                this.conj_grad_loop_endXXX2();
            } else { // faire envoi et continuer
                if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
                    ///////////////////////////////////////////////
                    /// Notification of a comm with one rank
                    this.notifyOneRank(this.reduce_exch_proc[this.global_i],
                        4 + 8);
                    ///////////////////////////////////////////////
                }

                this.T_computation.stop();
                this.T_communication.start();
                long s = System.currentTimeMillis();
                this.reduce_exch_workers[this.reduce_exch_proc[this.global_i]].recv_cgit_loop_end_2_bis(this.currentIter,
                    this.sum_field);
                this.addM(s);
                this.T_communication.stop();

                if (this.stateWrapperArray[this.currentIter].value != 0d) { // verification de reception anterieure de la requete attendue
                    this.recv_cgit_loop_end_2_bis(this.currentIter,
                        this.stateWrapperArray[this.currentIter].value);
                }
            }
        }
    }

    private void conj_grad_loop_endXXX2() { //////////////////////////////////// OK
        this.T_computation.start();

        double rho0;
        double beta;
        rho0 = rho;
        rho = this.sum_field;

        // --------------------------------------------------------------------
        // Obtain beta:
        // --------------------------------------------------------------------
        beta = this.rho / rho0;

        // --------------------------------------------------------------------
        // p = r + beta*p
        // --------------------------------------------------------------------
        for (int j = 1; j <= this.numberOfColumns; j++) {
            this.p[j] = this.r[j] + (beta * this.p[j]);
        }

        this.cgit++;

        this.T_computation.stop();
        this.conj_grad_loop_step1(); // loop cgit
    } // -> no barrier AND call to conj_grad_loop_step1 |!| end of do cgit=1,cgitmax |!|

    private void conj_grad_step2() { /////////////////////////////////////////// OK
        this.T_computation.start();
        int j;
        int k;
        int temp;
        double sum;

        // --------------------------------------------------------------------
        // Compute residual norm explicitly: ||r|| = ||x - A.z||
        // First, form A.z
        // The partition submatrix-vector multiply
        // --------------------------------------------------------------------
        for (j = 1; j <= this.numberOfRows; j++) {
            sum = 0.0d;
            temp = (this.rowstr[j + 1] - 1);
            for (k = this.rowstr[j]; k <= temp; k++) {
                sum += (this.a[k] * this.z[this.colidx[k]]); //sum = sum + (a[k] * z[colidx[k]]);
            }
            this.w[j] = sum;
        }

        this.global_i = this.l2npcols;

        if (this.tempArray.length != this.reduce_send_lengths[this.global_i]) {
            this.tempArray = new double[this.reduce_send_lengths[this.global_i]];
        }
        System.arraycopy(this.w, this.reduce_send_starts[this.global_i],
            this.tempArray, 0, this.reduce_send_lengths[this.global_i]);

        if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
            ///////////////////////////////////////////////
            /// Notification of a comm with one rank
            this.notifyOneRank(this.reduce_exch_proc[this.global_i],
                4 + TimIt.getObjectSize(this.tempArray));
            ///////////////////////////////////////////////
        }

        this.T_computation.stop();
        this.T_communication.start();
        long s = System.currentTimeMillis();
        this.reduce_exch_workers[this.reduce_exch_proc[this.global_i]].recv_conj_grad1_bis(this.currentIter,
            this.tempArray);
        this.addM(s);
        this.T_communication.stop();
        // stopCOM
    } // -> no barrier AND call to send_conj_grad_step2

    // 5)
    public void recv_conj_grad1_bis(int from, double[] r_tab) {
        this.T_computation.start();
        if (from > this.currentIter) { //  reception d'une requete en avance
            this.stateWrapperArray[from].array = r_tab; // placement de la valeur en attente
            this.T_computation.stop();
        } else { // reception et traitement de la requete attendue
                 //start comp
            int j;
            int temp;
            System.arraycopy(r_tab, 0, this.r,
                this.reduce_recv_starts[this.global_i],
                this.reduce_recv_lengths[this.global_i]);

            temp = ((this.send_start + this.reduce_recv_lengths[this.global_i]) -
                1);
            for (j = send_start; j <= temp; j++) {
                this.w[j] += r[j];
            }

            this.global_i--;
            this.currentIter++;
            //stopcomp
            if (this.global_i < 1) { // plus d'envoi a faire : c'est fini
                this.T_computation.stop();
                this.conj_grad_step3();
            } else { // faire envoi et continuer
                     //start comp
                if (this.tempArray.length != this.reduce_send_lengths[this.global_i]) {
                    this.tempArray = new double[this.reduce_send_lengths[this.global_i]];
                }
                System.arraycopy(this.w,
                    this.reduce_send_starts[this.global_i], this.tempArray, 0,
                    this.reduce_send_lengths[this.global_i]);

                if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
                    ///////////////////////////////////////////////
                    /// Notification of a comm with one rank
                    this.notifyOneRank(this.reduce_exch_proc[this.global_i],
                        4 + TimIt.getObjectSize(this.tempArray));
                    ///////////////////////////////////////////////
                }

                this.T_computation.stop();
                this.T_communication.start();
                long s = System.currentTimeMillis();
                this.reduce_exch_workers[this.reduce_exch_proc[this.global_i]].recv_conj_grad1_bis(this.currentIter,
                    this.tempArray);
                this.addM(s);
                this.T_communication.stop();

                if (this.stateWrapperArray[this.currentIter].array != null) { // verification de reception anterieure de la requete attendue
                    this.recv_conj_grad1_bis(this.currentIter,
                        this.stateWrapperArray[this.currentIter].array);
                }
            }
        }
    }

    /** -------------------------------------------------------------------- **/
    /** Exchange piece of q with transpose processor:                        **/
    /** -------------------------------------------------------------------- **/
    private void conj_grad_step3() { ////////////////////////////////////// OK
        this.T_computation.start();
        if (this.stateWrapperArray[this.currentIter].array != null) { // Si il y valeur dans memoire
            System.arraycopy(this.stateWrapperArray[this.currentIter].array, 0,
                this.r, 0, this.exch_recv_length); //  on la lit
            System.arraycopy(this.w, this.send_start, this.tempArray2, 0,
                this.send_len); // on prepare l'envoi

            if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
                ///////////////////////////////////////////////
                /// Notification of a comm with one rank
                this.notifyOneRank(this.exch_proc,
                    4 + TimIt.getObjectSize(this.tempArray2));
                ///////////////////////////////////////////////
            }

            this.T_computation.stop();
            this.T_communication.start();
            long s = System.currentTimeMillis();
            this.reduce_exch_workers[this.exch_proc].recv_conj_grad2(this.currentIter,
                this.tempArray2); // on envoi
            this.addM(s);
            this.T_communication.stop();

            this.currentIter++;
            this.conj_grad_step4(); // continue by myself
        } else {
            System.arraycopy(this.w, this.send_start, this.tempArray2, 0,
                this.send_len);

            this.T_computation.stop();
            if (this.exch_proc == this.rank) { // In this case we could make the System.arraycopy directly
                this.recv_conj_grad2(this.currentIter, this.tempArray2);
                return;
            }

            if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
                ///////////////////////////////////////////////
                /// Notification of a comm with one rank
                this.notifyOneRank(this.exch_proc,
                    4 + TimIt.getObjectSize(this.tempArray2));
                ///////////////////////////////////////////////
            }

            this.T_communication.start();
            long s = System.currentTimeMillis();
            this.reduce_exch_workers[this.exch_proc].recv_conj_grad2(this.currentIter,
                this.tempArray2);
            this.addM(s);
            this.T_communication.stop();
        }
    } // -> no barrier AND recv_cgit2

    public void recv_conj_grad2(int from, double[] tab) { ///////////////////////////////////// OK
        this.T_computation.start();
        if (from > this.currentIter) {
            this.stateWrapperArray[from].array = tab;
            this.T_computation.stop();
        } else {
            System.arraycopy(tab, 0, this.r, 0, this.exch_recv_length);
            this.currentIter++;

            this.T_computation.stop();
            this.conj_grad_step4();
        }
    } // -> no barrier and ASYNC call

    private void conj_grad_step4() { /////////////////////////////////////////// OK
        this.T_computation.start();
        // --------------------------------------------------------------------
        // At this point, r contains A.z
        // --------------------------------------------------------------------
        double d;

        for (int j = 1; j <= this.numberOfColumns; j++) {
            d = x[j] - r[j];
            this.sum_field += (d * d);
        }

        this.global_i = 1;

        if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
            ///////////////////////////////////////////////
            /// Notification of a comm with sync group ranks
            this.notifySyncGroupRanks(TimIt.getObjectSize(
                    "recv_conj_grad_step4_bis" + this.currentIter));
            this.notifyOneRank(this.reduce_exch_proc[this.global_i], 4 + 8);
            ///////////////////////////////////////////////
        }

        this.T_computation.stop();
        this.T_communication.start();
        long s = System.currentTimeMillis();
        ProSPMD.barrier("recv_conj_grad_step4_bis" + this.currentIter,
            this.typedSyncGroup);
        this.reduce_exch_workers[this.reduce_exch_proc[this.global_i]].recv_conj_grad_step4_bis(this.currentIter,
            this.sum_field);
        this.addM(s);
        this.T_communication.stop();
    } // -> no barrier AND call to send_conj_grad_step4

    // 6)
    public void recv_conj_grad_step4_bis(int from, double val) {
        this.T_computation.start();
        if (from > this.currentIter) { //  reception d'une requete en avance
            this.stateWrapperArray[from].value = val;
            this.T_computation.stop();
        } else { // reception de la requete attendue
            this.global_i++;
            this.currentIter++;
            this.sum_field += val;
            if (this.global_i > this.l2npcols) { // plus d'envoi a faire : c'est fini
                //this.T_computation.stop();
                this.conj_grad_end();
            } else { // faire envoi et continuer
                if (WorkerCG.COMMUNICATION_PATTERN_OBSERVING_MODE) {
                    ///////////////////////////////////////////////
                    /// Notification of a comm with one rank
                    this.notifyOneRank(this.reduce_exch_proc[this.global_i],
                        4 + 8);
                    ///////////////////////////////////////////////
                }

                this.T_computation.stop();
                this.T_communication.start();
                long s= System.currentTimeMillis();
                this.reduce_exch_workers[this.reduce_exch_proc[this.global_i]].recv_conj_grad_step4_bis(this.currentIter,
                    this.sum_field);
                this.addM(s);
                this.T_communication.stop();

                if (this.stateWrapperArray[this.currentIter].value != 0d) { // verification de reception anterieure de la requete attendue
                    this.recv_conj_grad_step4_bis(this.currentIter,
                        this.stateWrapperArray[this.currentIter].value);
                }
            }
        }
    }

    private void conj_grad_end() { ///////////////////////////////////////////// OK
        if (this.rank == 0) {
            this.rnorm = Math.sqrt(this.sum_field);
            //System.out.println("WorkerCG.conj_grad_end() ::::: sum_field : " + this.sum_field  + " this.rnorm : " + this.rnorm );
        }

        this.T_computation.stop();
        this.normalize_step1();
    } // -> no barrier AND call to normalize_step1

    /**************************************************************************/
    private boolean verify() {
        boolean verified;
        double epsilon = 0.0000000001d;

        if (clss.PROBLEM_CLASS_NAME != 'U') {
            if (Math.abs(zeta - clss.zeta_verify_value) <= epsilon) {
                verified = true;
                System.out.println(" VERIFICATION SUCCESSFUL");
                System.out.println(" Zeta is    " + zeta);
                System.out.println(" Error is   " +
                    (zeta - clss.zeta_verify_value));
            } else {
                verified = false;
                System.out.println(" VERIFICATION FAILED");
                System.out.println(" Zeta                " + zeta);
                System.out.println(" The correct zeta is " +
                    clss.zeta_verify_value);
            }
        } else {
            verified = false;
            System.out.println(" Problem size unknown");
            System.out.println(" NO VERIFICATION PERFORMED");
        }
        return verified;
    }

    /** The method to kill this Active object */
    public void terminate() {
        try {
            ProActive.getBodyOnThis().terminate();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * End of the benchmark and print statistics.
     * Only by leadWorker.
     */
    private void end() {
        // The leader worker checks the result
        // and finalize sinds his stats to the reductor
        super.finalizeTimed(this.rank, verify() ? "" : "UNSUCCESSFUL");
    }

    private double getMflops() {
        double time = T_total.getTotalTime() / 1000.0;
        int nzp1 = clss.nonzer * (clss.nonzer + 1);
        double mflops = ((2 * clss.niter * clss.na) * (3.0 + nzp1 +
            (25.0 * (5.0 + nzp1)) + 3.0)) / time / 1000000.0;

        return mflops;
    }

    private class StateWrapper implements Serializable {
        public double value = 0d;
        public double[] array = null;

        public StateWrapper() {
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    // METHODS USED TO OBSERVE NB COMMS AND COMM SIZE
    ////////////////////////////////////////////////////////////////////////////
    private void notifyOneRank(int destRank, int messageSize) {
        // Notification of 1 communication with the dest rank
        super.getEventObservable()
             .notifyObservers(new CommEvent(this.nbCommObserver, destRank, 1));

        // Notification
        super.getEventObservable()
             .notifyObservers(new CommEvent(this.commSizeObserver, destRank,
                messageSize));
    }

    private void notifySyncGroupRanks(int messageSize) {
        for (int i = 0; i < this.syncGroupRanks.size(); i++) {
            this.notifyOneRank((Integer) this.syncGroupRanks.get(i), messageSize);
        }
    }

    private void notifyAllGroupRanks(int messageSize) {
        for (int i = 0; i < this.groupSize; i++) {
            this.notifyOneRank(i, messageSize);
        }
    }

    public static double checkSum(double[] arr, int len) {
        double res = 0;
        for (int i = 1; i <= len; i++) {
            res += (arr[i] * i);
        }
        return res;
    }

    public static double checkSum(double[] arr) {
        return checkSum(arr, arr.length - 1);
    }
    
    public final void addM(long startTime){
    	this.currentIter_++;
    }
}
