<?xml version="1.0" encoding="utf-8"?>
<!--  <!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN" "../docbook.dtd" />  --> 
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="admin_manual"><info><title>Administration guide</title></info>		
	<section xml:id="scheduler_architecture"><info><title>Scheduler Architecture</title></info>
			<section xml:id="Scheduler_Global_Architecture"><info><title>Scheduler Global Architecture</title></info>
				<para>
					The ProActive Scheduler Service is the result of a collaboration between 2 entities (the ProActive Scheduler and the Resource
					Manager). Each one of them has its own functionality.
				</para>
				<para>
					The ProActive Scheduler is the main entity and is a non GUI daemon which is connected to the Resources Manager. It is in
					charge of scheduling submitted jobs in accordance with the scheduling policy.
				</para>
				<para>
					In order to launch jobs, the ProActive Scheduler has to obtain nodes (resources) from the Resources Manager.
					As described hereafter, the user interacts only with the ProActive Scheduler entity and
					the managed resources can be simple hosts or peer to peer resources. For full documentation about the Resource Manager,
					please refer to <xref linkend="Resource_Manager"/>.
				</para>
				<figure xml:id="Scheduler_2_entities"><info><title>The ProActive Scheduler Entities</title></info>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" align="center" fileref="scheduler/pics/core/scheduler2entities.jpg" format="JPG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					<emphasis role="bold">In this section</emphasis>,
					we will explain how the <emphasis role="bold"> scheduler entity works and how it can be used.</emphasis>
				</para>
			</section>
	
			<section xml:id="Scheduler_entity_Architecture"><info><title>Scheduler Entity Architecture</title></info>
				<para>
					The architecture of the ProActive Scheduler (<xref linkend="Scheduler_entity"/>) is built around 3 Active Objects:
					To know more about Active Object, please refer to the ProActive Documentation.
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">The Authentication interface</emphasis>
							which is the first object that the user may have to contact. It is in charge of authenticate
							the user and allowing him to access (or not) to the Scheduler. The authentication security system
							can interact with files or LDAP.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">The Front-end</emphasis>
							which is the interface returned by the Authentication Interface and allows interaction
							with the ProActive Scheduler. This interface allows users to submit jobs, get scheduling state, retrieves
							job result...
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">The Core</emphasis>
							which is the main entity of the ProActive Scheduler. It is in charge of scheduling Jobs according with the
							policy (FIFO by default), retrieving scheduling events to the user and making storages.
						</para>
					</listitem>
				</itemizedlist>
				<para>
					Users cannot interact directly with the ProActive Scheduler Core. They have to use the Front-end gateway.
				</para>
				<figure xml:id="Scheduler_entity"><info><title>The ProActive Scheduler Entity</title></info>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" align="center" fileref="scheduler/pics/core/schedulerEntity.jpg" format="JPG"/>
						</imageobject>
					</mediaobject>
				</figure>
			</section>
		</section>
		
	<section xml:id="Start_scheduler"><info><title>Start the ProActive Scheduler</title></info>
			<para>
				The ProActive Scheduler has to be started with
				a database that will be used to save scheduling process in case of crash.
				It allows the ProActive Scheduler to restart with a consistent state.
				The ProActive Scheduler will either use an existing database or create a new one if it cannot find one.
				<itemizedlist>
					<listitem>
						<para>
							The database get its properties in the <emphasis>/database/hibernate/hibernate.cfg.xml</emphasis> configuration file.
							Here is an example of configuration:
						</para>
						<programlisting>
&lt;property name="connection.driver_class"&gt;org.apache.derby.jdbc.EmbeddedDriver&lt;/property&gt;
&lt;property name="connection.url"&gt;jdbc:derby:../../SCHEDULER_DB;create=true&lt;/property&gt;
&lt;property name="connection.username"&gt;scheduler&lt;/property&gt;
&lt;property name="connection.password"&gt;&lt;/property&gt;
&lt;!-- SQL dialect  --&gt;
&lt;property name="dialect"&gt;org.hibernate.dialect.DerbyDialect&lt;/property&gt;
						</programlisting>
						<itemizedlist>
							<listitem><para>
								<emphasis>driver_class</emphasis> defines which driver to use for the current dataBase implementation.
								</para>
							</listitem>
							<listitem><para>
								<emphasis>url</emphasis> defines the protocol, the url and the name used for this dataBase. The goal of this two first properties is
								to provide a way to change the implementation of the database and its directory. To start the Scheduler
								with the provided implementation, just don't modify them.</para>
							</listitem>
							<listitem><para>
								<emphasis>username</emphasis> is the user name authorized to create and manage the database ('scheduler' by default)</para>
							</listitem>
							<listitem><para>
								<emphasis>password</emphasis> is the password of the authorized user (empty by default)</para>
							</listitem>
							<listitem><para>
								<emphasis>dialect</emphasis> If you intend to change the database implementation, don't forget to change the dialect
								to match the given implementation.</para>
							</listitem>
						</itemizedlist>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				It is also possible to configure some properties that rely on the Scheduler. The file
				<emphasis>PASchedulerProperties.ini</emphasis> in the <emphasis>config</emphasis> directory contains
				every property that can be modified by administrator. The <emphasis>PASchedulerProperties</emphasis> class
				provide a way to override this file with your own one. If you do so, every overridden properties will be used.
				It is not necessary to specify every properties inside your own file.
				Here's a way to override default PAScheduler properties file by the code:
			</para>
			<programlisting language="java">
PASchedulerProperties.updateProperties("your_property_file");
			</programlisting>
			<para>
				The last method to override a property is to specify it into the the java command line using the -d option.
				You just have to name the property as it is done in the properties file, and give it a value.
				(ex: java -dpa.scheduler.core.nodepingfrequency=30000...). Such a property can be added in the provided scripts
				(startScheduler.[sh|bat] for example).
			</para>
			<para>
				The priority order between two definition of a same property is as follows:
				the definition with the highest priority is those defined using the Java command line, then it is the one defined in your own properties file and
				finally, the lowest priority is given to the default definition.
			</para>
			<para>
				Let's go on to the startup of the ProActiveScheduler. To start it with a shell command, go on to the next section.
				To start it using the Java API, please refer to <xref linkend="Start_scheduler_java"/>.
			</para>
			<section xml:id="PASchedulerProperties"><info><title>ProActive Scheduler properties</title></info>
				<para>
					<para>
						Note that some properties require a file path. File path can be given relative to the Scheduler home directory
						(ie : application root directory) OR with an absolute path. Also note that each property can be overridden by
						using the JVM properties when starting the Scheduler. (ie startScheduler.[sh|bat] -Dpa.scheduler.core.timeout=1000)
					</para>
					<para>
						<emphasis>Scheduler properties</emphasis>
					</para>
					<itemizedlist>
						<listitem>
							<emphasis role="italic">pa.scheduler.home</emphasis> :
							define Scheduler home directory. The home directory is the one containing the dist, doc, lib, classes, config
							directory (default is ., the current directory)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.core.timeout</emphasis> : timeout used in the main scheduling loop. If no new request is received by the SchedulerCore entity,
							no new resources are available, and tasks are running, it is the time to wait before the next scheduling loop specified in millisecond.
							(default is 2000ms)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.core.nodepingfrequency</emphasis> : time interval between each failed node checking specified in second (default is 20s)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.classserver.usecache</emphasis> : boolean that specify if the classes definition used in task class servers must be cached or not.
							Set to false to preserve memory usage in SchedulerCore (default is true)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.classserver.tmpdir</emphasis> : directory used to store a job classpath. If this value is not set,
							it uses the default TMP directory. (default is not set)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.policy</emphasis> : Scheduler default policy full name (default is org.ow2.proactive.scheduler.policy.PriorityPolicy)
							The policy specified here must be in the Scheduler classpath.
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.forkedtask.security.policy</emphasis> : Forked java task default security policy path,
							use to define the policy of the forked task (default is config/forkedJavaTask/forkedTask.java.policy)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.core.jmxmbeanname</emphasis> : Name of the JMX MBean for the scheduler (default is 'SchedulerFrontend:name=SchedulerWrapperMBean')
						</listitem>
					</itemizedlist>
					<para>
						<emphasis>Jobs properties</emphasis>
					</para>
					<itemizedlist>
						<listitem>
							<emphasis role="italic">pa.scheduler.job.factor</emphasis> : Number used to create task IDs.
							If the job number is the 123 and it contains 456 tasks and this property is set to 1000, so the task ID
							will be 123456. If this property is set to 10000, the task ID will be 1230456.
							Task ID is (jobId*this_factor+taskId). (default is 10000)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.core.removejobdelay</emphasis> : time interval between the retrieval of a job result and its suppression from the Scheduler
							specified in second. Set this time to 0 if you don't want the job to be remove anyway. (default is 3600)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.job.removeFromDataBase</emphasis> : According to the previous property,
							remove the job also in dataBase when removing it from scheduler. (default is false)
						</listitem>
					</itemizedlist>
					<para>
						<emphasis>Tasks properties</emphasis>
					</para>
					<itemizedlist>
						<listitem>
							<emphasis role="italic">pa.scheduler.task.initialwaitingtime</emphasis> : time to wait for when a task has had a faulty state
							specified in millisecond.
							For performance reason, if the task is faulty, it is not restarted immediately. This property define the initial
							time to wait. Next time are computed following this function: newTimeToWait=previousTimeToWait+n*1000 where n is
							the number of re-execution of the task. The new time to wait is capped to 60000ms. (default is 1000ms)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.task.numberofexecutiononfailure</emphasis> : number of execution
							allowed if a task failed. The difference between faulty and failed is the state of the resource on which
							the task is executed. Most of the time, a failure is detected if a task kill a resource. In this case,
							this property define the number of execution allowed for this kind of potentially harmful task.
							(default is 2, so one retry)
						</listitem>
					</itemizedlist>
					<para>
						<emphasis>Logs properties</emphasis>
					</para>
					<itemizedlist>
						<listitem>
							<emphasis role="italic">pa.scheduler.logs.provider</emphasis> : full class name of logs forwarding method.
							Logs forwarding is the system used to forward logs from task execution to user. possible values are:
							<itemizedlist>
								<listitem>
									org.ow2.proactive.scheduler.common.util.logforwarder.providers.SocketBasedForwardingProvider for simple socket.
									This one use simple java socket.
								</listitem>
								<listitem>
									org.ow2.proactive.scheduler.common.util.logforwarder.providers.SocketWithSSHTunnelBasedForwardingProvider for SSH tunneled socket.
									This one use java socket with SSH tunneling for secure communication.
								</listitem>
								<listitem>
									org.ow2.proactive.scheduler.common.util.logforwarder.providers.ProActiveBasedForwardingProvider for ProActive based communication.
									This one use ProActive communication, safer but slower.
								</listitem>
							</itemizedlist>
							(Default is org.ow2.proactive.scheduler.common.util.logforwarder.providers.ProActiveBasedForwardingProvider)
						</listitem>
					</itemizedlist>
					<para>
						<emphasis>Tasks properties</emphasis>
					</para>
					<itemizedlist>
						<listitem>
							<emphasis role="italic">pa.scheduler.ldap.config.path</emphasis> :
							LDAP Authentication configuration file path, used to set LDAP configuration properties.
							(default is config/authentication/ldap.cfg)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.core.defaultloginfilename</emphasis> :
							Login file name for file authentication method
							(default is config/authentication/login.cfg)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.core.defaultgroupfilename</emphasis> :
							Group file name for file authentication method
							(default is config/authentication/group.cfg)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.core.authentication.loginMethod</emphasis> :
							Property that define the method that have to be used for logging users to the Scheduler
							It can be one of the following values:
							<itemizedlist>
								<listitem>
									SchedulerFileLoginMethod to use file login and group management
								</listitem>
								<listitem>
									SchedulerLDAPLoginMethod to use LDAP login management
								</listitem>
							</itemizedlist>
							(default is SchedulerFileLoginMethod)
						</listitem>
					</itemizedlist>
					<para>
						<emphasis>Resources manager related properties</emphasis>
					</para>
					<itemizedlist>
						<listitem>
							<emphasis role="italic">pa.scheduler.resourcemanager.authentication.username</emphasis> :
							default username to connect the Resources Manager. Possible authentications are define
							by the RM authentication management (default is scheduler)
						</listitem>
						<listitem>
							<emphasis role="italic">pa.scheduler.resourcemanager.authentication.password</emphasis> :
							default password to connect the Resources Manager. Possible authentications are define
							by the RM authentication management (default is scheduler_pwd)
						</listitem>
					</itemizedlist>
					<para>
						<emphasis>Hibernate properties</emphasis>
					</para>
					<itemizedlist>
						<listitem>
							<emphasis role="italic">pa.scheduler.db.hibernate.configuration</emphasis> :
							Hibernate main configuration file (default is config/database/hibernate/hibernate.cfg.xml)
						</listitem>
					</itemizedlist>
				</para>
			</section>
			<section xml:id="Start_scheduler_sh"><info><title>Start the Scheduler using shell command</title></info>
				<para>
					To start a local scheduler, run the <emphasis>startScheduler.[sh|bat]</emphasis>
					script in 'bin/[os]/' directory. Without arguments, the ProActive Scheduler will start on the local
					host and will try to connect to a started local Resources Manager with the default database configuration file.
					If no Resources Manager exists, it will create its own Resources Manager.
					Note that the database will be created if it does not exist.
				</para>
				<para>
					<emphasis>startScheduler.[sh|bat]</emphasis> can be started with 2 optional arguments (use -h option to see 
					a description of the available options):
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>The URL of a Resources Manager</emphasis> already started (using the "-u URL" option).
								If you don't use this, it will try to connect to a started Resource Manager on the local host.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>The scheduling policy</emphasis> that will be started with the Scheduler
								(using "-p org.objectweb.proactive.extensions.scheduler.policy.PriorityPolicy" option).
								By default, it will use the <emphasis>PriorityPolicy</emphasis> provided with the package.
							</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>
					For example, the following line will launch a scheduler on a Resource Manager started on "toto". It will also use 
					the 'PriorityPolicy' scheduling policy:
				</para>
				<para>
					<code>startScheduler.[sh|bat] -u //toto/ -p org.objectweb.proactive.extensions.scheduler.policy.PriorityPolicy</code>
				</para>
				<para>
					By default, the "config/authentication/" directory has to contain the two authentication files (group and login).
					The "config/database/hibernate" directory has to contain the "hibernate.cfg.xml" configuration file.
				</para>
				<para>
					It is also possible to launch the ProActive Scheduler with only one of these options or without option at all. For more
					informations, use -h (or --help) option (i.e. "startScheduler.[sh|bat] -h").
				</para>
			</section>
			<section xml:id="Start_scheduler_java"><info><title>Start the Scheduler using the Java API</title></info>
				<para>
					You can start the ProActive Scheduler using the Java API. Supposing that a Resource Manager is already started on toto
					(see Resource Manager documentation <xref linkend="Resource_Manager"/> to create a resource Manager),
					this can be done as following:
				</para>
				<programlisting language="java">
ResourceManagerProxy rmp = ResourceManagerProxy.getProxy(new URI("//toto/"));
AdminScheduler.createScheduler(
	rmp,
	"org.objectweb.proactive.extensions.scheduler.policy.PriorityPolicy");
				</programlisting>
				<para>where arguments are respectively :</para>
				<orderedlist>
					<listitem>
						<para>
							<emphasis>The Resource Manager Proxy</emphasis>: A reference on an already started Resources Manager instance.
							Refer to the Resource Manager documentation to know how to do that
							(<xref linkend="Resource_Manager"/>).
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>The Policy Full Class Name</emphasis>: The scheduling policy to use, as a string
							representing the complete name of the class.
						</para>
					</listitem>
				</orderedlist>
				<para>
					<emphasis role="bold">NOTE: </emphasis>
					By default, authentication are provided by the 2 files into the <emphasis>config/authentication</emphasis> directory.
					This files contains username, password and their groups.
					A LDAP authentication module is also available to replace authentication files (login.cfg and group.cfg) security
					module by a LDAP security module.
					To do so, just go into the <emphasis>PASchedulerProperties.ini</emphasis> configuration file and change the value
					of the property <emphasis>pa.scheduler.core.authentication.loginMethod</emphasis> to "SchedulerLDAPLoginMethod".
					Information about your own LDAP configuration can be set in the <emphasis>ldap.cfg</emphasis> into the "config/authentication" directory.
				</para>
				<para>
					Another way is to start the ProActive Scheduler AND connect an administrator at the same time:
				</para>
				<programlisting language="java">
AdminScheduler.createScheduler(
	"login",
	"password",
	rmp,
	"org.objectweb.proactive.extensions.scheduler.policy.PriorityPolicy");
				</programlisting>
				<para>
					where arguments are the sames plus a <emphasis>login</emphasis> and a <emphasis>password</emphasis>
					as a string that authenticate the administrator who wants to connect. The user has to be in the login file and
					his group has to be 'admin' in the group file.
				</para>
			</section>
		</section>
		<section xml:id="About_job_submission"><info><title>About job submission</title></info>
			<para>
				According to the user manual, once connected, a user is ready to submit jobs. Here is a short explanation
				that describes the mechanism of submission.
				The <emphasis role="bold"> Authentication interface entity is no longer used</emphasis> for this connected user.
				<xref linkend="Job_submission"/> shows what happens when the Scheduler received a new job to schedule.
				<figure xml:id="Job_submission"><info><title>A job submission</title></info>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" align="center" fileref="scheduler/pics/core/jobSubmission.jpg" format="JPG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<orderedlist>
					<listitem>
						<para>
							First, the user submits a Job using his <emphasis role="bold">UserSchedulerInterface</emphasis>
							retrieved by the <emphasis role="bold">logAsUser</emphasis> method. Let's remind it:
							<programlisting language="java">
// connecting to the scheduler
SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/");
// checking username and password
UserSchedulerInterface scheduler = auth.logAsUser("username","password");
// submitting a new job and get the associated id
JobId myJobId = scheduler.submit(job);
							</programlisting>
						</para>
					</listitem>
					<listitem>
						<para>
							The Scheduler Front-end checks the integrity of the job, and builds it
							in order to be ready to be managed by the Scheduler Core. If there is a
							problem, an exception is thrown explaining the cause of this problem.
						</para>
					</listitem>
					<listitem>
						<para>
							Finally, the job is transmitted to the Core for scheduling.
						</para>
					</listitem>
				</orderedlist>
			</para>
		</section>
		<section xml:id="Administer_scheduler"><info><title>Administer the ProActive Scheduler</title></info>
			<para>
				As an administrator, it is possible to ask the Scheduler to start and stop, to kill jobs, set jobs priority, and so on...
				To start a command line administrator, go on to the next section. To use the Java API to manage it, please refer to
				<xref linkend="Administer_scheduler_java"/>.
			</para>
			<section xml:id="Administer_scheduler_sh"><info><title>Administer the Scheduler using shell command</title></info>
				<para>
					The admin shell is an interface which allows a user to administer the ProActive Scheduler without the
					java API. It is also possible to see exceptions coming from the scheduler to know what happened.
					To start a admin shell, run the <emphasis>adminScheduler.[sh|bat]</emphasis>
					script in 'unix/[os]/' directory. Without arguments, the admin shell will try to connect a
					scheduler on the local host, exceptions from the ProActive Scheduler won't be displayed and
					your login and password will be requested. Note that the admin shell uses administrator rights to allow
					the connection to the scheduler.
				</para>
				<para>
					<emphasis>adminScheduler.[sh|bat]</emphasis> can be started with 3 optional arguments:
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis>Your login</emphasis> (using the "-l login" option). If you use this option, only your password will
							be requested.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>Exceptions display</emphasis> (using the "-e" option). If this option is used, all exceptions coming from the ProActive Scheduler
							will be displayed, otherwise exceptions won't be displayed.
							By default, exceptions arre not displayed.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>URL of a started scheduler</emphasis> (using the "-u URL" option).
							By default, it tries to connect to a local scheduler.
						</para>
					</listitem>
				</itemizedlist>
				<para>
					Here is an overview of the admin shell :
				</para>
				<figure xml:id="admin_shell"><info><title>The admin shell</title></info>
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%" align="center" fileref="scheduler/pics/core/admin_shell.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					It is also possible to launch the admin shell with only one of the previous options or without option at all. For more
					informations, use -h (or --help) option (i.e. "adminScheduler.[sh|bat] -h").
				</para>
			</section>
			<section xml:id="Administer_scheduler_java"><info><title>Administer the Scheduler using the Java API</title></info>
				<para>
					Let's first explain the connection mechanism.
					A user can connect to the ProActive Scheduler only if he/she is known. That is the goal of the
					authentication interface which is able to authenticate users.
					Following figure shows how the ProActive Scheduler connects a user.
					<figure xml:id="userConnection"><info><title>A user connection</title></info>
						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%" contentdepth="100%" align="center" fileref="scheduler/pics/core/userConnection.jpg" format="JPG"/>
							</imageobject>
						</mediaobject>
					</figure>
					<orderedlist>
						<listitem>
							<para>
								First of all, a user tries to join the authentication interface using the
								<emphasis role="bold">SchedulerConnection.join(...)</emphasis> static method.
								It is also possible to use the SchedulerConnection.waitAndJoin(...) that will join the scheduler and wait
								for the connection to be established or an error to be raised.
							</para>
							<programlisting language="java">
SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/");
							</programlisting>
							<para>
								Then, with the <emphasis role="bold">SchedulerAuthenticationInterface</emphasis>,
								users can be connected as user or administrator roles using the
								<emphasis role="bold">logAsUser</emphasis> or <emphasis role="bold">logAsAdmin</emphasis> methods.
							</para>
							<programlisting language="java">
UserSchedulerInterface scheduler = auth.logAsUser("username", "password");
// OR AdminSchedulerInterface scheduler = auth.logAsAdmin("adminname", "password");
							</programlisting>
						</listitem>
						<listitem>
							<para>
								Next, the authentication object checks the users rights and whether
								the user is authorized to connect the scheduler. If not, an exception will be thrown.
							</para>
						</listitem>
						<listitem>
							<para>
								Once connected, the authentication object sends the right and
								username/password to the scheduler front-end which will be able to
								authenticate user on its own.
							</para>
						</listitem>
						<listitem>
							<para>
								If nothing goes wrong, the authentication interface will return a 
								<emphasis role="bold">UserSchedulerInterface</emphasis> or a 
								<emphasis role="bold">AdminSchedulerInterface</emphasis>
								which is in fact a direct link to the <emphasis role="bold">Front-end</emphasis>.
							</para>
						</listitem>
						<listitem>
							<para>
								The user is now able to interact with the Scheduler using the returned interface.
							</para>
						</listitem>
					</orderedlist>
				</para>
				<para>
					And now to administer the ProActive Scheduler, just connect to it if it's not already done and use the
					<emphasis role="bold">AdminSchedulerInterface</emphasis> to manage it. Take a look at the JavaDocumentation
					to get more details and features. Let's remind how to connect the Scheduler as an administrator:
				</para>
				<programlisting language="java">
SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/");
AdminSchedulerInterface scheduler = auth.logAsAdmin("admin_username", "admin_password");
				</programlisting>
				<para>
					Then, use the returned 'scheduler' object to communicate with the ProActive Scheduler as an administrator. One interesting thing
					is to change the policy during the scheduling, that will consequently change the remaining
					scheduling order. Refer to the <xref linkend="Extend_scheduler_policy"/> to make your own policy and change it as
					shown below:
				</para>
				<programlisting language="java">
//scheduler is the AdminSchedulerInterface returned in the previous sections
scheduler.changePolicy(org.objectweb.proactive.extensions.scheduler.policy.PriorityPolicy.class);
				</programlisting>
			</section>
		</section>
		<section xml:id="Extend_scheduler"><info><title>Extend the ProActive Scheduler</title></info>
			<section xml:id="Extend_scheduler_policy"><info><title>Add a new scheduling policy</title></info>
				<para>
					Create and add a new scheduling policy remains a very simple work. You just have to implements the
					<emphasis>
						org.ow2.proactive.scheduler.common.policy.Policy
					</emphasis>
					interface and start a new Scheduler with this new policy as argument, or dynamically change it
					if the scheduler is already running.
				</para>
				<para>
					Here is the interface which has to be implemented. The default implementation is <emphasis>PriorityPolicy</emphasis>
					in the same package:
				</para>
				<programlisting language="java">
public abstract class Policy implements Serializable {
	//Resource Manager state field.
	public RMState RMState = null;
	//method to implement
	public abstract Vector&lt;EligibleTaskDescriptor&gt; getOrderedTasks(List&lt;JobDescriptor&gt; jobs);
}
				</programlisting>
				<para>
					This method returns all the tasks that have to be scheduled. Tasks must be in the desired scheduling
					order. The first task to be scheduled will be the first in the returned Vector.
				</para>
				<para>
					The parameters is a list of running and pendingJobs,
					which contain tasks to be scheduled. Some properties in each job and task
					can be accessed in order to make your own scheduling order. It is also possible
					to access to the "RMState" field that allows you to have information about resources like
					used nodes, total nodes number, etc. The only thing to do is to
					<emphasis>extract the task</emphasis>, <emphasis>re-order them</emphasis>
					and <emphasis>put them in a vector</emphasis>. Let's see the default implementation of the ProActive
					Scheduler policy to illustrate it:
				</para>
				<programlisting language="java">
public class PriorityPolicy implements PolicyInterface {

	/**
	 * This method returns the tasks using FIFO policy according to the jobs priorities.
	 *
	 * @see org.objectweb.proactive.extensions.scheduler.policy.PolicyInterface#getReadyTasks(java.util.List)
	 */
	@Override
	public Vector&lt;EligibleTaskDescriptor&gt; getOrderedTasks( List&lt;JobDescriptor&gt; jobs) {

		Vector&lt;EligibleTaskDescriptor&gt; toReturn = new Vector&lt;EligibleTaskDescriptor&gt;();

		//sort jobs by priority
		Collections.sort(jobs);

		//add tasks to the list to return
		for (JobDescriptor lj : jobs) {
			toReturn.addAll(lj.getEligibleTasks());
		}

		//return
		return toReturn;

	}
}
				</programlisting>
				<para>
					By default, jobs know how to be sorted regarding to their priorities. But it is simpler to create a Comparator
					and sort jobs with it. It is also possible to have some information about resources using the protected
					<emphasis>RMState</emphasis> field inside the getOrderedTasks method.
				</para>
			</section>
		</section>

	<section xml:id="Scheduler_authentication"><info><title>Configure users authentication</title></info>
		<para> As presented before, scheduler users are authenticated at scheduler connection. Users have to enter a login and a password checked by Scheduler. There are
		two authorization levels:
		</para>
		<itemizedlist>
			 <listitem><para><emphasis>user level </emphasis>: enables to submit jobs (see waiting queue, jobs running and jobs finished). They can change priority of their jobs, with 3 priority levels:
			 lowest, low and normal. They are able to see their jobs output, cancel and retrieve results only from their own jobs.
			 They cannot perform actions on jobs submitted by other users.</para> 
			 </listitem>
			 <listitem><para><emphasis>admin level </emphasis>: enables to pause, stop and restart scheduler, cancel or retrieve results of any job,
			 change priority of any job, with 5 priority levels: lowest, low, normal, high and highest.</para>
			 </listitem>
		</itemizedlist>
		<section xml:id="Sched_authent_select"><info><title>Select authentication method</title></info>
			<para>
			So that the Scheduler can manage users authentication and authorization, it has to store users account/password, and check login and password at users connection.
			This storage of users accounts can be managed in two ways: by files, or by LDAP. A Scheduler property (PASchedulerProperties.ini)
			specifies which kind of authentication will be used:
			</para>
				<programlisting language="java">
	#Property that defines the method that has to be used for logging users to the Scheduler
	#It can be one of the following values:
	#	- "SchedulerFileLoginMethod" to use file login and group management
	#	- "SchedulerLDAPLoginMethod" to use LDAP login management
	pa.scheduler.core.authentication.loginMethod=SchedulerFileLoginMethod
				</programlisting>
			<para>
			By default, authentication method is by file (SchedulerFileLoginMethod). If you want to use the LDAP-based authentication,
			replace the "SchedulerFileLoginMethod" value by "SchedulerLDAPLoginMethod".
			</para>
		</section>
		<section xml:id="file_Sched_authent"><info><title>Configure file-based authentication</title></info>
			<para> By default, the Scheduler stores users accounts, passwords, and group memberships (user or admin), in two files:
			</para>
			<itemizedlist>
				<listitem><para><emphasis>config/authentication/login.cfg</emphasis> stores users and passwords accounts.
				Each line has to look like <emphasis>user:passwd</emphasis>.
				The default login.cfg file is given hereafter:</para>
			 	<programlisting language="java">
admin:admin
user1:pwd1
user2:pwd2
demo:demo
				</programlisting>
				</listitem>
				<listitem><para><emphasis>config/authentication/group.cfg</emphasis> stores users membership. For each
				user registered in login.cfg, a group membership has to be defined in this file.
				Each line has to look like <emphasis>user:group</emphasis>. Group has to be <emphasis>user</emphasis> to have user
				rights, or <emphasis>admin</emphasis> to have administrator rights.
				Default group.cfg is like this:</para>
			 	<programlisting language="java">
admin:admin
demo:admin
demo:admin
user1:user
user2:user
				</programlisting>
				</listitem>			
			</itemizedlist>
			<para>You can change the default paths of these two files. Edit file <emphasis>config/PASchedulerProperties.ini</emphasis> and change
			the two properties:
			</para>
			<itemizedlist>
				<listitem><para><emphasis>pa.scheduler.core.defaultloginfilename</emphasis> - To define a user/password file, change this line as follows:
				pa.scheduler.core.defaultloginfilename=/etc/scheduler/mylogins.cfg</para>
				</listitem>
				<listitem><para><emphasis>pa.scheduler.core.defaultgroupfilename</emphasis> - To define a group membership file, change the line as follows:
				pa.scheduler.core.defaultgroupfilename=/etc/scheduler/mygroups.cfg</para>
				</listitem>
			</itemizedlist>
		</section>
		<section xml:id="LDAP_Sched_authent"><info><title>Configure LDAP-based authentication</title></info>
			<para>
			Scheduler is able to connect to an existing LDAP, to check users login/password, and verify users group membership. This authentication method can be useful
			if you have in your organization an LDAP that already stores user/password entries. There are several points to configure: path in LDAP where scheduler users and admins
			entries are stored, LDAP groups that define user and admin group membership, URL of the LDAP, LDAP binding method used by connection
			and configuration of SSL/TLS if you want a secured connection between Scheduler and LDAP. All LDAP connection parameters are set in <emphasis>config/authentication/ldap.cfg</emphasis>.
			</para>
			<section xml:id="LDAP_users_URL"><info><title>Set LDAP url</title></info>
				<para> First, you have to define the LDAP's URL of your organisation. This address corresponds to the property: <emphasis>pa.scheduler.ldap.url</emphasis>.
				 You have to put a standard LDAP-like URL, for example <emphasis>ldap://myLdap</emphasis>. You can also set an URL with secure access: <emphasis>ldaps://myLdap:636</emphasis>.
				 See <xref linkend="LDAP_SSL"/> for SSL/TLS configuration.
				 </para>
			</section>			
			<section xml:id="LDAP_users_subtree"><info><title>Set users subtree and login attribute</title></info>
				<para>You have to define where users entries are stored in LDAP tree, i.e. the path where Scheduler tries to find users and admin entries. 
				The users subtree corresponds to the property: <emphasis>pa.scheduler.ldap.userssubtree</emphasis>. Put a DN of your LDAP like this:
				<literal>pa.scheduler.ldap.userssubtree=ou=myUsers,o=myOrganisation,dc=myFirm,dc=com</literal>. 
				</para>
				<para> Then, you have to specify in users entries, the attribute that corresponds to the user login. This is done by the property: <emphasis>pa.scheduler.ldap.user.login.attr</emphasis>.
				Put an attribute name like this: <literal>pa.scheduler.ldap.user.login.attr=loginName</literal>.
				</para>
			</section>
			<section xml:id="LDAP_groups"><info><title>Set users and admin groups</title></info>
				<para>
				After having found user entry in LDAP, and checked user password, LDAP checks group membership of the user. Your
				organization LDAP's has to provide two entries of type <emphasis>groupOfUniqueNames</emphasis>, that present attributes
				of type <emphasis>uniqueMember</emphasis>, which corresponds to users DN that has access to the Scheduler (typical group definition in a LDAP). You have to set
				the two entries of this type wherein users and admins DN are put in 'uniqueMemeber' attribute. Admins group DN is set in scheduler by property 
				<emphasis>pa.scheduler.ldap.admins.group.dn</emphasis>. User group DN is set by  property <emphasis>pa.scheduler.ldap.users.group.dn</emphasis>. 
				</para>
			</section>
			<section xml:id="LDAP_binding_method"><info><title>Configure LDAP authentication parameters</title></info>
				<para>
				By default, the Scheduler binds to LDAP in anonymous mode. You can change this authentication method by modifying the property <emphasis>pa.scheduler.ldap.authentication.method</emphasis>.
				This property can have several values:
				<itemizedlist>
					<listitem><para><emphasis>none</emphasis> (default value) - the Scheduler performs connection to LDAP in anonymous mode.</para>
					</listitem>
					<listitem><para><emphasis>simple</emphasis> - the Scheduler performs connection to LDAP with a specified login/password (see below for user password setting).</para>
					</listitem>
					<listitem><para>You can also specify a SASL mechanism for LDAPv3. There are many SASL mechanisms available:
					<emphasis>cram-md5</emphasis>, <emphasis>digest-md5</emphasis>, <emphasis>kerberos4</emphasis>... Just put <emphasis>sasl</emphasis> to this property 
					to let scheduler JVM choose SASL authentication mechanism.</para>
					</listitem>
				</itemizedlist>
				</para>
				<para>
				If you specify an authentication method different from 'none' (anonymous connection to LDAP),
				you must specify a login/password for authentication. There are two properties in PASchedulerProperties.ini to set:
				<itemizedlist>
					<listitem><para><emphasis>pa.scheduler.ldap.bind.login</emphasis> - set user name for authentication.</para>
					</listitem>
					<listitem><para><emphasis>pa.scheduler.ldap.bind.pwd</emphasis> - set password for authentication.</para>
					</listitem>
				</itemizedlist>				
				</para>
			</section>
			<section xml:id="LDAP_SSL"><info><title>Set SSL/TLS parameters</title></info>
				<para>Scheduler is able to communicate with LDAP with a secured SSL/TLS layer. It can be useful if your network is not trusted, and critical information are transmitted
				between scheduler and LDAP, such as  users passwords.
				First, set the LDAP URL property <emphasis>pa.scheduler.ldap.url</emphasis> to a URL of type ldaps://myLdap.
				Then, set <emphasis>pa.scheduler.ldap.authentication.method</emphasis> to none so as to delegate authentication to SSL.
				</para>
				<para>For using SSL properly, you have to specify your certificate and public keys for SSL handshake. Java stores
				certificates in a keyStore and public keys in a trustStore. In most of cases, you just have to define a trustStore with public
				key part of LDAP's certificate. Put certificate in a keyStore, and public keys in a trustStore 
				with the keytool command (keytool command is distributed with standard java platforms):
				</para>
				<para>
				keytool -import -alias myAlias -file myCertificate -keystore myKeyStore
				</para>
				<para>
				<emphasis>myAlias</emphasis> is alias name of your certificate, <emphasis>myCertificate</emphasis> is your private certificate file and
				<emphasis>myKeyStore</emphasis> is the new keyStore file produced in output. This command asks you to enter a password for your keyStore.
				</para>
				<para>
				Put LDAP certificate's public key in a trustStore, with the keytool command:
				</para>
				<para>
				keytool -import -alias myAlias -file myPublicKey -keystore myTrustStore
				</para>
				<para>
				<emphasis>myAlias</emphasis> is alias name of your certificate's public key, <emphasis>myPublicKey</emphasis> is your certificate's public
				key file and <emphasis>myTrustore</emphasis> is the new trustStore file produced in output. This command asks you to enter a password for your trustStore.
				</para>
				<para>
				Finally, in <emphasis>config/authentication/ldap.cfg</emphasis>, set keyStore and trustStore created before to their respective passwords:
				</para>
				<itemizedlist>
					<listitem><para>
					Set <emphasis>pa.scheduler.ldap.keystore.path</emphasis> to the path of your keyStore.</para>
					</listitem>
					<listitem><para>
					Set <emphasis>pa.scheduler.ldap.keystore.passwd</emphasis> to the password defined previously for keyStore.</para>
					</listitem>
					<listitem><para>
					Set <emphasis>pa.scheduler.ldap.truststore.path</emphasis> to the path of your trustStore.</para>
					</listitem>
					<listitem><para>
					Set <emphasis>pa.scheduler.ldap.truststore.passwd</emphasis> to the password defined previously for trustStore.</para>
					</listitem>
				</itemizedlist>
			</section>
			<para>
				This conclude with the ProActive Scheduler chapter, let's now look at the ProActive Scheduler Eclipse Plugin.
			</para>
		</section>
	</section>
</chapter>
