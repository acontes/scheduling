<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="user_manual"><info><title>User guide</title></info>			
	<section xml:id="Create_job"><info><title>Creating a job</title></info>
		<para>
			A job is the entity that will be submitted to the ProActive Scheduler.
			As it has been explained in the <xref linkend="what_is_job"/>,
			it's possible to create more than one type of job.
			A job can also be created using an XML descriptor or the provided ProActive Scheduler Java API.
		</para>
		<section xml:id="Create_job_xml"><info><title>Job XML descriptor</title></info>
			<para>
			The  Job  XML descriptor is created 
			following the 
			<uri xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://proactive.inria.fr/schemas/jobdescriptor/dev/schedulerjob.xsd">
			descriptor XSD schema</uri>
			
			</para>
			<para>
				Several parameters can be set for a job :
				<itemizedlist>
					<listitem>
						<para>
							<emphasis>name</emphasis>
							is a way to identify your job or just simply name it.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>projectName</emphasis> (optional)
							can be define in your job. This information grouping different jobs by project name.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>priority</emphasis> (optional - default is normal)
							is the scheduling priority level for your job. A user can only set its job
							priority to 'lowest', 'low', or 'normal'. There are two higher priority levels
							'high' and 'highest' which can be set by the administrator. 
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>cancelJobOnError</emphasis> (optional - default is false)
							is a way to define if your job must continue if a user exception or
							error occurs during the job process. This property is also define in each task.
							If the value of this property is defined, each cancelJobOnError property for each task
							of this job will have this same value as the default one. True means that the job
							will immediately stop every remaining running tasks if an error occurs in one of
							the tasks. It is useful when there is no need to go further after a task failure.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>restartTaskOnError</emphasis> (optional - default is anywhere)
							is a way to define if your task that have to restart will be restart on an other
							resource or not. Define this property will force each restartTaskOnError property 
							to have this value as the default one. Possible values are 'anywhere' or 'elsewhere' meaning respectively
							that the concerned task will be restart on any available resources or especially on a different one.
							A task can be restart when an exception occurred (Java Task) or an error code is returned (Native Task).
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>nbMaxOfExecution</emphasis> (optional - default is 1)
							is a way to define how many times a task is allowed to restart.
							Define this property will force each nbMaxOfExecution property to have this value as the default one.
							The value can be an non negative and non nul integer.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>logFile</emphasis> (optional) is the path of a log file.
							Set it if you want to save the job generated logs (STDOUT and STDERR) in a file.
							<emphasis>As this file is created and filled by the scheduler server, the path must be
							also reachable from the scheduler server not only from the client.</emphasis>
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>description</emphasis> (optional)
							is a human readable description of the job.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>variables</emphasis> (optional)
							is a way to define variables which can be reused throughout the descriptor file.
							Inside this tag, each variable can be reused (even in another following variable definition)
							by using the syntax ${name_of_variable}.
							Note that you can also reference variables defined in the JVM properties. The JVM that starts the Job parser (JobFactory)
							can be start with -Dtoto=helloWorld. The variable ${toto} in the XML descriptor file will have 'helloWorld' as value.
							This method is not commonly used but can be very useful to manage your relative path.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>genericInformation</emphasis> (optional)
							is a way to define some information inside your job.
							These information could be read by the policy of the Scheduler. This information can be used
							to modify the scheduling behavior. As an example, the administrator can set the policy
							to be influenced by this information.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>JobClasspath</emphasis> (optional)
							is the equivalent of the Java classpath. All classes that are in this set of paths can be loaded by 
							the java tasks contained in this job. The jobClasspath can contain class directories but also jar files.
						</para>
							<warning><para> The jobClasspath mechanism relies on the file transfer therefore the size of the jobClasspath
							files have an impact on performances, especially on the time spent for submitting jobs.</para></warning> 
					</listitem>
				</itemizedlist>
			</para>
			<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/job.xml"/></textobject></programlisting>
			
			<para>This example descriptor does not contain the job type definition. We detail the job type definition in the next sections.</para>
		</section>
			
		<section xml:id="Create_ProActive_job_xml"><info><title>Creating a ProActive job using a XML descriptor</title></info>
			<para>
				To specify that the job is a ProActive Job, we add the 'proActive' tag.
				We use the previous job descriptor and add the tag :
			</para>
			<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/ProActive_job.xml" /></textobject></programlisting>
			<para>
				To create and add tasks to your Job, just go to <xref linkend="Create_add_task" />.
			</para>
		</section>
		<section xml:id="Create_TaskFlow_job_xml"><info><title>Creating a Task Flow job using XML descriptor</title></info>
		<para>
			The Task Flow job or data flow job is a job that can
			contain one or more task(s) with the needed dependencies.
				To specify that the job is a Task Flow Job, we add the 'taskFlow' tag.
				We use the previous job descriptor and add the tag :
			</para>
			<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/taskFlow_job.xml" /></textobject></programlisting>
			<para>
				To create and add tasks to your Job, just go to <xref linkend="Create_add_task" />.
			</para>
		</section>
		
		
		<section xml:id="Create_TaskFlow_job_java"><info><title>Create a Task Flow job using Java API</title></info>
			<para>
				To make a new instance of a TaskFlow job we simply create a new 
				object of <code>TaskFlowJob</code>  type:
			</para>
			<programlisting language="java"> <textobject><textdata fileref="automatic_snippets/task_flow_job_creation.snip" /></textobject></programlisting>
		</section>
	

		<section xml:id="Create_ProActive_job_java"><info><title>Create a ProActive job using Java API</title></info>
			<para>
				To make a new instance of a ProActive job we simply create a new 
				object of <code>ProActiveJob</code>  type:
			</para>
			<programlisting language="java"><![CDATA[ ProActiveJob job = new ProActiveJob();]]></programlisting>
  		</section>
		
		<section xml:id="Parameters_job_java"><info><title>Setting the job parameters using the Java API</title></info>
			<para>
				The parameters for jobs created through the Java API are the same as those created through
				XML files <xref linkend="Create_job_xml"/>.
				The example below creates a job using the Java Scheduler API and sets some parameters for the job:
			</para>
			<programlisting language="java"><textobject><textdata fileref="automatic_snippets/taskflow_params.snip"/></textobject></programlisting>
			<programlisting language="java">
//job has already been created under the 'job' variable
job.setLogFile("path/to/a/log/file.log");
job.setDescription("Job description");
job.addGenericInformation("var1","val1");
job.addGenericInformation("var2","val2");
JobEnvironment je = new JobEnvironment();
je.setJobClasspath(new String[]{"/path/to/my/classes/","/path/to/my/jarfile.jar"}); 
job.setEnv(je);
			</programlisting>
			<para>
				To create and add tasks to your Job, just go to <xref linkend="Create_add_task"/>.
			</para>
		</section>
		
	</section>
	<section xml:id="Create_add_task"><info><title>Create and add a task to a job</title></info>
		<para>
			As it has been said, it is possible to create 3 types of tasks. Native and
			Java tasks can be add to TaskFlow Job, and one ProActive Task to one ProActive Job.
		</para>
		<section xml:id="Create_java_task"><info><title>Create and add a Java task</title></info>
			<para>
				<emphasis>Note</emphasis> : It is only possible to add a Java task in a TaskFlow Job.
			</para>
			<para>
				To learn how to create a TaskFlow Job,
				just go to <xref linkend="Create_TaskFlow_job_xml"/> or <xref linkend="Create_TaskFlow_job_java"/>.
				Once your TaskFlow Job created, you can add as many Java tasks as needed to perform an application.
			</para>
			<section xml:id="define_executable_java"><info><title>Define your own Java executable</title></info>
				<para>
					First of all, you must know that you can create your own
					java executable by implementing scheduler executable interfaces.
					What is called 'executable' is in fact, the executed process (that is a Java class in this case).
					Here's an example to create your own Java executable :
				</para>
				<programlisting language="java">
public class WaitAndPrint extends JavaExecutable {

	@Override
	public Serializable execute(TaskResult... results) throws Throwable {
		String message;

		try {
			System.err.println("Démarrage de la tache WaitAndPrint");
			System.out.println("Parameters are : ");

			for (TaskResult tRes : results) {
				if (tRes.hadException()) {
					System.out.println("\t " + tRes.getTaskId() + " : " + tRes.getException().getMessage());
				} else {
					System.out.println("\t " + tRes.getTaskId() + ": " + tRes.value());
				}
			}

			message = URIBuilder.getLocalAddress().toString();
			Thread.sleep(10000);

		} catch (Exception e) {
			message = "crashed";
			e.printStackTrace();
		}

		System.out.println("Terminaison de la tache");

		return (message + "\t slept for 10 sec");
	}
}
				</programlisting>
				<para>
					This executable will print an initial message, then check if there are results from previous tasks
					and if so, print the value of these "parameters". It will then return a message
					containing what the task did. The return value will be store in the job result.
				</para>
				<para>
					It is also possible to get a list of arguments that you can give to the executable at its start by
					overriding the init method on a Java executable. How to give arguments to the task will be explain
					further.
					We get back the foo, bar and test arguments to illustrate the task creation example below :
					<programlisting language="java">
private boolean foo;
private int bar;
private String test;

@Override
public void init(Map&lt;String, Object&gt; args) {
	foo = (Boolean)args.get("foo");
	bar = (Integer)args.get("bar");
	test = args.get("test");
}
					</programlisting>
				</para>
				<para>
					To sum up, create an executable is just extend the <code>JavaExecutable</code> abstract class, and fill
					the execute method. The given <code>TaskResult... results</code> arguments permit to get the results from
					previous dependent tasks that have finished their execution.
				</para>
				<para>
					As shown in the following lines, the given array of TaskResults(<emphasis>results</emphasis>)
					will be an array of two results (TaskResult 2 and 3) in this order
					if the dependences of Task 5 is Task 2 and Task 3 in this order.
					Therefore you can use them to perform Task 5 process.
					<programlisting language="java">
@Override
public Serializable execute(TaskResult... results) throws Throwable {
	//TaskResult
	tResult2 = results[0];
	//TaskResult
	tResult3 = results[1];
}
					</programlisting>
				</para>
				<para>
					Finally, overriding the <code>init()</code> method can be useful if you want to retrieve some parameters.
				</para>
			</section>
			

			<section xml:id="Create_java_task_xml"><info><title>Create and add a Java task using XML descriptor</title></info>
					<para>
						The task is the entity that will be scheduled by ProActive Scheduler.
						As it has been explained in <xref linkend="what_is_task"/>,
						it's possible to create and add Java tasks to your TaskFlow Job.
						A Java task can also be created using an XML descriptor or the provided ProActive Scheduler Java API.
					</para>
				<para>
					Just take a look at the example below to understand the syntax of a task :
				</para>
				<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/java_task_simple.xml"/></textobject></programlisting>
				<para>
					The Java Task is composed of one 'javaExecutable' that specified the 'executable' Java class to use.
					A set of parameters has also be defined to provide the executable some information. These parameters will be
					available into the <code>HashMap</code> of the <code>init(HashMap)</code> method into your <code>JavaExecutable</code>.
					This example also shows the definition of two tasks with dependencies. We can easily see that 'task 2' depends on
					'task 1'. So 'task 2' will be executed when 'task 1' has finished.
					To put these two tasks inside your TaskFlow job, just put it between the 'taskFlow' tags.
					Here's how a complete ready-to-be-scheduled TaskFlow Job seems like :
				</para>
				<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/taskFlow_job_complete.xml"/></textobject></programlisting>
				<para>
					It is obviously possible to mix Java and Native task inside a taskFlow Job.
					Some other stuffs and options can be set onto a Java task, here's two examples of what can be done with
					task XML descriptors :
				</para>
				<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/java_task_script.xml"/></textobject></programlisting>
				<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/java_task_fork.xml"/></textobject></programlisting>
				<para>
					To have an exhaustive list of which options are available and what they are suppose to do, just go to
					the task explanation section at <xref linkend="Create_task_explanation"/>.
				</para>
			</section>
			<section xml:id="Create_java_task_java"><info><title>Create and add a Java task using Java API</title></info>
				<para>
					To <emphasis>create a Java task</emphasis> use the
					<emphasis>JavaTask</emphasis> class.
					In this type, you must specify the class you want to start with, by mentioning a
					Class of your executable. (To make your own executable see the
					proper section <xref linkend="define_executable_java"/> ).
					In addition, you can add arguments with which the task will be launched.
					These launching arguments will be given to the Java executable as a Map.
					Just take a look at the example below to see how to use the task creation Java API
					(see also Java DOCumentation of the Scheduler to learn more) :
				</para>
				<programlisting language="java">
//create a Java Task with the default constructor that we'll call 'aTask'
JavaTask aTask = new JavaTask();
//then, set the desired options : (for example)
aTask.setName("task 1");
aTask.setDescription("This task will do
something...");
aTask.addGenericInformation("key","value");
aTask.setRerunnable(2);
aTask.setRestartTaskOnError(RestartMode.ELSEWHERE);
aTask.setCancelJobOnError(false);
aTask.setResultPreview(UserDefinedResultPreview.class);
//add arguments (optional)
aTask.addArgument("foo",new Boolean(true));
aTask.addArgument("bar",new Integer(12));
aTask.addArgument("test","test1");
//add executable class or instance
pat.setExecutableClassName("org.ow2.proactive.scheduler.examples.WaitAndPrint");

//SCRIPTS EXAMPLE		
//If the script to use is in a file or URL
String[] args = new String("foo","bar");
File scriptFile = new File("path/to/script_file");
//URL scriptURL = new URL("url/to/script_file");
Script script = new SimpleScript(scriptFile, args);
// Script script = new SimpleScript(scriptURL, args);
aTask.setPreScript(script);
//If the script to use is in a Java string for example
Script script = new SimpleScript("Script_content", "type_of_language");
//where type_of_language can be any language supported by the underlying JRE
aTask.setPreScript(script);

//same construction for the post script
aTask.setPostScript(script);

//same construction for the cleaning script
aTask.setCleaningScript(script);

//same construction for the  selection script
//the last parameter is still not used in the current implementation
SelectionScript selScript = new SelectionScript(script, true);
aTask.setSelectionScript(selScript);
				</programlisting>
				<para>
					To complete your job by adding the task inside the job, just add it as followed :
				</para>
				<programlisting language="java">
//add the task to the job
job.addTask(aTask);
				</programlisting>
				<para>
					Here's some other features than can be performed on tasks such as dependencies or wallTime :
				</para>
				<programlisting language="java">
//admitting task 2 and task 3 has been create just before
//we have to create task 5.
//create a new task
JavaTask task5 = new JavaTask();
//... (fill task5 as describe above)
//then specify dependencies by using the addDependence(Task) method
task5.addDependence(task2);
task5.addDependence(task3);
//or use the addDependences(list&lt;Task&gt;) method as shown
//task5.addDependences(new ArrayList&lt;Task&gt;(task2,task3));
			</programlisting>
			<programlisting language="java">
//set this task as forked
aTask.setFork(true);
//or set a walltime
aTask.setWallTime(10000);
//you can also define a fork environment (for example)
ForkEnvironment env = new ForkEnvironment();
env.setJavaHome("Your/java/home/path");
env.setJVMParameters("-d12");
aTask.setForkEnvironment(env);
				</programlisting>
				<para>
					To have an exhaustive list of which options are available and what they are for, just go to
					<xref linkend="Create_task_explanation"/>.
				</para>
			</section>
		</section>
		
		<section xml:id="Create_native_task"><info><title>Create and add a native task</title></info>
			<para>
				<emphasis>Note</emphasis> : It is only possible to add a native task in a TaskFlow Job.
			</para>
			<para>
				To learn how to create a TaskFlow Job,
				just go to <xref linkend="Create_TaskFlow_job_xml"/> or <xref linkend="Create_TaskFlow_job_java"/>.
				Once your TaskFlow Job created, you can add as many native tasks as needed to perform an application.
				A native task can be any native application such as programs, scripts, process, etc...
			</para>
			<section xml:id="Create_native_task_xml"><info><title>Create and Add a native task using XML descriptor</title></info>
				<para>
					Just take a look at the example below to understand the syntax of a native task :
				</para>
				<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/native_task_simple.xml"/></textobject></programlisting>
				<para>
					The native Task is composed of one 'nativeExecutable' that specified the 'executable' process to use.
					A set of parameters has also be defined to provide the executable some arguments. These arguments will be
					append (according to the Runtime.exec() method) to the command line starting by your native executable.
					This example also shows the definition of two tasks with dependencies. We can easily see that 'task2_native' depends on
					'task1_native'. So 'task2_native' will be executed when 'task1_native' has finished.
					To put these two tasks inside your TaskFlow job, just put it between the 'taskFlow' tags.
					Here's how a complete ready-to-be-scheduled TaskFlow Job seems like :
				</para>
				<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/taskFlow_job_complete_with_native.xml"/></textobject></programlisting>
				<para>
					It is obviously possible to mix Java and Native task inside a taskFlow Job.
					Some other stuffs and options can be set onto a native task, here's two examples of what can be done with
					task XML descriptors :
				</para>
				<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/native_task_script.xml"/></textobject></programlisting>
				<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/native_task_walltime.xml"/></textobject></programlisting>
				<para>
					To have an exhaustive list of which options are available and what they are suppose to do, just go to
					the task explanation section at <xref linkend="Create_task_explanation"/>.
				</para>
			</section>
			<section xml:id="Create_native_task_java"><info><title>Create and add a native task using Java API</title></info>
				<para>
					To <emphasis>create a native task</emphasis> use the
					<emphasis>NativeTask</emphasis> class.
					In this type, you must specify the executable you want to start, by mentioning a
					'command line' that is in fact a String array that contains the program name and the arguments
					with which the task will be launched.
					Just take a look at the example below to see how to use the task creation Java API
					(see also Java DOCumentation of the ProActive Scheduler to learn more) :
				</para>
				<programlisting language="java">
//create a native task with the default constructor that we'll call 'aTask'
NativeTask aTask = new NativeTask();
//then, set the desired options : (for example)
aTask.setName("task 1");
aTask.setDescription("This task will do
something...");
aTask.addGenericInformation("key","value");
aTask.setPreciousResult(true);
aTask.setRerunnable(2);
aTask.setRestartTaskOnError(RestartMode.ELSEWHERE);
aTask.setResultPreview(UserDefinedResultPreview.class);
//set the command line with the parameter append to the process name
aTask.setCommandLine(new String[]{"/path/to/command/cmd","param1","param2");

//SCRIPTS EXAMPLE		
//If the script to use is in a file or URL
String[] args = new String("foo","bar");
File scriptFile = new File("path/to/script_file");
//URL scriptURL = new URL("url/to/script_file");
Script script = new SimpleScript(scriptFile, args);
// Script script = new SimpleScript(scriptURL, args);
aTask.setPreScript(script);
//If the script to use is in a Java string for example
Script script = new SimpleScript("Script_content", "type_of_language");
//where type_of_language can be any language supported by the underlying JRE
aTask.setPreScript(script);

//same construction for the post script
aTask.setPostScript(script);

//same construction for the cleaning script
aTask.setCleaningScript(script);

//same construction for the  selection script
//the last parameter is still not used in the current implementation
SelectionScript selScript = new SelectionScript(script, true);
aTask.setSelectionScript(selScript);
				</programlisting>
				<para>
					To complete your job by adding the task inside the job, just add it as followed :
				</para>
				<programlisting language="java">
					//add the task to the job
					job.addTask(aTask);
				</programlisting>
				<para>
					Here's some other features than can be performed on tasks such as dependencies or wallTime :
				</para>
				<programlisting language="java">
//admitting task 2 and task 3 has been create just before
//we have to create task 5.
//create a new task
NativeTask task5 = new NativeTask();
//... (fill task5 as describe above)
//then specify dependencies by using the addDependence(Task) method
task5.addDependence(task2);
task5.addDependence(task3);
//or use the addDependences(list&lt;Task&gt;) method as shown
//task5.addDependences(new ArrayList&lt;Task&gt;(task2,task3));
				</programlisting>
				<programlisting language="java">
//set a walltime to stop the process after the given time even it is not finish
aTask.setWallTime(10000);
				</programlisting>
				<para>
					Here's a last example that describe how to create a native task with a
					<emphasis>dynamic command</emphasis>, i.e. generated by a script called a
					generation script. The generation script can only be associated to a
					<emphasis>native</emphasis> task: the execution of a generation
					script must set the string variable <literal>command</literal>.
					The value of this variable is the command line that will be executed by
					the ProActive Scheduler as task execution. The returned string will be parsed
					and transform as a String Array according to this example ( '%' is the escape character ):
					<itemizedlist>
						<listitem><para>the string "/path/to/cmd arg1 arg 2 arg% 3 arg%%% 4 5</para></listitem>
						<listitem><para>will generate : [/path/to/cmd,arg1,arg,2,arg 3,arg% 4,5]</para></listitem>
 					</itemizedlist>
                                        where the first element is the command.
				</para>
				<programlisting language="java">
//create a new native task
NativeTask task2 = new NativeTask();
//create a generation script with a script as shown above
GenerationScript gscript = new GenerationScript(script);
//set the command to execute as a string
task2.setGenerationScript(gscript);
				</programlisting>
				<para>
					To have an exhaustive list of which options are available and what they are for, just go to
					<xref linkend="Create_task_explanation"/>.
				</para>
			</section>
		</section>
		
		<section xml:id="Create_ProActive_task"><info><title>Create and add a ProActive task</title></info>
			<para>
				<emphasis>Note</emphasis> : It is only possible to add a ProActive task only in a ProActive Job.
			</para>
			<para>
				To learn how to create a ProActive Job,
				just go to <xref linkend="Create_ProActive_job_xml"/> or <xref linkend="Create_ProActive_job_java"/>.
				Once your ProActive Job created, it is possible to just add ONE ProActive task inside your job.
			</para>
			<section xml:id="define_executable_ProActive"><info><title>Define your own ProActive executable</title></info>
				<para>
					First of all, you must know that you can create your own
					ProActive executable by implementing scheduler executable interfaces.
					What is called 'executable' is in fact, the executed process (that is a Java class in this case).
					Here's an example to create your own ProActive executable application :
				</para>
				<programlisting language="java">
public class ProActiveExample extends ProActiveExecutable {

	private int numberToFind = 5003;
	
	@Override
	public Serializable execute(ArrayList&lt;Node&gt; nodes) {
		System.out.println("ProActive job started !!");

		// create workers (on local node)
		Vector&lt;Worker&gt; workers = new Vector&lt;Worker&gt;();

		for (Node node : nodes) {
			try {
				Worker w = (Worker)PAActiveObject.newActive(Worker.class.getName(),
						new Object[] { }, node);
				workers.add(w);
			} catch (ActiveObjectCreationException e) {
				e.printStackTrace();
			} catch (NodeException e) {
				e.printStackTrace();
			}
		}

		// create controller Controller controller = new Controller(workers);
		int result = controller.findNthPrimeNumber(numberToFind);

		System.out.println("last prime : " + result);

		return result;
	}
}
				</programlisting>
				<para>
					It is also possible to get a list of arguments that you can give to the executable at its start by
					overriding the init method on a ProActive executable. How to give arguments to the task will be explain
					further.
					We get back the foo, bar and test arguments to illustrate the task creation example below :
					<programlisting language="java">
private boolean foo;
private int bar;
private String test;

@Override
public void init(Map&lt;String, Object&gt; args) {
	foo = (Boolean)args.get("foo");
	bar = (Integer)args.get("bar");
	test = args.get("test");
}
					</programlisting>
				</para>
				<para>
					As shown in a ProActive tutorial, this example uses the given nodes with the ProActive API in
					order to start 'workers' on them. The <code>execute(nodes)</code> method shows what can be done
					inside this kind of task. For more details about how to use the ProActive API,
					see the appropriate documentation.
					The complete example file can be found under 'sample/jobs_descriptors/Job_ProActive.xml'.
				</para>
				</section>
			</section>
			<section xml:id="Create_ProActive_task_xml"><info><title>Create and add a ProActive task using XML descriptor</title></info>
				<para>
					Just take a look at the example below to understand the syntax of the ProActive task :
				</para>
				<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/ProActive_task_simple.xml"/></textobject></programlisting>
				<para>
					The ProActive Task is composed of one 'proActiveExecutable' that specified the 'ProActiveExecutable' Java class to use.
					A set of parameters has also be defined to provide this executable some information. These parameters will be
					available into the <code>HashMap</code> of the <code>init(HashMap)</code> method into your <code>ProActiveExecutable</code>.
					To put this task inside your ProActive job, just put it between the 'ProActive' tags.
					On this job it is necessarily to set the number of node you desired for your ProActiveExecutable.
					Instead of deploying resources as it must be done in ProActive Suite, the resources are provides by the ProActive Scheduler.
					Here's how a complete ready-to-be-scheduled ProActive Job seems like :
				</para>
				<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/ProActive_job_complete.xml"/></textobject></programlisting>
				<para>
					Some other stuffs and options can be set onto a ProActive task, here's a new example of what can be done with
					task XML descriptors :
				</para>
				<programlisting language="xml"><textobject><textdata fileref="scheduler/xml/ProActive_task_script.xml"/></textobject></programlisting>
				<para>
					To have an exhaustive list of which options are available and what they are suppose to do, just go to
					the task explanation section at <xref linkend="Create_task_explanation"/>.
				</para>
			</section>
			<section xml:id="Create_ProActive_task_java"><info><title>Create and add a ProActive task using Java API</title></info>
				<para>
					To <emphasis>create a ProActive task</emphasis> use the
					<emphasis>ProActiveTask</emphasis> class.
					In this type, you must specify the class you want to start with, by mentioning a
					Class of extending  ProActiveExecutable. (To make your own executable see the
					proper section <xref linkend="define_executable_ProActive"/> ).
					In addition, you can add arguments with which the task will be launched.
					These launching arguments will be given to the ProActive executable as a Map.
					Just take a look at the example below to see how to use the task creation Java API
					(see also Java DOCumentation of the Scheduler to learn more) :
				</para>
				<programlisting language="java">
//create a ProActive Task using the default constructor that we'll call 'aTask'
ProActiveTask aTask = new ProActiveTask();
//then, set the desired options : (for example)
aTask.setName("task 1");
aTask.setDescription("This task will do
something...");
aTask.addGenericInformation("key","value");
aTask.setResultPreview(UserDefinedResultPreview.class);
//add arguments (optional)
aTask.addArgument("foo",new Boolean(true));
aTask.addArgument("bar",new Integer(12));
aTask.addArgument("test","test1");
//add executable class or instance
pat.setExecutableClassName("org.ow2.proactive.scheduler.examples.ProActiveExample");
//add number of nodes needed for the application
      pat.setNumberOfNodesNeeded(10);

//SCRIPTS EXAMPLE		
//If the script to use is in a file or URL
String[] args = new String("foo","bar");
File scriptFile = new File("path/to/script_file");
//URL scriptURL = new URL("url/to/script_file");
Script script = new SimpleScript(scriptFile, args);
// Script script = new SimpleScript(scriptURL, args);
aTask.setPreScript(script);
//If the script to use is in a Java string for example
Script script = new SimpleScript("Script_content", "type_of_language");
//where type_of_language can be any language supported by the underlying JRE
aTask.setPreScript(script);

//same construction for the post script
aTask.setPostScript(script);

//same construction for the cleaning script
aTask.setCleaningScript(script);

//same construction for the  selection script
//the last parameter is still not used in the current implementation
SelectionScript selScript = new SelectionScript(script, true);
aTask.setSelectionScript(selScript);
				</programlisting>
				<para>
					To complete your job by adding the task inside the job, just add it as followed :
					(note that you can only add ONE ProActive task in a ProActive Job)
				</para>
				<programlisting language="java">
//add the task to the job
job.setTask(aTask);
				</programlisting>
				<para>
					To have an exhaustive list of which options are available and what they are for, just go to
					<xref linkend="Create_task_explanation"/>.
				</para>
			</section>
			
			<section xml:id="Create_task_explanation"><info><title>Tasks options and explanations</title></info>
				<para>
					As it has been shown in the different examples, it is possible to create 3 types of tasks.
					These 3 types have some common features like name, description, scripts, etc...
					Here's the details of each of these common features :
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis>name</emphasis>
							is the name assigned to the task. It can be whatever you want as a String.
							This name must be unique for each task.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>description</emphasis> (optional)
							is a human readable description of the task.
							It is for human use only. This field is optional but it is better to set it.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>genericInformation</emphasis> (optional)
							is a way to define some information inside your task.
							This information could be read inside the policy (similar to job's one).
							It can be useful to add new complex scheduling behavior.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>preciousResult</emphasis> (optional - default is false)
							is the way to define that a result of a task is important or not. For example,
							in a job result, you could have to retrieve only some task results that are
							important for you. By setting the precious result to 'true', you'll be able
							to retrieve easily these results.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>cancelJobOnError</emphasis> (optional - default is false or the value set in the job)
							is a way to define if your job must continue if a user exception or
							error occurs during this task process. True means that the job
							will immediately stop every remaining running tasks if an error occurs in this task.
							It is useful when there is no need to go further if this task fails.
							If true, the job will be canceled if the maximum number of execution for this task has been reached.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>maxNumberOfExecution</emphasis> (optional - default is 1 or the value set in the job)
							is a way to define how many times a task will run if it ends with an exception
							or error code. If the task ends in a normal way, this property has no effect.
							If the task has exception or error more than defined in this property, 2 possibilities :
							<itemizedlist>
								<listitem>
									<para>
									cancelJobOnError=true : then the job is canceled.
									</para>
								</listitem>
								<listitem>
									<para>
									cancelJobOnError=false : then the task ends and the result is the representation of the error 
									(Exception in Java, error code in native). The job continues in a normal way.
									</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>restartTaskOnError</emphasis> (optional - default is anywhere or the value set in the job)
							is a way to define if this task have to restart on an other resource or not.
							Possible values are 'anywhere' or 'elsewhere' meaning respectively
							that the concerned task will be restart on any available resources or especially on a different one.
							A task can be restart when an exception occurred (Java Task) or an error code is returned (Native Task) and 
							if the maximum number of execution has not been reached yet. Each time an error occurred, the task is placed in
							a Faulty(n/m) status and the numberOfExecutionLeft count is decrease. n is the current number of executions and
							m is the maximum number of executions.
						</para>
						<para>
							Here is table that sum-up the different possible executions, that can be useful to know the behavior of your job :
							<figure xml:id="cancel_restart"><info><title>CancelJobOnError and RestartTaskOnError behavior</title></info>
								<mediaobject>
									<imageobject>
										<imagedata scalefit="1" width="70%" contentdepth="70%" align="center" fileref="scheduler/pics/core/cancel-restart.png" format="PNG"/>
									</imageobject>
								</mediaobject>
							</figure>
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>Walltime</emphasis> (optional)
							Task Walltime is a maximum allowed execution time of a task.
							It can be specified for any task, irrespectively of its type.
							If a task does not finish before its walltime it is terminated by the ProActive Scheduler.
							An example has been given above with the walltime specified. Note that, the walltime
							is defined in a task, thus it can be used for any type of a task.
							The general format of the walltime attribute is [hh:mm:ss], where h is hour, m is minute and s is second.
							The format still allows for more flexibility. We can define the walltime simply as “5”
							which corresponds to 5 seconds, “10” is 10 seconds, “4:10” is 4 minutes and 10 seconds, and so on. 
							
							The walltime mechanism is started just before a task is launched. If a task does finish before its walltime,
							the mechanism is canceled. Otherwise, the task is terminated. Note that, the tasks are terminated without
							any prior notice.
							
							If the walltime is specified for a Java task (as in the example) it enforces the creation of
							a forked Java task instead.
							
							When this property is defined and execution exceeds this time, the task ends with an exception.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>fork and forkEnvironment</emphasis> (optional only for Java Task)
							The purpose of a new type of a task Forked Java Task is to gain more flexibility with
							respect to the execution environment of a task.
							A new JVM is started with an inherited classpath and (possibly) redefined Java home path and JVM properties.
							It allows to use a JVM from a different provider and specify options to be passed to JVM (like memory usage). 

							A Forked Java Task is defined as a Java Task with a forkEnvironment element.

							The aim of a forkEnvironment element is providing javaHome and jvmParameters attributes.
							For any undefined attribute a default environment value will be applied. Note that, the javaHome
							attribute points only to the Java installation directory and not the Java application itself.
							
							If the javaHome is not specified then the ProActive Scheduler will execute simply a Java command assuming
							that it is defined in the user path. The 'jvmParameters' attribute is a string composed of a sequence
							of Java options divided by a space.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>parameters</emphasis> (optional, only for Java and ProActive Task)
							is a way to define some parameters to be transfered to the executable. This is best explained
							in <xref linkend="define_executable_java"/>. Each parameters is define with a name and a value
							and will be passed to the Java Executable as an <code>HashMap</code>.
						</para>
						<para>
							<emphasis>arguments</emphasis> (optional, only for native Task)
							is a way to define arguments for your native process. Each arguments is define by a value
							that will be append to the process name to create a String array command line.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>resultPreview</emphasis> (optional)
							allows to specify how the result of a task should be displayed in the
							Scheduler graphical client. The user should implement a result preview class
							(that extends
							<literal>
								org.objectweb.proactive.extensions.scheduler.common.task.ResultPreview
							</literal>
							abstract class) which specifies result rendrering in two different manners :
						</para>
						<itemizedlist>
							<listitem>
								<para>
									a textual manner, by implementing
									<literal>
										public abstract String getTextualDescription(TaskResult result);
									</literal>
									. This method, similarily to
									<literal>
										String Object.toString()
									</literal>
									should return a <literal>String</literal> bject that describes the result;
								</para>
							</listitem>
							<listitem>
								<para>
									a graphical manner, by implementing
									<literal>
										public abstract JPanel getGraphicalDescription(TaskResult result);
									</literal>
									. This method should return a Swing
									<literal>JPanel</literal>
									object that describes the result.
								</para>
							</listitem>
						</itemizedlist>
						<para>
							Some useful methods to create a specific preview class can be found in
							<literal>
								org.objectweb.proactive.extensions.scheduler.common.task.util.ResultPreviewTool
							</literal>
							, such as automatic display of an image file, or automatic translation between
							windows and unix path.
						</para>
					</listitem>
					<listitem>
						<para>
							<!-- TODO gsigety : Add more scripts examples -->
							<emphasis>scripts</emphasis> (optional)
							The ProActive scheduler supports portable scripts execution through the
							JSR 223 Java Scripting capabilities; scripts can be written in any language
							supported by the underlying Java Runtime Environment. Scripts are used in the
							ProActive Scheduler to :
						</para>
						<itemizedlist>
							<listitem>
								<para>
									Execute some simple Pre, Post and Cleaning processing: optional pre-script,
									post-script, and cleaning-script
								</para>
							</listitem>
							<listitem>
								<para>
									Select among available resources the node that suitable for the execution: optional
									selection-script can be associated to a task.
								</para>
							</listitem>
							<listitem>
								<para>
									Dynamic building of a command line for a native task: optional
									generation-script (detailed in next section).
								</para>
							</listitem>
						</itemizedlist>
						<para>
							Here are some details and examples:
						</para>
						<itemizedlist>
							<listitem>
								<para>
									<emphasis>selection script</emphasis>
									The selection script is always executed before the task itself
									on any candidate node: the execution of a selection script
									must set the boolean variable <literal>selected</literal>
									, that indicates if the candidate node is suitable for
									the execution of the associated task.
									A java helper (org.ow2.proactive.scripting.helper.selection.SelectionUtils)
									is provided for javascript, ruby and python script languages allowing user to simply
									make some kind of selections. (script samples are available in 'sample/scripts/selection' directory.)
								</para>
							</listitem>
							<listitem>
								<para>
									<emphasis>pre-script</emphasis>
									The pre-script (if used) is always executed on the node that has
									been selected by the Resource Manager <emphasis>before</emphasis>
									the execution of the task itself.
									Java helper (org.ow2.proactive.scripting.helper.filetransfer package) is also available
									for file transfer purposes to manage file copies. 
									Some script samples are available in 'sample/scripts/filetransfer' directory.
								</para>
							</listitem>
							<listitem>
								<para>
									<emphasis>post-script</emphasis> The post-script is executed on the same node
									<emphasis>after</emphasis> the task itself and only if this last one has succeed.
									The same helper than for pre-script can be used in the post-script.
								</para>
							</listitem>
							<listitem>
								<para>
									<emphasis>cleaning-script</emphasis> The cleaning-script is always
									executed by the Resource Manager <emphasis>after</emphasis> the execution
									of the task itself or after the post-script (if used).
									The same helper than for pre-script can be used in the cleaning-script.
								</para>
							</listitem>
						</itemizedlist>
						<para>
							Note : For any script engines or script implementation used in this package or brought by you,
							you must notice that :
						</para>
						<para>
							THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
							OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
							AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
							CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
							DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
							DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
							IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
							OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
						</para>
					</listitem>
				</itemizedlist>
				<para>
					Now that your have your job created, next step is to submit it to the ProActive Scheduler.
				</para>
			</section>
		</section>
		<section xml:id="Submit_a_job"><info><title>Submit a job to the Scheduler</title></info>
			<para>
				The submission will perform some verifications to ensure that a job is correctly formed.
				Then the job is inserted in the pending list and wait for executions until free resources
				become available. Once done, the job will be started on the resources deployed by the
				Resource Manager. Finally, once finished, the job goes in a finish queue and will wait until user
				to retrieve its result.
				Their are three ways to submit a job to The Scheduler : 
			</para>
			<section xml:id="Submit_a_job_GUI"><info><title>Submit a job using the Graphical User Interface (Scheduler Eclipse Plugin)</title></info>
				<para>
				To submit a job using the graphical tools, you must have first created a job XML Descriptor.
				Then refer to
				<xref linkend="Scheduler_Eclipse_Plugin"/>.
				</para>
			</section>
			<section xml:id="Submit_a_job_sh"><info><title>Submit a job using shell command</title></info>
				<para>
					Use the provided shell script <emphasis>submit.[sh|bat]</emphasis> to submit a job using command line.
					This script (bin/[os]/submit.[sh|bat]) has 1 mandatory option and 3 optional :
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>The path to the job</emphasis> file descriptor is
								mandatory (using the "-j PATH" option)
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>The URL of a started scheduler.</emphasis> (using
								the "-u URL" option) If not mentioned,
								the script will connect an existing localhost Scheduler.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>Your login</emphasis> (using the "-l login"
								option). If you use this option, only
								your password will be requested.
								Otherwise, both will be.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>The number of jobs</emphasis> to submit, by default
								only 1 will be submitted (using the "-n A_NUMBER" option).
							</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>
					For example :
					<emphasis>
						submit.[sh|bat] -j ../../sample/jobs_descriptors/Job_with_dep.xml -l login -n 12 -u //localhost/
					</emphasis>
					will submit 12 times the <literal>Job_with_dep</literal> job to a local
					ProActive Scheduler and only your password will be requested.
					Authorized username and password are defined by the administrator.
				</para>
				<para>
					For more information, use -h (or --help) option (i.e. "submit.[sh|bat] -h")
				</para>
			</section>
			<section xml:id="Submit_a_job_java"><info><title>Submit a job using Java API</title></info>
				<para>
					To connect the ProActive Scheduler and submit a Job using Java API, just proceed as following :
				</para>
				<programlisting language="java">
//join an existing ProActive Scheduler retrieving an authentication interface.
SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/");
//connect and log to the Scheduler. Valid username and password are define by the administrator.
UserSchedulerInterface scheduler = auth.logAsUser("username", "password");
// submitting a new job and get the associated id
JobId myJobId = scheduler.submit(job);
				</programlisting>
				<para>
					As you can see submitting a job will return a Job ID. This is the identification code of
					the submitted Job. It is useful to save it in order to retrieve future information on this job.
				</para>
			</section>
		</section>
		<section xml:id="get_result"><info><title>Get a job result</title></info>
			<para>
				Once a Job terminated, it is possible to get its result. You can only get the result of the job that you own.
			</para>
			<section xml:id="get_result_GUI"><info><title>Get a job result using the Graphical User Interface (Scheduler Eclipse Plugin)</title></info>
				<para>
				To get a job result using the graphical tools, please refer to
				<xref linkend="Scheduler_Eclipse_Plugin"/>.
				</para>
			</section>
			<section xml:id="get_result_sh"><info><title>Get a job result using shell command</title></info>
				<para>
					To get the result of a job using a command line,
					use the <emphasis role="bold">result.[sh|bat]</emphasis>
					script in the (bin/[os]/result.[sh|bat]) directory.
					This script has 2 optional options :
					<itemizedlist>
						<listitem>
							<para>
								The URL of a started scheduler. (using the "-u URL" option). If you
								don't use this, it will try to connect to a started scheduler on
								local host.
							</para>
						</listitem>
						<listitem>
							<para>
								Your login (using the "-l login" option). If you use this option,
								only your password will be requested. Otherwise, both will be requested.
							</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>
					It will print the result on the screen as the
					toString() Java method could have done it.
				</para>
				<para>
					For more information, use -h (or --help) option (i.e. "result.[sh|bat] -h")
				</para>
			</section>
			<section xml:id="get_result_java"><info><title>Get a job result using Java API</title></info>
				<para>
					To do it in Java, use the <emphasis role="bold">getJobResult(JobId)</emphasis>method in the
					<emphasis role="bold"> UserSchedulerInterface </emphasis> and the job ID you got when you submitted it.
					It is also possible to create a new ID based on the integer id you got.
					A job result is in fact a list of task result ordered in three lists :
				</para>
				<itemizedlist>
					<listitem>
						<para>
							A full list that contains every result
							or exception of every tasks.
						</para>
					</listitem>
					<listitem>
						<para>
							A failed list that contains every result
							or exception returned by a task that
							failed.
						</para>
					</listitem>
					<listitem>
						<para>
							And a precious result list that contains
							every result or exception returned by
							the task marked precious.
						</para>
					</listitem>
				</itemizedlist>
				<para>
					This result will be given to you exactly like
					you returned it in your executable. To know
					when a job that you have submitted has finished
					its execution, you can subscribe to the
					scheduler to be notified of some events. This
					will be explain in the next section.
				</para>
				<programlisting language="java">
// get the user interface
UserSchedulerInterface scheduler = auth.logAsUser("username", "password");
// get the result of the job
JobResult myResult = scheduler.getJobResult(myJobId);
//look at inside the JobResult to retrieve TaskResult...
				</programlisting>
			</section>
		</section>
		<section xml:id="Register_events"><info><title>Register to ProActive Scheduler events</title></info>
			<para>
				If you are <emphasis>using the Java API</emphasis>, it is possible to get events from the Scheduler. 
				In order to be notified about the scheduler activities, you can add a Scheduler listener
				that will inform you of some events, like job submitting, job or task finished, scheduling
				state changing, etc... To add a listener, just make your listener by implementing the
				<emphasis>SchedulerEventListener</emphasis> interface and add it to the scheduler. You will
				then receive the scheduler state containing some information about the current
				scheduling state. See the ProActive Scheduler JAVADOC for more details.
			</para>
			<programlisting language="java">
//make your listener
SchedulerEventListener mySchedulerEventListener = new chedulerEventListener () {
	public void jobRunningToFinishedEvent(JobInfo info){
		//if my job is finished
		if (event.getJobId().equals(myJobId)){
			//get its result
			JobResult myResult = scheduler.getJobResult(myJobId);
		}
	}
	//Implement other methods...
}
//add the listener to the scheduler specified which events you want to receive.
scheduler.addSchedulerEventListener(MySchedulerEventListener,SchedulerEvent.JOB_RUNNING_TO_FINISHED);
			</programlisting>
			<para>
				This example shows you how to listen to the scheduler events (here the finished job event
				only). But you can listen for every events you want containing in this interface.
			</para>
			<para>
				For more details and features on the user scheduler interface, please refer to the java Documentation.
			</para>
		</section>
</chapter>
