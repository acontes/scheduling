<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="../viewDocbook.css"?>
<chapter id="implementation">
  <title>An implementation of the Grid Component Model</title>

  <para>
  	The GCM is an extension of the Fractal specification, and it
  	introduce the new features using a Fractal compliant terminology.
  </para>

  <para>Fractal defines a general conceptual model, along with a programming
  application interface (API) in Java. According to the official
  documentation, the Fractal component model is '<emphasis>a modular and
  extensible component model that can be used with various programming
  languages to design, implement, deploy and reconfigure various systems and
  applications, from operating systems to middleware platforms and to
  graphical user interfaces</emphasis>'.</para>

  <para>There is a reference implementation, called Julia.</para>

  <para>We first tried to use Julia to manipulate active objects (the
  fundamental entities in ProActive), but we wouldn't have been able to reuse
  the features of the Proactive library, because of the architectures of the
  libraries.</para>

  <para>Julia manipulates a base class by modifying the bytecode or adding
  interception objects to it. On the other hand, ProActive is based on a
  meta-object protocol and provides a reference to an active object through a
  typed stub. If we wanted to use active objects with Julia, the Julia runtime
  would try to manipulate the stub, and not the active object itself. And if
  trying to force Julia to work on the same base object than ProActive, the
  control flow could not traverse both ProActive and Julia.</para>

  <para>Eventually, re-implementing ProActive using Julia could be a solution
  (a starting point could be the 'protoactive' example of Julia), but this
  would imply a full refactoring of the library, and therefore quite a few
  resources...</para>

  <para>More generally speaking, Julia is designed to work with standard
  objects, but not with the active objects of ProActive. Some features (see
  next section) would not be reusable using Julia with ProActive active
  objects.</para>

  <para>Therefore, we decided to provide our own implementation of Fractal,
  geared at Grid Computing and based on the ProActive library.</para>

  <para>This implementation is different from Julia both in its objectives and
  in the programming techniques. As previously stated, we target Grid and P2P
  environments. The programming techniques and the architecture of the
  implementation is described in a following section.</para>

  <sect1>
    <title>Specific features</title>

    <para>Consider a standard system of Fractal components: </para>

    <para><figure>
        <title>A system of Fractal components</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="components/pics/fractal.png"
                       format="PNG" />
          </imageobject>

        </mediaobject>
      </figure></para>

    <para>ProActive/Fractal features distributed components:</para>
    <para><figure>
        <title>A system of distributed ProActive/Fractal components (blue, yellow and white represent distinct locations)</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="components/pics/fractal-proactive-distributed.png"
                       format="PNG" />
          </imageobject>

        </mediaobject>
      </figure></para>

    <para>Each component is implemented as one (at least) active object:</para>
    <para><figure>
        <title>Match between components and active objects</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="components/pics/fractal-proactive-aos.png"
                       format="PNG" />
          </imageobject>

        </mediaobject>
      </figure></para>

    <para>The combination of the Fractal model with the ProActive library
    leverages the Fractal component model and provides an implementation for Grid computing.</para>

    <sect2>
      <title>Distribution</title>

      <para>Distribution is achieved in a transparent manner over the Java RMI
      protocol thanks to the use of a stub/proxy pattern. Components are
      manipulated indifferently of their location (local or on a remote
      JVM).</para>
    </sect2>

    <sect2>
      <title>Deployment framework</title>

      <para>ProActive provides a deployment framework for creating a
      distributed component system. Using a configuration file and the concept
      of virtual nodes, this framework:</para>

      <orderedlist>
        <listitem>
          <para>connects to remote hosts using supported protocols, such as
          rsh, rlogin, ssh, globus, lsf etc...</para>
        </listitem>

        <listitem>
          <para>creates JVMs on these hosts</para>
        </listitem>

        <listitem>
          <para>instantiates components on these newly created JVMs</para>
        </listitem>
      </orderedlist>
    </sect2>

    <sect2>
      <title>Activities</title>

      <para>A fundamental concept of the ProActive library is this of Active
      Objects (see <xref linkend="ProActiveBasis" />), where activities can
      actually be redefined (see also <xref linkend="ActiveObjectCreation" />)
      to customize their <emphasis role="bold">behavior</emphasis>.</para>
    </sect2>

    <sect2>
      <title>Asynchronous method calls with futures</title>

      <para>Asynchronous method calls with transparent futures is a core
      feature of ProActive (<xref linkend="FutureObjectCreation" />), and it
      allows concurrent processing. Indeed, suppose a caller invokes a method
      on a callee. This method returns a result on a component. With
      synchronous method calls, the flow of execution of the caller is blocked
      until the result of the method called is received. In the case of
      intensive computations, this can be relatively long. With asynchronous
      method calls, the caller gets a future object and will continue its
      tasks until it really uses the result of the method call. The process is
      then blocked (it is called wait-by-necessity) until the result has
      effectively been calculated.</para>
    </sect2>

    <sect2>
      <title>Collective interactions</title>

      <para>We address collective interactions (1-to-n and n-to-1 interactions
      between components) through <xref linkend="collective-interfaces" />,
      namely gathercast and multicast interfaces.</para>
    </sect2>

    <sect2>
      <title>Conformance</title>

      <para>The Fractal specification defines conformance levels for
      implementations of the API (section 7.1. of the Fractal 2
      specification). The implementation for ProActive is conformant up to
      level 3.3. In other words, it is fully compliant with the API. Generic
      factories (template components) are provided as ADL templates.</para>

      <para>We are currently implementing a set of predefined standard
      conformance tests for the Fractal specification.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Implementation specific API</title>

    <sect2>
      <title>fractal.provider</title>

      <para>The API is the same for any Fractal implementation, though some
      classes are implementation-specific:</para>

      <para>The fractal provider class, that corresponds to the
      <literal>fractal.provider</literal> parameters of the JVM, is
      <literal>org.objectweb.proactive.core.component.Fractive</literal>. The
      <literal>Fractive</literal> class acts as:</para>

      <itemizedlist>
        <listitem>
          <para>a bootstrap component</para>
        </listitem>

        <listitem>
          <para>a GenericFactory for instantiating new components</para>
        </listitem>

        <listitem>
          <para>a utility class providing static methods to create collective
          interfaces and retrieve references to
          ComponentParametersController</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Content and controller descriptions</title>

      <para>The controller description and the content description of the
      components, as specified in the method <literal>public Component
      newFcInstance(Type type, Object controllerDesc, Object contentDesc)
      throws InstantiationException</literal> of the
      <literal>org.objectweb.fractal.api.factory.Factory</literal> class,
      correspond in this implementation to the classes
      <literal>org.objectweb.proactive.core.component.ControllerDescription</literal>
      and
      <literal>org.proactive.core.component.ContentDescription</literal>.</para>
    </sect2>

    <sect2>
      <title>Collective interactions</title>

      <indexterm>
        <primary>Binding</primary>

        <secondary>Collective</secondary>
      </indexterm>

      <para>Collective interactions are an extension to the Fractal model,
      described in section <xref linkend="collective-interfaces" />, that
      relies on collective interfaces.</para>

      <para>Collective interfaces are bound using the standard Fractal binding
      mechanism.</para>
    </sect2>

    <sect2>
      <title>Requirements</title>

      <para>As this implementation is based on ProActive, several conditions
      are required (more in <xref linkend="ActiveObjectCreation" />):</para>

      <itemizedlist>
        <listitem>
          <para>the base class for the implementation of a primitive component
          has to provide an empty, no-args constructor.</para>
        </listitem>

        <listitem>
          <para>for asynchronous invocations, return types of the methods
          provided by the interfaces of the components have to be reifiable
          and methods must not throw exceptions.</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="componentArchitecture">
    <title>Architecture and design</title>

    <para>The implementation of the Fractal model is achieved by reusing the
    extensible architecture of ProActive, notably the meta-object protocol and
    the management of the queue of requests. As a consequence, components are
    fully compatible with standard active objects and as such, inherit from
    the features active objects exhibit: mobility, security, deployment
    etc.</para>

    <para>A fundamental idea is to manage the non-functional properties at the
    meta-level: <emphasis role="bold">each component is actually an active
    object</emphasis> with dedicated meta-objects in charge of the component
    aspects.</para>

    <sect2>
      <title>Meta-object protocol</title>

      <para>ProActive is based on a meta-object protocol (MOP), that allows
      the addition of many aspects on top of standard Java objects, such as
      asynchronism and mobility. Active objects are referenced indirectly
      through stubs: this allows transparent communications, would the active
      objects be local or remote.</para>

      <para>The following diagram explains this mechanism:</para>

      <para>Java objects 'b' and 'a' can be in different virtual machines (the
      network being represented here between the proxy and the body, though
      the invocation might be local). Object 'b' has a reference on active
      object 'a' (of type <literal>A</literal>) through a stub (of type
      <literal>A</literal> because it is generated as a subclass of
      <literal>A</literal>) and a proxy. When 'b' invokes a method on
      '<literal>stub_A</literal>', the invocation is forwarded through the
      communication layer (possibly through a network) to the body of the
      active object. At this point, the call can be intercepted by
      meta-objects, possibly resulting in induced actions, and then the call
      is forwarded to the base object 'a'.</para>

      <para><figure>
          <title>ProActive's Meta-Objects Protocol.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="components/pics/standard-mop.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The same idea is used to manage components: we just add a set of
      meta-objects in charge of the component aspects.</para>

      <para>The following diagram shows what is changed:</para>

      <para>A new set of meta-objects, managing the component aspect
      (constituting the controller of the component, in the Fractal
      terminology), is added to the active object 'a'. The standard ProActive
      stub (that gives a representation of type A on the figure) is not used
      here, as we manipulate components. In Fractal, a reference on a
      component is of type <literal>Component</literal>, and references to
      interfaces are of type <literal>Interface</literal>. 'b' can now
      manipulate the component based on 'a' through a specific stub, called a
      <emphasis>component representative</emphasis>. This <emphasis>component
      representative</emphasis> is of type <literal>Component</literal>, and
      also offers references to control and functional interfaces, of type
      <literal>Interface</literal>. Note that classes representing functional
      interfaces of components are generated on the fly: they are specific to
      each component and can be unknown at compile-time.</para>

      <para>Method invocations on Fractal interfaces are reified and
      transmitted (possibly through a network) to the body of the active
      object corresponding to the component involved. All standard operations
      of the Fractal API are now accessible.</para>

      <para><figure>
          <title>The ProActive MOP with component meta-objects and component
          representative</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="components/pics/components-mop.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Components vs active objects</title>

      <para>In our implementation, because we make use of the MOP's
      facilities, all components are constituted of one active object (at
      least), are they composite or primitive components. If the component is
      a composite, and if it contains other components, then we can say it is
      constituted of several active objects. Also, if the component is
      primitive, but the programmer of this component has put some code within
      it for creating new active objects, the component is again constituted
      of several active objects.</para>

      <para>As a result, a composite component is an active object built on
      top of the <literal>CompositeComponent</literal> class, and a parallel
      component is built on top of the <literal>ParallelComponent</literal>
      class. These classes are empty classes, because for composite and
      parallel components, all the action takes place in the meta-level. But
      they are used as a base to build active objects, and their names help to
      identify them with the IC2D visual monitoring tool.</para>
    </sect2>

    <sect2>
      <title>Method invocations on components interfaces</title>

      <para>Invoking a method on an active object means invoking a method on
      the stub of this active object. What usually happens then is that the
      method call is reified as a <literal>Request</literal> object and
      transferred (possibly through a network) to the body of the active
      object. It is then redirected towards the queue of requests, and
      delegated to the base object according to a customizable serving policy
      (standard is FIFO).</para>

      <para>Component requests, on the other hand, are tagged so as to
      distinguish between functional requests and controller requests. A
      functional request targets a functional interface of the component,
      while a controller request targets a controller of the component.</para>

      <para>Like in the standard case (without components), requests are
      served from the request queue. The serving policy has to be FIFO to
      ensure coherency. <emphasis role="bold">This is where the life cycle of
      the components is controlled</emphasis>: the dispatching of the request
      is dependent upon the nature of the request, and corresponds to the
      following algorithm:</para>

      <screen>
  loop
        if componentLifeCycle.isStarted()
                get next request
                // all requests are served
        else if componentLifeCycle.isStopped()
                get next controller request
                // only controller requests are served
        ;
        if gotten request is a component life cycle request
                if request is start --&gt; set component state to started ;
                if request is stop --&gt; set component state to stopped ;
        ;
; </screen>
    </sect2>
  </sect1>
</chapter>