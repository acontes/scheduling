<!-- Converted by db4-upgrade version 1.0 -->

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="TimIt"><info><title>TimIt API</title></info>
    
    <indexterm>
        <primary>TimIt</primary>
    </indexterm>
    <section><info><title>Overview</title></info>
        
        <para>
            TimIt offer a complete solution to benchmark an application.
            It is an API which provide some advanced timing and event
            observing services. Benchmarking your ProActive application
            will permit you to enhance performance of it. Thanks to
            <emphasis>generated statistics charts</emphasis>
            , you will be able to determine critical points of your
            application.
        </para>
        <para>
            Different kind of statistics can be done. You can setup
            different timers with
            <emphasis>hierarchical capabilities</emphasis>
            and see them in charts. Event observers can be placed to
            study, for example, communication pattern between your
            application's workers.
        </para>
        <para>
            TimIt generate charts and results XML file, with exact
            timing and event observers values. Here are some examples of
            charts and XML files generated by TimIt :
        </para>
        <para>
            <mediaobject>
                <imageobject>
                    <imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="timit/pics/chartsExamples.png" format="PNG"/>
                </imageobject>
            </mediaobject>
            <programlisting xml:lang="xml">&lt;timit&gt;
  &lt;FinalStatistics name="Example2 4" runs="10" timeoutErrors="0"
                   date="2006-11-05 10:46:56.742"&gt;

    &lt;timers&gt;
      &lt;timer name="total"
             min="2095.0" avg="2191.250" max="2357.0" dev="1.603" sum="2187.750"&gt;
        &lt;timer name="work"
               min="1453.0" avg="1466.000" max="1473.0" dev="0.951" sum="0.000" /&gt;
        &lt;timer name="init"
               min="147.0" avg="175.250" max="205.0" dev="2.932" sum="0.000" /&gt;
        &lt;timer name="end"
               min="467.0" avg="546.500" max="679.0" dev="1.439" sum="0.000" /&gt;
      &lt;/timer&gt;
    &lt;/timers&gt;

    &lt;events&gt;
      &lt;event name="nbComms" min="92.000" avg="92.000" max="92.000" dev="0.000" /&gt;
      &lt;event name="commPattern" value="Too complex value, first run shown"&gt;.
10  0 13  0 
 0 13  0 10 
13  0 10  0 
 0 10  0 13
      &lt;/event&gt;
      &lt;event name="densityPattern" value="Too complex value, first run shown"&gt;.
  20    0 2080    0 
   0 2080    0   20 
2080    0   20    0 
   0   20    0 2080
      &lt;/event&gt;
    &lt;/events&gt;


    &lt;informations&gt;
      &lt;deployer jvm="Java HotSpot(TM) Client VM 1.5.0_06-64 - Version 1.5.0_06"
                os="ppc Mac OS X 10.4.8" processors="1" /&gt;
    &lt;/informations&gt;


  &lt;/FinalStatistics&gt;

&lt;/timit&gt;</programlisting>
        </para>
    </section>
    <section><info><title>Quick start</title></info>
        
        <section><info><title>Define your TimIt configuration file</title></info>
            
            <para>
                Configuring TimIt is done through an XML configuration
                file which is axed around four major tags :
            </para>
            <section><info><title>Global variables definition</title></info>
                
                <para>
                    This part set variables which can be used both
                    inside this file as you can see in next parts, but
                    also in
                    <emphasis>ProActive</emphasis>
                    descriptor file.
                </para>
                <para>
                    TimIt offer a nice tool to deal with variables and
                    redundancy : the
                    <emphasis>sequences variables</emphasis>
                </para>
                <para>
                    These variables are very useful to reduce your
                    configuration file size and its management.
                </para>
                <para>
                    A
                    <emphasis>sequence</emphasis>
                    is a list of values for a variable. In our example,
                    <emphasis>NP</emphasis>
                    is a sequence variable which have values
                    <emphasis>4</emphasis>
                    and
                    <emphasis>8</emphasis>
                    and the
                    <emphasis>benchmark</emphasis>
                    tag will be
                    <emphasis>expanded</emphasis>
                    into two benchmark tags : one with NP value set to 4
                    and the other with NP value set to 8.
                </para>
                <para>
                    If sequence variables are used in a
                    <emphasis>Serie</emphasis>
                    's attribute, you will expand this Serie into as
                    tags as you have values in your sequence.
                </para>
                <para>
                    For example, these two examples are equivalents :
                </para>
                <programlisting xml:lang="xml">&lt;timit&gt;

  &lt;globalVariables&gt;
    &lt;descriptorVariable name="ALGO" value="Algo1,Algo2"/&gt;
    &lt;descriptorVariable name="NP"   value="4,8"/&gt;
    &lt;descriptorVariable name="TEST" value="#1"/&gt;
  &lt;/globalVariables&gt;

  &lt;serie (...) result="${ALGO}"&gt;
    &lt;benchmarks&gt;
      &lt;benchmark name="Test ${TEST} : algo ${ALGO} on ${NP} nodes" (...)/&gt;
    &lt;/benchmarks&gt;
  &lt;/serie&gt;

&lt;/timit&gt;&lt;/programlisting&gt;

        &lt;programlisting lang="xml"&gt;&lt;timit&gt;

  &lt;globalVariables&gt;
    &lt;descriptorVariable name="TEST" value="#1"/&gt;
  &lt;/globalVariables&gt;
  
  &lt;serie (...) result="Algo1"&gt;
    &lt;benchmarks&gt;
      &lt;benchmark name="Test #1 : algo Algo1 on 4 nodes" (...)/&gt;
      &lt;benchmark name="Test #1 : algo Algo1 on 8 nodes" (...)/&gt;
    &lt;/benchmarks&gt;
  &lt;/serie&gt;
  
  &lt;serie (...) result="Algo2"&gt;
    &lt;benchmarks&gt;
      &lt;benchmark name="Test #1 : algo Algo2 on 4 nodes" (...)/&gt;
      &lt;benchmark name="Test #1 : algo Algo2 on 8 nodes" (...)/&gt;
    &lt;/benchmarks&gt;
  &lt;/serie&gt;

&lt;/timit&gt;</programlisting>
                <para>
                    <emphasis>Important</emphasis>
                    :
                </para>
                <para>
                    <emphasis>Sequences</emphasis>
                    variables are not handled by
                    <emphasis>ProActive</emphasis>
                    descriptor files, so do not use same names for
                    ProActive descriptor and sequence variable names to
                    avoid bad overwriting. To do it, you should prefer
                    overwriting in
                    <emphasis>benchmark</emphasis>
                    tag like this :
                </para>
                <programlisting xml:lang="xml">&lt;benchmark name="Test ${TEST} : algo ${ALGO} on ${NP} nodes" (...) &gt;
  &lt;descriptorVariable name="NBNODES" value="${NP} /&gt;
&lt;/benchmark&gt;</programlisting>
                <para>
                    <emphasis>Note</emphasis>
                    :
                </para>
                <para>
                    You can use
                    <emphasis>sequences</emphasis>
                    without using variables with
                    <literal>#{...}</literal>
                    pattern :
                </para>
                <programlisting xml:lang="xml">&lt;benchmark name="Test ${TEST} : algo #{Algo1,Algo2} on ${NP} nodes" (...) &gt;
  &lt;descriptorVariable name="NBNODES" value="${NP} /&gt;
&lt;/benchmark&gt;</programlisting>
            </section>
            <section><info><title>Serie</title></info>
                
                <para>
                    A Serie represent a suite of benchmarks. For
                    example, if you want to benchmark two algorithms
                    with different parameters each, you can specify two
                    Series (one for each algorithm) and then specify
                    different benchmarks for all parameters.
                </para>
                <para>Description of the attributes :</para>
                <itemizedlist>
                    <listitem>
                        <para>
                            [CAN]
                            <emphasis>descriptorBase</emphasis>
                            : the file containing the base ProActive
                            deployment descriptor
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>class</emphasis>
                            : the class of your application which is
                            <emphasis>Startable</emphasis>
                            (see
                            <emphasis>section 2.2</emphasis>
                            )
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>result</emphasis>
                            : the output file for writing final results
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [CAN]
                            <emphasis>errorFile</emphasis>
                            : if an error occur (recoverable), logs will
                            be outputed into this file
                        </para>
                    </listitem>
                </itemizedlist>
            </section>
            <section><info><title>Chart definition</title></info>
                
                <para>
                    Here you specify parameters for the charts. Those
                    charts will be generated thanks to benchmark
                    results.
                </para>
                <para>Description of the attributes :</para>
                <para>
                    Other attributes are chart's type specific :
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>type</emphasis>
                            : the type of chart you want to create
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>title</emphasis>
                            : your chart title
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>subtitle</emphasis>
                            : your chart subtitle
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>xaxislabel</emphasis>
                            : the X axis label
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>yaxislabel</emphasis>
                            : the Y axis label
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [CAN]
                            <emphasis>width</emphasis>
                            : the width of the output chart
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [CAN]
                            <emphasis>height</emphasis>
                            : the height of the output chart
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>filename</emphasis>
                            : the chart output filename (will produce
                            both a .PNG and .SVG files)
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    Other attributes are chart's type specific :
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            [CAN]
                            <emphasis>filter</emphasis>
                            : the name of the counter (event) you want
                            to involve in this chart. All activated
                            counters (events) are involved if not
                            specified (available only for
                            <literal>HierarchicalBarChart</literal>
                            and
                            <literal>Line2dChart</literal>
                            )
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>tag</emphasis>
                            : the tag to deal with (
                            <literal>timers</literal>
                            or
                            <literal>events</literal>
                            ) must be associated with
                            <emphasis>attribute</emphasis>
                            (available only for
                            <literal>Line2dChart</literal>
                            )
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>attribute</emphasis>
                            : the attribute value (
                            <literal>min</literal>
                            ,
                            <literal>average</literal>
                            ,
                            <literal>max</literal>
                            or
                            <literal>deviation</literal>
                            ) to use for the chart (available only for
                            <literal>Line2dchart</literal>
                            )
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [CAN]
                            <emphasis>legendFormatMode</emphasis>
                            : the format of the legend (
                            <literal>Default</literal>
                            ,
                            <literal>None</literal>
                            ,
                            <literal>K1000</literal>
                            ,
                            <literal>K1024</literal>
                            ) to show value in legent as standard, power
                            of 2 or power of 10 numbers (available only
                            for
                            <literal>MatrixChart</literal>
                            )
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [CAN]
                            <emphasis>scaleMode</emphasis>
                            : the scale mode (
                            <literal>Default</literal>
                            ,
                            <literal>Linear</literal>
                            ,
                            <literal>Logarithmic</literal>
                            ) for che chart (available only for
                            <emphasis>MatrixChart</emphasis>
                            )
                        </para>
                    </listitem>
                </itemizedlist>
            </section>
            <section><info><title>Benchmark suite definition</title></info>
                
                <para>
                    Define the suite of tests with different parameters.
                    Each test will generate a result file and an entry
                    in chart.
                </para>
                <para>Description of the attributes :</para>
                <itemizedlist>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>name</emphasis>
                            : the name of this benchmark. Will be set in
                            result file.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>run</emphasis>
                            : the number of runs you want to perform.
                            Final result will give the
                            min/average/max/deviation between these
                            runs.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [CAN]
                            <emphasis>warmup</emphasis>
                            : the number of "untimed" runs you want to
                            perform before starting the real runs.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [CAN]
                            <emphasis>timeout</emphasis>
                            : the time in seconds before restarting a
                            run (with a maximum of 3 restarts per
                            benchmark).
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [CAN]
                            <emphasis>descriptorGenerated</emphasis>
                            : the ouput file where TimIt but the
                            ProActive deployment descriptor.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [CAN]
                            <emphasis>removeExtremums</emphasis>
                            : if
                            <literal>true</literal>
                            , max and min values between all runs will
                            be removed.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [CAN]
                            <emphasis>note</emphasis>
                            : the text entered here will be copied into
                            result file. Useful for specifying launch
                            environnement.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>parameters</emphasis>
                            : the parameters to launch your application.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            [MUST]
                            <emphasis>output</emphasis>
                            : result of all runs will be outputted into
                            this output file.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    In addition to these attributes, you can specify
                    descriptorVariable tags which will be copied into
                    generated ProActive deployment descriptor file.
                </para>
                <para>
                    Here is a complete example of a configuration file :
                    <programlisting xml:lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;timit&gt;       
    
  &lt;!-- GLOBAL VARIABLES DEFINITION
       Will replace those in ProActive deployment descriptor --&gt;
  &lt;globalVariables&gt;
    &lt;descriptorVariable name="VMARGS" value="-Xmx32M -Xms32M" /&gt;
    &lt;descriptorVariable name="CLASS_PREFIX"
                        value="org.objectweb.proactive.examples.timit" /&gt;
    &lt;descriptorVariable name="NP" value="4,8" /&gt;
    &lt;descriptorVariable name="RUN" value="1" /&gt;
    &lt;descriptorVariable name="WARMUP" value="0" /&gt;
  &lt;/globalVariables&gt;


  &lt;!-- Running example2 suite and generate different charts --&gt;
  &lt;serie descriptorBase="${PROJECT_PATH}/descriptors/TimIt.xml"
         result="${PROJECT_PATH}/results/example2.4-8.xml"
         class="${CLASS_PREFIX}.example2.Launcher"&gt;

    &lt;charts&gt;
      &lt;chart type="HierarchicalBarChart"
             filter="total,init,foo"
             title="Example2 on 4 and 8 nodes"
             subtitle="Timing values" width="800" height="600"
             xaxislabel="Benchmarks" yaxislabel="Time in seconds"
             filename="${PROJECT_PATH}/results/example2.Timing" /&gt;
      &lt;chart type="MatrixChart"
             eventName="commPattern"
             title="Example2"
             subtitle="Communications pattern"
             xaxislabel="Receiver rank" yaxislabel="Sender rank"
             scalemode="logarithmic" legendFormatMode="pow2"
             filename="${PROJECT_PATH}/results/example2.Pattern" /&gt;
      &lt;chart type="Line2dChart"
             tag="events" filter="nbComms" attribute="avg"
             title="Example2"
             subtitle="Total number of communications"
             xaxislabel="Benchmarks" yaxislabel="Nb communications"
             filename="${PROJECT_PATH}/results/example2.nbComms" /&gt;
    &lt;/charts&gt;

    &lt;benchmarks&gt;
      &lt;benchmark name="Example2 ${NP}"
                 run="${RUN}" warmup="${WARMUP}" timeout="100"
                 descriptorGenerated="${PROJECT_PATH}/descriptors/generated.xml"
                 removeExtremums="true"
                 note="My first test"
                 parameters="${PROJECT_PATH}/descriptors/generated.xml ${NP}"
                 output="${PROJECT_PATH}/results/example2-${NP}.xml"&gt;
        &lt;descriptorVariable name="NODES" value="${NP}" /&gt;
        &lt;descriptorVariable name="TIMIT_ACTIVATE"
                 value="total,init,work,end,foo,densityPattern,commPattern,nbComms"/&gt;
      &lt;/benchmark&gt;
    &lt;/benchmarks&gt;
  &lt;/serie&gt;

&lt;/timit&gt;</programlisting>
                </para>
            </section>
        </section>
        <section><info><title>
                Add time counters and event observers in your source
                files
            </title></info>
            
            <para>
                <orderedlist>
                    <listitem>
                        <para>
                            Main class have to implement
                            <emphasis>Startable</emphasis>
                            interface
                            <programlisting xml:lang="java">public class Example implements Startable {
  
  /** TimIt needs a noarg constructor (can be implicit) **/
  public Example() {}

  /** The main method is not used by TimIt **/
  public static void main( String[] args ) {
    new Example().start(args);
  }

  /** Invoked by TimIt to start your application **/
  public void start( String[] args ) {
    // Creation of the Timed object(s)
    // It can be by example :
    //   - a classic java object
    //   - an active object
    //   - a group of objects
    Worker workers = ProSPMD.newSPMDGroup(...);

    // You have to create an instance of TimItManager and
    // give to it the Timed objects
    TimItManager tManager = TimItManager.getInstance();

    // Timed objects start their job
    workers.start();

    // At the and of you application, you must invoke
    // the getBenchmarkStatistics to retrieve the results
    // from the Timed objects
    BenchmarkStatistics bStats = tManager.getBenchmarkStatistics();

    // Then, you can modify or print out the results
    System.out.println(bStats);
  }
}</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Analyzed class have to extend
                            <emphasis>Timed</emphasis>
                            <programlisting xml:lang="java">public class Worker extends Timed {
  
  /** Declaration of all TimerCounters and EventObservers **/
  private TimerCounter T_TOTAL, T_INIT, T_WORK, T_COMM;
  private EventObserver E_COMM, E_MFLOPS;

  public void start() {
    // Register the TimerCounters and EventObservers
    T_TOTAL = TimIt.add(new HierarchicalTimerCounter("total"));
    T_INIT = TimIt.add(new HierarchicalTimerCounter("init"));
    T_WORK = TimIt.add(new HierarchicalTimerCounter("work"));
    T_COMM = TimIt.add(new HierarchicalTimerCounter("comms"));
    E_MFLOPS = TimIt.add(new DefaultEventObserver("mdlops"));
    E_COMM = TimIt.add(new CommEventObserver(
               "communicationPattern", groupSize, timedID));

    // You must activate TimIt before using your counters and observers
    // According to the 'proactive.timit.activation' property value, it
    // will activate or not concerned TimerCounters (EventObservers)
    TimIt.activation();

    // The you can use your counters and observers
    // (better examples of usage in next section)
    T_TOTAL.start();
      for( int destID=0; destID&lt;nbTimeds; destID++ ) {
        TimIt.notifyObservers(new CommEvent(E_COMM,destID,1));
      }
    T_TOTAL.stop();
    TimIt.notifyObservers(new Event(E_MFLOPS,mflops));

    // At the end, you have invoke finalization method to return results
    // to the startable object
    TimIt.finalization(timedID,"Worker "+timedID+" OK");
  }
}</programlisting>
                        </para>
                    </listitem>
                </orderedlist>
            </para>
        </section>
    </section>
    <section><info><title>Usage</title></info>
        
        <para>
            TimIt provide different kind of services. By combinig them,
            you will be able to measure many parameters of your
            application. TimIt package contains few examples for using
            these services in your application.
        </para>
        <section><info><title>Timer counters</title></info>
            
            <para>
                It will help you to time some piece of code in your
                application. For example you can get total,
                initialization, working and communication time. These
                counters are hierarchicals. It means that time values
                will be defined by counter dependances.
            </para>
            <para>Example of hierarchy :</para>
            <itemizedlist>
                <listitem>
                    <para>Total time = 60 seconds</para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                Initialization time = 10 seconds
                            </para>
                            <itemizedlist>
                                <listitem>
                                    <para>
                                        Communication time = 4 seconds
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                        <listitem>
                            <para>Working time = 50 seconds</para>
                            <itemizedlist>
                                <listitem>
                                    <para>
                                        Communication time = 17 seconds
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                    </itemizedlist>
                </listitem>
            </itemizedlist>
            <para>
                Here you can see
                <emphasis>communication</emphasis>
                part both in
                <emphasis>initialization</emphasis>
                and
                <emphasis>working</emphasis>
                time.
            </para>
            <para>The code associated to this example is :</para>
            <para>
                <programlisting xml:lang="java">T_TOTAL.start();

  T_INIT.start();
    // Initialization part...
    T_COMM.start();
      // Communications...
    T_COMM.stop();
  T_INIT.stop();

  T_WORK.start();
    // Working part...
    T_COMM.start();
      // Communications...
    T_COMM.stop();
  T_WORK.stop();

T_TOTAL.stop();</programlisting>
            </para>
        </section>
        <section><info><title>Event observers</title></info>
            
            <para>
                It will help you to keep an eye on different events that
                occur in your application.
            </para>
            <para>There is two types of events :</para>
            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>Default event</emphasis>
                    </para>
                    <para>
                        This event manage a
                        <emphasis>single value</emphasis>
                        (a
                        <emphasis>
                            <emphasis>double</emphasis>
                        </emphasis>
                        ). It can be useful to compute mflops or total
                        number of performed communications.
                    </para>
                    <para>Example of usage :</para>
                    <programlisting xml:lang="java">// Initialization
int collapseOperation = DefaultEventData.SUM;
int notifyOperation = DefaultEventData.SUM;
EventObserver E_NBCOMMS = TimIt.add(
         new DefaultEventObserver("nbComms", collapseOperation, notifyOperation));</programlisting>
                    <para>
                        Value of
                        <emphasis>notifyOperation</emphasis>
                        determine what operation to perform between
                        notifications.
                    </para>
                    <para>
                        Value of
                        <emphasis>collapseOperation</emphasis>
                        determine what operation to perform between
                        Timed objects.
                    </para>
                    <programlisting xml:lang="java">// Utilization
for( int i=0; i&lt;10; i++ ) {
  TimIt.notifyObservers( new Event(E_NBCOMMS, 1) );
}</programlisting>
                    <para>
                        For each Timed object, nbComms value will be 10,
                        and final value would be 30 if we had 3 Timed
                        objects.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Communication event</emphasis>
                    </para>
                    <para>
                        This event were designed for communications. It
                        manage a
                        <emphasis>square matrix</emphasis>
                        which can be used by example to determine
                        topology of communications between Timed
                        objects.
                    </para>
                    <para>Example of usage :</para>
                    <programlisting xml:lang="java">// Initialization
EventObserver E_COMM = TimIt.add(
         new CommEventObserver("mflops", groupSize, timedID);</programlisting>
                    <para>
                        Value of groupSize represent the number of Timed
                        objects which are involved in these
                        communications.
                    </para>
                    <para>
                        Value of timedID represent an identification
                        number which represent the current Timed object
                        (like the rank).
                    </para>
                    <programlisting xml:lang="java">// Utilization
int destID = (timedID + 1) % groupSize;
TimIt.notifyObservers( new CommEvent(E_COMM, destID, 1) );</programlisting>
                    <para>
                        Between each notification an addition with the
                        old value will be performed. Then the collapsing
                        operation between the Timed objects will be an
                        sum. In this case, we will obtain a matrix
                        showing the toplogy of our application.
                    </para>
                    <para>
                        In line we have the sender, and in column with
                        have the receiver. Here we obtain a ring
                        topology :
                    </para>
                    <programlisting xml:lang="java">1 0 0 0
0 0 0 1
0 0 1 0
0 1 0 0</programlisting>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section><info><title>TimIt extension</title></info>
        
        <para>
            TimIt package can be found in
            <emphasis>
                org.objectweb.proactive.benchmarks.timit
            </emphasis>
            . We try to make easy as possible the way to add a new
            feature to this application. To do so, TimIt is organized in
            5 major points which can be extended :
        </para>
        <section><info><title>Configuration file</title></info>
            
            <para>
                The subpackage
                <emphasis>timit.config</emphasis>
                contains all classes related to the configuration file
                management.
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>ConfigReader</emphasis>
                    </para>
                    <para>
                        This class read the configuration file. It deal
                        with
                        <emphasis>globalVariable</emphasis>
                        and
                        <emphasis>serie</emphasis>
                        tags.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Tag</emphasis>
                    </para>
                    <para>
                        All created tags (except
                        <emphasis>globalVariable</emphasis>
                        ) have to extend this class. It makes easier the
                        way to read tag's attributes. If you want to
                        create a new tag, extend this class and take
                        example on a new tag, like
                        <emphasis>Benchmark</emphasis>
                        , which is a good example.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                <emphasis>Example :</emphasis>
            </para>
            <para>
                Suppose you want to add attribute
                <emphasis>myOption</emphasis>
                to the
                <emphasis>Benchmark</emphasis>
                tag where the default value is
                <emphasis>1</emphasis>
                .
            </para>
            <programlisting xml:lang="java">// Add these lines in the get method of Benchmark class
if (name.equals("myOption")) {
  return "1";
}</programlisting>
            <para>
                Then, you will be able to use it like this it
                <emphasis>TimIt</emphasis>
                class:
            </para>
            <programlisting xml:lang="java">String result = bench.get("myOption");
// ... and do whatever you want with it...</programlisting>
        </section>
        <section><info><title>Timer counters</title></info>
            
            <para>
                The subpackage
                <emphasis>timit.util.timing</emphasis>
                contains all classes related to the timing management.
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>HierarchicalTimer</emphasis>
                    </para>
                    <para>
                        This class will contain values of all timer
                        counters. Here is all the "intelligency" of the
                        timer. For example, if you want to use
                        nanoseconds instead of milliseconds, you should
                        extend this class and overwrite
                        <literal>getCurrentTime()</literal>
                        method.
                    </para>
                </listitem>
            </itemizedlist>
        </section>
        <section><info><title>Event observers</title></info>
            
            <para>
                The subpackage
                <emphasis>timit.util.observing</emphasis>
                contains all classes related to the event observers
                management. Existant event observers are default and
                communication specific. Default (
                <emphasis>DefaultEventObserver</emphasis>
                ) is base on a single value, while the communication
                specific (
                <emphasis>CommEventObserver</emphasis>
                ) is based on 2D square matrix.
            </para>
            <para>
                Event observers are based on
                <emphasis>observer/observaSuble</emphasis>
                design pattern.
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>EventObserver</emphasis>
                    </para>
                    <para>
                        This interface must be implemented by all kind
                        of event observers. These implementations will
                        have to deal with an
                        <emphasis>EventData</emphasis>
                        .
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Event</emphasis>
                    </para>
                    <para>
                        Each kind of event should have its own
                        <emphasis>Event</emphasis>
                        implementation. An instance of this event will
                        be passed at each notification.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>EventData</emphasis>
                    </para>
                    <para>
                        Like
                        <emphasis>HierarchicalTimer</emphasis>
                        for the timing service,
                        <emphasis>EventData</emphasis>
                        is the "intelligence" of event observing. It
                        will contain all data values for a particular
                        <emphasis>Timed</emphasis>
                        object. It also contain a
                        <literal>collapseWith()</literal>
                        method which will be used to merge data values
                        from all
                        <emphasis>Timed</emphasis>
                        objects.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>EventObservable</emphasis>
                    </para>
                    <para>
                        For performance purpose, there is to
                        implementations of this interface. A
                        <emphasis>FakeEventObservable</emphasis>
                        and a
                        <emphasis>RealEventObservable</emphasis>
                        .
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>EventDataBag</emphasis>
                    </para>
                    <para>
                        This class contains data values from all
                        <emphasis>Timed</emphasis>
                        objects. You are able to get it through an
                        <emphasis>EventStatistics</emphasis>
                        .
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>EventStatistics</emphasis>
                    </para>
                    <para>
                        When a benchmark run is done, you can get a
                        <emphasis>BenchmarkStatistics</emphasis>
                        which contains both timer and event statistics.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                <emphasis>Example :</emphasis>
            </para>
            <para>
                Suppose you want to create a new kind of
                <emphasis>Event</emphasis>
                which work with a 3D matrix instead of 2D matrix like
                <emphasis>CommEventObserver</emphasis>
                .
            </para>
            <para>You will have to implement 2 or 3 classes :</para>
            <orderedlist>
                <listitem>
                    <para>
                        <emphasis>MyEventObserver</emphasis>
                        which implements
                        <emphasis>EventObserver</emphasis>
                    </para>
                    <para>
                        It will receive notifications and transmit them
                        to your
                        <emphasis>EventData</emphasis>
                        .
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>MyEventData</emphasis>
                        which implements
                        <emphasis>EventData</emphasis>
                    </para>
                    <para>
                        It will contain your 3D matrix computed from
                        your notifications.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>MyEvent</emphasis>
                        which implements
                        <emphasis>Event</emphasis>
                    </para>
                    <para>
                        It will be passed at each notification of your
                        observer and will contain necessary data to
                        update your 3D matrix.
                    </para>
                    <para>
                        Notice that you can reuse an other
                        <emphasis>Event</emphasis>
                        implementation if existing ones are sufficient.
                    </para>
                </listitem>
            </orderedlist>
        </section>
        <section><info><title>Chart generation</title></info>
            
            <para>
                The subpackage
                <emphasis>timit.util.charts</emphasis>
                contains all classes related to charts generation. This
                service is based on
                <emphasis>JFreeChart</emphasis>
                API (http://www.jfree.org/jfreechart/). Three major type
                of charts are proposed with
                <emphasis>TimIt</emphasis>
                :
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis>HierarchicalBarChart</emphasis>
                        , used to represent a serie of hierarchical
                        timing statistics.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>Line2dChart</emphasis>
                        , used to represent a serie of single values.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>MatrixChart</emphasis>
                        , used to represent communications specific
                        event observer.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Remember that in configuration file, choosing your chart
                type is done through the
                <literal>type</literal>
                attribute of
                <literal>chart</literal>
                tag. Actually, it represent the classname used to handle
                your chart creation.
            </para>
            <para>
                By the way, to create an new kind of chart, you just
                have to implement the
                <emphasis>Chart</emphasis>
                interface. So, you will have access to XML results file,
                full
                <emphasis>BenchmarkStatistics</emphasis>
                and all chart parameters given in configuration file
                (see
                <emphasis>section 4.1</emphasis>
                to add new attributes).
            </para>
            <para>
                If you need a very complex rendering chart method, you
                can implement your own renderer like we did for
                <emphasis>HierarchicalBarChart</emphasis>
                . Take example on this class, and see
                <emphasis>JFreeChart</emphasis>
                documentation.
            </para>
        </section>
    </section>
</chapter>
