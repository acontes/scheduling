<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="FileTransfer">
  <title>ProActive File Transfer Model</title>

  <sect1 id="FileTransfer_html_intro">
    <title>Introduction and Concepts</title>

    <para>Currently ProActive provide support for the following type of
    transfers:</para>

    <itemizedlist>
      <listitem>
        <para>To a remote node (<emphasis role="bold">Push</emphasis>)</para>
      </listitem>

      <listitem>
        <para>From a remote node (<emphasis
        role="bold">Pull</emphasis>)</para>
      </listitem>
    </itemizedlist>

    <para>The transfer can take place at any of the following moments:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Deployment</emphasis> Time: At the
        beginning of the application to input the data.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Retrieval</emphasis> Time: At the end of
        the application to collect results.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">During the user application</emphasis>: To
        transfer information between nodes.</para>
      </listitem>
    </itemizedlist>

    <para>To achieve this, we have implemented File Transfer support in two
    ways:</para>

    <itemizedlist>
      <listitem>
        <para>File Transfer API</para>
      </listitem>

      <listitem>
        <para>Descriptor File Transfer support.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="dbdoclet.id.FileTransfer_html_objectives">
    <title>File Transfer API</title>

    <sect2>
      <title>API Definition</title>

      <programlisting lang="java">package org.objectweb.proactive.api.ProFileTransfer;

static <emphasis role="bold">      RemoteFile</emphasis> <emphasis role="bold">pull</emphasis>(<emphasis
          role="bold">Node</emphasis> srcNode, <emphasis role="bold">File</emphasis> srcFile, <emphasis
          role="bold">File</emphasis> dstFile) throws IOException;
static List&lt;<emphasis role="bold">RemoteFile</emphasis>&gt; <emphasis
          role="bold">pull</emphasis>(<emphasis role="bold">Node</emphasis> srcNode, <emphasis
          role="bold">File[]</emphasis> srcFile, <emphasis role="bold">File[]</emphasis> dstFile) throws IOException;

static       <emphasis role="bold">RemoteFile</emphasis> <emphasis role="bold">push</emphasis>(<emphasis
          role="bold">File</emphasis> srcFile, <emphasis role="bold">Node</emphasis> dstNode, <emphasis
          role="bold">File</emphasis> dstFile) throws IOException;
static List&lt;<emphasis role="bold">RemoteFile</emphasis>&gt; <emphasis
          role="bold">push</emphasis>(<emphasis role="bold">File[]</emphasis> srcFile, <emphasis
          role="bold">Node</emphasis> dstNode, <emphasis role="bold">File[]</emphasis> dstFile) throws IOException;

static       <emphasis role="bold">RemoteFile</emphasis> <emphasis role="bold">transfer</emphasis>(<emphasis
          role="bold">Node</emphasis> srcNode, <emphasis role="bold">File</emphasis> srcFile, <emphasis
          role="bold">Node</emphasis> dstNode, <emphasis role="bold">File</emphasis> dstFile) throws IOException;
static List&lt;<emphasis role="bold">RemoteFile</emphasis>&gt; <emphasis
          role="bold">transfer</emphasis>(<emphasis role="bold">Node</emphasis> srcNode, <emphasis
          role="bold">File[]</emphasis> srcFile, <emphasis role="bold">Node</emphasis> dstNode, <emphasis
          role="bold">File[]</emphasis> dstFile) throws IOException;
static List&lt;<emphasis role="bold">RemoteFile</emphasis>&gt; <emphasis
          role="bold">transfer</emphasis>(<emphasis role="bold">Node</emphasis> srcNode, <emphasis
          role="bold">File[]</emphasis> srcFile, <emphasis role="bold">Node</emphasis> dstNode, <emphasis
          role="bold">File[]</emphasis> dstFile, int bsize, int numFlyingBlocks) throws IOException;</programlisting>

      <para>These methods are static, and handle the transfer of file between
      ProActive <emphasis role="bold">Node</emphasis>s. The pull methods
      retrieve a file located on a remote machine to the local machine. The
      push methods transfer a file available on the local node to the
      specified remote node. And the transfer methods allow transfer between
      third party nodes. </para>

      <para>The file transfers are performed in an asynchronous fashion. Each
      of these methods returns at <emphasis role="bold">RemoteFile</emphasis>
      object which represents the file transfer operation and the remote
      file's node/location. When these methods are invoked a <emphasis
      role="bold">RemoteFile</emphasis> instance is immediately returned,
      before the file transfer operation has been completed. The <emphasis
      role="bold">RemoteFile</emphasis> object provides a way to monitor the
      status of the file transfer:</para>

      <screen>public interface <emphasis role="bold">RemoteFile</emphasis> extends Serializable {

  public boolean <emphasis role="bold">isTransferFinished</emphasis>();

  public void <emphasis role="bold">waitForFinishedTransfer</emphasis>() throws IOException;

  public RemoteFile <emphasis role="bold">pull</emphasis>(File localDst) throws IOException;

  public RemoteFile <emphasis role="bold">push</emphasis>(Node dstNode, File dstRemote) throws IOException;

  public Node <emphasis role="bold">getRemoteNode</emphasis>();

  public File <emphasis role="bold">getRemoteFilePath</emphasis>();

}</screen>

      <para>The <emphasis role="bold">isTransferFinished</emphasis> and
      <emphasis role="bold">waitForFinishedTransfer</emphasis> can be invoked
      to query and wait on the file transfer status. The <emphasis
      role="bold">pull</emphasis> method can be used to fetch the <emphasis
      role="bold">RemoteFile</emphasis> from the remote node, into the local
      <emphasis role="bold">Node</emphasis>, and the <emphasis
      role="bold">push</emphasis> methods can be used to send the <emphasis
      role="bold">RemoteFile</emphasis> to another <emphasis
      role="bold">Node</emphasis>.</para>
    </sect2>

    <sect2>
      <title>How to use the API Example</title>

      <para>In the following example, a <emphasis role="bold">Node</emphasis>
      is deployed using a descriptor file. A <emphasis
      role="bold">File</emphasis> is then pushed from the local <emphasis
      role="bold">Node</emphasis> to a remote <emphasis
      role="bold">Node</emphasis>. Then the file is pulled from the Remote
      <emphasis role="bold">Node</emphasis>, and the computation is blocked
      waiting for the file transfer operation to finish.</para>

      <programlisting lang="java">ProActiveDescriptor pad = ProDeployment.getProactiveDescriptor(XML_LOCATION);

VirtualNode testVNode = pad.getVirtualNode("test");
testVNode.activate();
Node testnode = testVNode.getNode();

<emphasis role="bold">RemoteFile</emphasis> remoteFileA = <emphasis
          role="bold">ProFileTransfer.push</emphasis>(new File("/tmp/test.dat"), testnode, new File("/tmp/test.dat"));
<emphasis role="bold">RemoteFile</emphasis> remoteFileB = <emphasis
          role="bold">remoteFileA.pull</emphasis>(new File("/tmp/test2.dat"));


<emphasis role="bold">remoteFileB.waitForFinishedTransfer</emphasis>(); //blocking method</programlisting>

      <sect3>
        <title>How to obtain a Node from an Active Object reference</title>

        <para>The Node where an Active Object resides can be obtained in the
        following way:</para>

        <screen>Object o  =  ProActiveObject.newActive(...);
...
<emphasis role="bold">Node node = ProActiveObject.getActiveObjectNode(o);</emphasis></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Descriptor File Transfer</title>

    <para>File Transfers can also be specified using ProActive Descriptors.
    The main advantage of this scheme is that it allows deployment and
    retrieval of input and output (files). In this section we will concentrate
    on mainly three topics:</para>

    <itemizedlist>
      <listitem>
        <para>XML Descriptor File Transfer Tags</para>
      </listitem>

      <listitem>
        <para>Deployment File Transfer</para>
      </listitem>

      <listitem>
        <para>Retrieval File Transfer</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>XML Descriptor File Transfer Tags</title>

      <para>The File Transfer related tags, are placed inside the descriptor
      at three different parts (or levels).</para>

      <para>The first one corresponds to the <emphasis
      role="bold">fileTransferDefinitions</emphasis> tag, which contains a
      list of FileTransfer definitions. A FileTransfer definition is a high
      level representation of the File Transfer, containing mainly the file
      names. It is created in such a way, that no low level information such
      as: hosts, protocols, prefix is present (this is the role of the low
      level representation). The following example shows a FileTranfer
      definition named <emphasis>example</emphasis>:</para>

      <para><screen>....
&lt;/deployment&gt;
&lt;<emphasis role="bold">fileTransferDefinitions</emphasis>&gt;
   &lt;<emphasis role="bold">fileTransfer</emphasis> id="<emphasis role="bold">example</emphasis>"&gt;
      &lt;<emphasis role="bold">file</emphasis> src="hello.dat" dest="world.dat"/&gt;
      &lt;<emphasis role="bold">file</emphasis> src="hello.jar" dest="world.jar"/&gt;
      &lt;<emphasis role="bold">file</emphasis> src="hello.class" dest="world.class"/&gt;
      &lt;<emphasis role="bold">dir</emphasis> src="exampledir" dest="exampledir"/&gt;
  &lt;/<emphasis role="bold">fileTransfer</emphasis>&gt;
  &lt;<emphasis role="bold">fileTransfer</emphasis> id="<emphasis role="bold">anotherExample</emphasis>"&gt;
      ...
  &lt;/<emphasis role="bold">fileTransfer</emphasis>&gt;
  ...
&lt;/<emphasis role="bold">fileTransferDefinitions</emphasis>&gt;
&lt;infrastructure&gt;
....         </screen></para>

      <para>The FileTransfer definitions can be referenced through their
      names, from the <emphasis role="bold">VirtualNode</emphasis> tags using
      two attributes:<emphasis role="bold">fileTransferDeploy</emphasis> and
      <emphasis role="bold">fileTransferRetrieve</emphasis>. The first one,
      corresponds to the file transfer that will take place at deployment
      time, and the second one corresponds to the file transfer that the user
      will trigger once the user application is done.</para>

      <para><screen>&lt;virtualNode name="exampleVNode" <emphasis role="bold">fileTransferDeploy</emphasis>="<emphasis
            role="bold"><emphasis><emphasis><emphasis role="bold"><emphasis>example</emphasis></emphasis></emphasis></emphasis></emphasis>" <emphasis
            role="bold">fileTransferRetrieve</emphasis>="<emphasis>example</emphasis>"/&gt;</screen></para>

      <para>All the low level information such as: hosts, username, protocols,
      prefix, etc... is declared inside each process. Both <emphasis
      role="bold">fileTransferDeploy</emphasis> and <emphasis
      role="bold">fileTransferRetrieve</emphasis> are specified separetly
      using a <emphasis role="bold">refid</emphasis> attribute. The <emphasis
      role="bold">refid</emphasis> can be a direct reference to a FileTransfer
      definition, or set using the keyword <emphasis
      role="bold">implicit</emphasis>. If <emphasis
      role="bold">implicit</emphasis> is used, then the reference will be
      inherited from the corresponding VirtualNode. In the following example
      both mechanisms (Deploy and Retrieve) reference indirectly and directly
      the example definition:</para>

      <para><screen>&lt;processDefinition id="xyz"&gt;
  &lt;sshProcess&gt;
  ...  
&lt;!-- Inside the process, the FileTransfer tag becomes an element instead of
an attribute.  This happens because FileTransfer information is process specific.
Note that the destination hostname and username can be omitted,
and implicitly inferred from the process information. --&gt;

    &lt;<emphasis role="bold">fileTransferDeploy</emphasis> refid="<emphasis
            role="bold">implicit</emphasis>"&gt; &lt;!-- referenceID or keyword "implicit" (inherit)--&gt;
      &lt;<emphasis role="bold">copyProtocol</emphasis>&gt;processDefault, rcp, scp, pft&lt;/<emphasis
            role="bold">copyProtocol</emphasis>&gt;
      &lt;<emphasis role="bold">sourceInfo</emphasis> prefix="/home/user"/&gt;
      &lt;<emphasis role="bold">destinationInfo</emphasis> prefix="/tmp" hostname="foo.org" username="smith" /&gt;
    &lt;/<emphasis role="bold">fileTransferDeploy</emphasis>&gt;

    &lt;<emphasis role="bold">fileTransferRetrieve</emphasis> refid="example"&gt;
      &lt;<emphasis role="bold">sourceInfo</emphasis> prefix="/tmp"/&gt;
      &lt;<emphasis role="bold">destinationInfo</emphasis> prefix="/home/user"/&gt;
    &lt;/<emphasis role="bold">fileTransferRetrieve</emphasis>&gt;
  &lt;/sshProcess&gt;
&lt;/processDefinition&gt;
</screen></para>

      <indexterm>
        <primary>CopyProtocol</primary>
      </indexterm>

      <para>In the example above, <emphasis
      role="bold">fileTransferDeploy</emphasis> has an implicit refid. This
      means that the File Transfer definitions used will be inherited from the
      VirtualNode. The first element shown inside this tag corresponds to
      <emphasis role="bold">copyProtocol</emphasis>. The <emphasis
      role="bold">copyProtocol</emphasis> tag specified the sequence of
      protocols that will be executed to achieve the FileTransfer at
      deployment time. Notice the <emphasis
      role="bold">processDefault</emphasis> keyword, which specifies the usage
      of the default copy protocol associated with this process. In the case
      of the example, this corresponds to an <emphasis
      role="bold"><emphasis><emphasis>sshProcess</emphasis></emphasis></emphasis>
      and therefore the Secure Copy Protocol (scp) will be tried first. To
      complement the higher level File Transfer definition, other information
      can be specified as attributes in the <emphasis
      role="bold">sourceInfo</emphasis> and <emphasis
      role="bold">destinationInfo</emphasis> elements. For the case of
      FileTransferDeploy, these tags currently correspond to:
      <emphasis>prefix</emphasis>, <emphasis>hostname</emphasis> and
      <emphasis>username</emphasis>.</para>

      <para>For f<emphasis role="bold">ileTransferRetrieve</emphasis>, no
      copyProtocol needs to be specified. ProActive will use it's internal
      mechanism to transfer the files. This implies that no
      <emphasis>hostname</emphasis> or <emphasis>username</emphasis> are
      required.</para>

      <sect3>
        <title>Currently supported protocols for file transfer
        deployment</title>

        <para><itemizedlist>
            <listitem>
              <para><emphasis role="bold">pft</emphasis><emphasis
              role="bold">p</emphasis> (ProActive File Transfer
              Protocol)</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">scp</emphasis> (ssh
              processDefault)</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">rcp</emphasis> (rsh
              processDefault)</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">unicore</emphasis> (Unicore
              processDefault)</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">nordugrid</emphasis> (Nordugrid
              processDefault)</para>
            </listitem>
          </itemizedlist></para>
      </sect3>

      <sect3>
        <title>Triggering File Transfer Deploy</title>

        <para>The trigger (start) of the File Transfer will take place when
        the deployment of the descriptor file is executed. In the case of
        <emphasis>external protocols</emphasis> (<emphasis role="bold">scp,
        rcp</emphasis>), this will take place before the process deployment.
        In the case of <emphasis>internal protocols</emphasis> (<emphasis
        role="bold">unicore, nordugrid</emphasis>), this will take place with
        the process deployment. In any case, it should be noted that
        intersting things can be achieved, such as transfering the ProActive
        libraries into the deploying machine using an <emphasis
        role="bold">on-the-fly</emphasis> style. This means that it is
        possible to deploy on remote machines without having ProActive
        <emphasis>pre-installed</emphasis>. Even further, when the network
        allows, it is also possible to transfer other required libraries like
        the JRE (Java Runtime Envirorment).</para>

        <para>There is one protocol that behaves differently from the rest,
        the ProActive FileTransfer Protocol (<emphasis
        role="bold">pftp</emphasis>). The <emphasis
        role="bold">pftp</emphasis> uses the ProActive FileTranfer API
        (described earier), to transfer files between nodes. The main
        advantage of using the <emphasis role="bold">pftp</emphasis> is that
        no external copy protocols are required to transfer files at
        deployment time. Therefore, if the grid infrastructure does not
        provide a way to transfer files, a FileTransfer Deploy can still take
        place using the <emphasis role="bold">pftp</emphasis>. On the other
        hand, the main drawback of using <emphasis role="bold">pftp</emphasis>
        is that ProActive must already be install on the remote machines, and
        thus <emphasis role="bold">on-the-fly</emphasis> deployment is not
        possible.</para>
      </sect3>

      <sect3>
        <title>Triggering File Transfer Retrieve</title>

        <para>Since distributed application's termination is difficult to
        detect. The responsability of triggering the deployment corresponds to
        the user. To achieve this, we have provided a specific mehod that will
        trigger the retrieval of all files associated with a
        VirtualNode.</para>

        <para><programlisting lang="java">import org.objectweb.proactive.core.descriptor.data;

public FileWrapper <emphasis role="bold">VirtualNode.fileTransferRetrieve</emphasis>();</programlisting></para>

        <para>This will trigger the retrieval of all the files specified in
        the descriptor, from all the nodes that were deployed using this
        virtual node using the <emphasis role="bold">pftp</emphasis>. The
        following shows an example:</para>

        <programlisting lang="java">import org.objectweb.proactive.core.descriptor.data;

pad = ProActive.getProactiveDescriptor(XML_LOCATION);

VirtualNode <emphasis role="bold">testVNode</emphasis> = pad.getVirtualNode("example");
testVNode.activate();
Node[] examplenode = testVNode.getNodes();

...

FileWrapper fw = testVNode.<emphasis role="bold">fileTransferRetrieve</emphasis>();
...
File f[]=<emphasis role="bold">fw.getFiles()</emphasis> //wait-for-files to arrive
</programlisting>

        <para>As a result of calling this method an array of type File[] will
        be created, representing all the retrieved files.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="dbdoclet.id.FileTransfer_html_design"
         xreflabel="FileTransfer Design">
    <title>Advanced: FileTransfer Design</title>

    <para>This section provides internal details and information on how the
    File Transfer is implemented. Reading the following section to use the
    File Transfer mechanisms provided by ProActive is not necessary.</para>

    <sect2>
      <title>Abstract Definition (High level)</title>

      <para>This definitions can be referenced from a VirtualNode. They
      contain the most basic information of a FileTransfer:</para>

      <itemizedlist>
        <listitem>
          <para>A unique definition identification name.</para>
        </listitem>

        <listitem>
          <para>Files: source and optionally the destination name.</para>
        </listitem>

        <listitem>
          <para>Directories: source and optionally the destination name. Also
          the exclude and include patterns (not yet available feature).</para>
        </listitem>
      </itemizedlist>

      <para>References from the VirtualNode are made using the unique
      definition name.</para>
    </sect2>

    <sect2>
      <title>Concrete Definition (Low level)</title>

      <para>These definitions contain more architecture specific information,
      and are therefore contained within the Process:</para>

      <itemizedlist>
        <listitem>
          <para>A reference to an abstract definition, or the "<emphasis
          role="bold">implicit</emphasis>" key word indicating the reference
          will be inherited from the VirtualNode.</para>
        </listitem>

        <listitem>
          <para>A sequence of Copy Protocols that will be used.</para>
        </listitem>

        <listitem>
          <para>Source and Destination information: prefix, username,
          hostname, file separator, etc...</para>
        </listitem>
      </itemizedlist>

      <para>If some of this information (like username or hostname) can be
      inferred from the process, it is not necessary to declare it in the
      definition. Optionally, the information contained in the protocol can be
      overridden if specified.</para>
    </sect2>

    <sect2>
      <title>How Deployment File Transfer Works</title>

      <figure>
        <title>File Transfer Design</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="development/imgs/fileTransferDesign.png"
                       format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>When a FileTransfer starts, both abstract and concrete information
      are merged using the FileTransfer Workshop. The result of this process
      correspons to a sequence of CopyProtocols, as specified in the Concrete
      Definition.</para>

      <para>Each CopyProtocol will be tried before the deployment takes place,
      until one succeeds. After one succeed are all fail, the process
      deployment will take place.</para>
    </sect2>

    <sect2>
      <title>How File Transfer API Works</title>

      <para>The File Transfer API is built on top of ProActive's active object
      and future file asynchronism model. When pulling or pushing a file from
      a Node, two service Active Objects (AO) are created. One is placed on
      the local machine and the otherone on the remote site. The file is then
      split into blocks, and transfered over the network using remote
      invocations between these two AO.</para>
    </sect2>

    <sect2>
      <title>How Retrieve File Transfer Works</title>

      <para>For a given virtualnode, a File Transfer pull will take place with
      all the nodes deployed from this virtualnode. The detailes of the
      specified file transfer will correspond to the ones present in the
      descriptor file.</para>
    </sect2>
  </sect1>
</chapter>