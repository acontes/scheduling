<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="ProActiveBasis">
  <title>Active Object Definition</title>

  <!--  File: /home/irosenbe/PA_new_doc/docbook-tuto/ProActiveBasis.html  -->

  
  <sect1>
  	<sect2>
  		<title>Overview</title>
  		<para>//TODO</para>
  	</sect2>
    <sect2 id="ProActiveBasis_html_def">
    <title>Active Object Structure</title>

    <para>Active objects are the basic units of activity and distribution used
    for building concurrent applications using ProActive. As opposed to passive(regular)
    objects, an active object is an object that has its own thread and execution queue. 
    The active object thread executes only the methods invoked on
    the active object by other active objects or by passive
    objects of the subsystem of the active object. However, the use of this 
    thread is transparent for the user. ProActive manages the active objects threads
    relieving the programmer from explicitly manipulating Thread
    objects.</para>

    <para>Active objects can be created on any of the hosts involved in the
    computation. Once an active object is created, its activity (the fact that
    it runs with its own thread) and its location (local or remote) are
    perfectly transparent. As a matter of fact, any active object can be
    manipulated just like if it were a passive instance of the same
    class.</para>
    
	 <para>The active object is actually the composition of two objects: a
    <emphasis>body</emphasis> and a standard Java object. The body is not
    visible from the outside of the active object therefore the active
    object looks exactly like a standard object from the user's perspective.</para>

    <para>The body is responsible for receiving calls on the active object,
    storing these calls in the queue of pending calls (also called requests).
    It will execute these calls in an order
    specified by a specific synchronization policy. If no specific
    synchronization policy is provided, calls are managed in a FIFO manner
    (first come, first served). It is important to note
    that no parallelism is provided inside an active object. This is an
    important decision in the design of ProActive which enables the use of
    pre and post conditions and class invariants.</para>

    <para>On the side of the subsystem which sends a call to an active object,
    this active object is represented by a <emphasis>proxy</emphasis>, whose
    main responsibility is to generate future objects for representing future
    values, transform calls into request objects (in terms of meta-object programming, this
    is a reification) and perform deep-copy of passive objects passed as
    parameters.</para>
  	</sect2>
	
	<sect2>
		<title> Active Object Behavior</title>
	  <itemizedlist>
      <listitem>
        <para>An application based on active objects is structured in subsystems.
        A subsystem is composed of only one active object (with its own thread) and several passive 
        objects (possibly zero). This is an effect of to the way active objects communicate 
		using proxies. The thread of one subsystem only executes methods in the objects of
        this subsystem and any call on a another active object passes through a proxy and is
        executed in the subsystem of the remote active object.  
        </para>
      </listitem>

      <listitem>
        <para>The passive objects are not shared between subsystems. Any call on an remote active object
        using passive objects as arguments leads to a deep-copy of the passive objects on the subsystem of
        the remote active object. </para>
      </listitem>
    </itemizedlist>

    <para><figure>
        <title>The Model: Sequential, Multithreaded, Distributed</title>

        <mediaobject>
          <imageobject>
            <imagedata contentwidth="100" fileref="images/proActiveModel.png"
                       format="PNG" width="6in" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>These two main features have a lot of important consequences on the
    topology of the application:</para>

    <itemizedlist>
      <listitem>
        <para>Of all the objects that make up a subsystem (the active object
        and the passive objects), only the active object is known to objects
        outside of the subsystem.</para>
      </listitem>

      <listitem>
        <para>All objects (both active and passive) may have references onto
        active objects.</para>
      </listitem>

      <listitem>
        <para>If an object o1 has a reference onto a passive object o2, then
        o1 and o2 are part of the same subsystem.</para>
      </listitem>
    </itemizedlist>

    <para>This has also consequences on the semantics of message-passing
    between subsystems.</para>

    <itemizedlist>
      <listitem>
        <para>When an object in a subsystem calls a method on an active
        object, the parameters of the call may be references on passive
        objects of the subsystem, which would lead to shared passive objects.
        This is why passive objects passed as parameters of calls on active
        objects are always passed by <emphasis>deep-copy</emphasis>. Active
        objects, on the other hand, are always passed by reference.
        Symmetrically, this also applies to objects returned from methods
        called on active objects.</para>
      </listitem>

      <listitem>
        <para>When a method is called on an active object, it returns
        immediately (as the thread cannot execute methods in the other
        subsystem). A <emphasis>future object</emphasis>, which is a
        placeholder for the result of the methods invocation, is returned.
        From the point of view of the caller subsystem, no difference can be
        made between the future object and the object that would have been
        returned if the same call had been issued onto a passive object. Then,
        the calling thread can continue executing its code just like if the
        call had been effectively performed. The role of the future object is
        to block this thread if it invokes a method on the future object and
        the result has not yet been set (i.e. the thread of the subsystem on
        which the call was received has not yet performed the call and placed
        the result into the future object): this inter-object synchronization
        policy is known as <emphasis>wait-by-necessity</emphasis>.</para>
      </listitem>
    </itemizedlist>

    <para><figure>
        <title>A call onto an active object as opposed to a call onto passive
        one</title>

        <mediaobject>
          <imageobject>
            <imagedata contentwidth="100"
                       fileref="images/activeObjectMethodCall.png"
                       format="PNG" width="6in" />
          </imageobject>
        </mediaobject>
      </figure></para>
      </sect2>
  </sect1>

  
</chapter>