<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="Principles">
  <title>Principles</title>

  <para>GRID computing is now a key aspect, from scientific to business
  applications, from large scale simulations to everyday life enterprise IT.
  After the old days of mainframes and servers with hundreds of persons
  sharing the same machines or the quite current days of the PCs with one
  person for one computer, we are just entering the era of Ubiquitous
  Computing with many computers at hand for every single individual.
  Potentially spanning all the world and involving several thousands or
  several hundred thousands of nodes, the programming of Grid applications
  call for new paradigms.</para>

  <para>Overall, ProActive promotes a few basic and simple principles:</para>

  <itemizedlist>
    <listitem>
      <para>Activites are distributed, remotely accessible objects</para>
    </listitem>

    <listitem>
      <para>Interactions are done through asynchronous method calls</para>
    </listitem>

    <listitem>
      <para>Results of interactions are called futures and are first class
      entities.</para>
    </listitem>

    <listitem>
      <para>Callers can wait for results using a mechanism called
      wait-by-necessity</para>
    </listitem>
  </itemizedlist>

  <para>The ProActive Grid solution relies on systematic asynchronous method
  calls mastering both complexity and efficiency and takes advantage of this
  sound programming model to further propose advanced features such as groups,
  mobility, and components. In the framework of a formal calculus, ASP
  (Asynchronous Sequential Processes), confluence, and determinism have been
  proved for this programming model: <xref endterm="TDO-book.abbrev"
  linkend="TDO-book" /> and <xref endterm="CHSPOPL04.abbrev"
  linkend="CHSPOPL04" />.</para>

  <para>Asynchronous method calls with returns lead to an emerging abstraction
  - futures - which are<indexterm>
      <primary>Future</primary>
    </indexterm> the expected result of a given asynchronous method call.
  Futures turn out to be a very effective abstraction for large distributed
  systems, preserving both low coupling and high structuring.</para>

  <para>Asynchronous method calls and first-class futures are provided in the
  unifying framework of an Active Object.</para>

  <indexterm>
    <primary>Active Object</primary>
  </indexterm>

  <sect1>
    <title>Seamless Sequentiality, Multithreading and Distribution</title>

    <para>Most of the time, activities and distribution are not known at the
    beginning and change over time. <emphasis>[COMMENT:Transitions from what
    to what ?]</emphasis>Seamless implies reusability and smooth and
    incremental transitions.[<emphasis>COMMENT</emphasis>]</para>

    <para><figure>
        <title>Different computing deployment paradigms</title>

        <mediaobject>
          <imageobject>
            <imagedata contentwidth="100"
                       fileref="images/proActiveModelColor.png" format="PNG"
                       width="6in" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>A huge gap still exists between multithreaded and distributed Java
    applications which impedes code reuse in order to build distributed
    applications from multithreaded applications. Both JavaRMI and JavaIDL, as
    examples of distributed object libraries in Java, put a heavy burden on
    the programmer because they require deep modifications of existing code in
    order to turn local objects into remotely accessible ones. In these
    systems, remote objects need to be accessed through some specific
    interfaces. As a consequence, these distributed objects libraries do not
    allow polymorphism between local and remote objects. This feature is our
    first requirement for a Grid Computing framework. It is strongly required
    in order to let the programmer concentrate first on modeling and
    algorithmic issues rather than lower-level tasks such as object
    distribution, mapping and load balancing.</para>
  </sect1>

  <sect1 id="Principles_html_active">
    <title>Active Objects: Unifying Threads and Remote Objects</title>

    <para>Active Objects are the core of the ProActive computing concept. An
    Active Object is both a remote object (which allows to deploy it on a
    distant host) and a thread (which gives it its own activity, its own
    independant behaviour and in concurrency with other Active Objects
    deployed). Given a standard object, turning it into an Active Objects
    provides:</para>

    <itemizedlist>
      <listitem>
        <para>location transparency</para>
      </listitem>

      <listitem>
        <para>activity transparency</para>
      </listitem>

      <listitem>
        <para>synchronization</para>
      </listitem>
    </itemizedlist>

    <para>Communications to an Active Object are by default asynchronous. So,
    an Active Object is composed of: </para>

    <itemizedlist>
      <listitem>
        <para>a main object</para>
      </listitem>

      <listitem>
        <para>a single thread</para>
      </listitem>

      <listitem>
        <para>a queue of pending requests</para>
      </listitem>
    </itemizedlist>

    <para>As such, a reference to a remote object is equivalent to a reference
    to a remote activity. An activity is an object ; but being in a
    non-uniform model, not all objects are Active Objects, the majority
    remaining standard Java objects. As there cannot be any sharing, an Active
    Object is also a unit of computational mobility (see <xref
    linkend="Migration" />).</para>

    <note>
      <para>The Active Object concept only requires modification of the
      instantiation code !</para>
    </note>

    <para>On activation, an object becomes a remotely accessible entity with
    its own thread of control: an Active Object. Here are given as example
    three ways to transform a standard object into an Active Object:</para>

    <example>
      <title>Class-based Active Object</title>

      <programlisting lang="java">Object[] params = new Object[] { new Integer (26), "astring" };
A a = (A) ProActive.newActive("example.A", params, node); </programlisting>
    </example>

    <example>
      <title>Instantiation-based Active Object</title>

      <programlisting lang="java">public class AA extends A implements Active {}
Object[] params = new Object[] { new Integer (26), "astring" };
A a = (A) ProActive.newActive("example.AA", params, node); </programlisting>
    </example>

    <para>ProActive permits transforming regular objects into Active Objects
    and for objects for which you do not have the source code; this is a
    necessary feature in the context of code mobility.</para>

    <example>
      <title>Object-based Active Object</title>

      <programlisting lang="java">A a = new A (26, "astring");
a = (A) ProActive.turnActive(a, node) ; </programlisting>
    </example>

    <note>
      <para>Nodes allow to control the mapping to the hosts. See <xref
      linkend="Active_Object_On_Node" /> for an example use of a Node, and
      <xref linkend="Descriptor_Principles" /> for a definition.</para>
    </note>
  </sect1>

  <sect1 id="Principles_html_model">
    <title>Model of Computation</title>

    <para>Here is a summary of the computation model being used by
    ProActive:</para>

    <itemizedlist>
      <listitem>
        <para>Heterogeneous model using passive and Active Objects</para>
      </listitem>

      <listitem>
        <para>Systematic asynchronous communications for Active Objects</para>
      </listitem>

      <listitem>
        <para>No shared passive object with only call-by-value between Active
        Objects</para>
      </listitem>

      <listitem>
        <para>Automatic continuations using a transparent delegation
        mechanism</para>
      </listitem>

      <listitem>
        <para>Wait-by-necessity using automatic and transparent futures</para>
      </listitem>

      <listitem>
        <para>Centralized and explicit control using libraries of
        abstractions</para>
      </listitem>
    </itemizedlist>

    <para>To compare to Java RMI, a Java remote object is not by essence an
    activity. The fact that several threads can execute several remote method
    calls simultaneously within a remote object does reveal that facet. When
    writing ro.foo(p), what ro identifies is not a remote activity, but just a
    remote object. This has several consequences, along with the presence of
    sharing between remote objects that prevents them from being a unit of
    computational migration.</para>
  </sect1>

  <sect1 id="Principles_html_reuse">
    <title>Reusability and Seamless Interface: Why and How Do We Achieve
    It?</title>

    <para><emphasis>[COMMENT:Completly ambigous, ask]</emphasis>Two key
    features:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Wait-by-necessity: inter-objects
        synchronization</emphasis>. Systematic, implicit and transparent
        futures. Ease the programming of synchronization and reuse of existing
        methods</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Polymorphism between standard and Active
        Objects</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>Type compatibility for classes and not just for
            interfaces</para>
          </listitem>

          <listitem>
            <para>Needed and done for the future objects as well</para>
          </listitem>

          <listitem>
            <para>Dynamic mechanism (dynamically achieved if
            needed)<emphasis>[COMMENT]</emphasis></para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>

    <para><figure>
        <title>Polymorphism</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/polymorphism.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure></para>
  </sect1>

  <sect1 id="TinyHelloWorld">
    <title>Hello world ! (tiny example)</title>

    <para>The example implements the smallest possible program in ProActive.
    It is the easiest program you could write using the Active Object concept
    and it shows quickly how code can be written with minimal knowledge of the
    API.</para>

    <para>In the example, a client object displays a String received from
    elsewhere (the original VM) to illustrates the creation of an Active
    Object. Only one class is needed, with the main method inside the class,
    which when deployed will be an Active Object.</para>

    <para>You can get a more complete "Hello World" example, with deployment
    on a remote host, further on in the manual (<xref
    linkend="HelloWorld" />). </para>

    <sect2>
      <title>The TinyHello Class</title>

      <para>This class can be used as an Active Object, serving requests. Its
      creation involves the following steps: <itemizedlist>
          <listitem>
            <para>Provide an implementation for the required server-side
            functionalities</para>
          </listitem>

          <listitem>
            <para>Provide an empty, no-argument constructor</para>
          </listitem>

          <listitem>
            <para>Write a main method in order to instantiate one server
            object.</para>
          </listitem>
        </itemizedlist></para>

      <example>
        <title>A possible implementation for the TinyHello class</title>

        <programlisting lang="java"><textobject>
            <textdata fileref="examples/hello/TinyHello.java" />
          </textobject></programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Implement the Required Functionality</title>

      <para>Implementing any remotely-accessible functionality is simply done
      through normal Java methods in a normal Java class, in exactly the same
      manner it would have been done in a non-distributed version of the same
      class. Here, the only method is sayHello.</para>
    </sect2>

    <sect2>
      <title>Creating the Hello Active Object</title>

      <para>Now that we know how to write the class that implements the
      required server-side functionalities, let us see how to create the
      server object. We want this Active Object to be created on the current
      node, which is why we use newActive in the main methodwith only two
      parameters.</para>

      <para>The code snippet which instantiates the TinyHello in the same VM
      is the following (in the main method):</para>

      <programlisting lang="java">        TinyHello tiny = (TinyHello) ProActive.newActive(
                TinyHello.class.getName(), // the class to deploy
                null // the arguments to pass to the constructor, here none
            ); // which jvm should be used to hold the Active Object</programlisting>
    </sect2>

    <sect2>
      <title>Invoking a Method On a Remote Object And Printing Out the
      Message</title>

      <para>Invoking a method on a remote object is exactly like invoking a
      method on a local object of the same type. The user does not have to
      deal with catching exceptions related to the distant deployment.</para>

      <para>As already stated, the only modification brought to the code by
      ProActive is located at the place where Active Objects are created. All
      the rest of the code remains the same, which fosters software reuse. So
      the way to call the sayHello method in this example is the following (in
      the main method):</para>

      <programlisting lang="java">        StringMutableWrapper received = tiny.sayHello(); // possibly remote call
        logger.info("On " + getHostName() + ", a message was received: " + received); // potential wait-by-necessity</programlisting>
    </sect2>

    <sect2>
      <title>Launching</title>

      <para>To launch the example, you may type:<screen>linux&gt; java -cp $CLASSPATH -Djava.security.policy=scripts/proactive.java.policy 
            -Dlog4j.configuration=file:scripts/proactive-log4j 
            org.objectweb.proactive.examples.hello.TinyHello</screen> <screen>windows&gt; java -cp $CLASSPATH -Djava.security.policy=scripts\proactive.java.policy 
              -Dlog4j.configuration=file:scripts\proactive-log4j 
               org.objectweb.proactive.examples.hello.TinyHello</screen></para>

      <para>There are also scripts in the scripts directory:<screen>linux&gt; cd scripts/unix/ 
linux&gt; tinyHello.sh</screen> <screen>windows&gt; cd scripts/windows 
windows&gt; tinyHello.bat</screen></para>

      <sect3>
        <title>The output</title>

        <screen>[apple unix]tinyhello.sh
--- Hello World tiny example ---------------------------------
&gt; This ClassFileServer is reading resources from classpath
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
Created a new registry on port 1099
//apple.inria.fr/Node628280013 successfully bound in registry at //apple.inria.fr/Node628280013
Generating class: pa.stub.org.objectweb.proactive.examples.hello.Stub_TinyHello
Generating class: pa.stub.org.objectweb.proactive.core.util.wrapper.Stub_StringMutableWrapper
On apple/138.96.218.62, a message was received: Hello World!
  from apple/138.96.218.62
  at 03/11/2005 14:25:32
</screen>
      </sect3>
    </sect2>
  </sect1>
</chapter>