<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="capabilities-intro"><info><title xml:id="Introduction_Proactive_Features">ProActive Example
   Applications</title></info>
  

  <section xml:id="C3D_example"><info><title>C3D: A distributed 3D renderer</title></info>
    
	
    <para>Distribution is often used for CPU-intensive applications, where
    parallelism is a key for performance. The parallelization of programs can be facilitated with
    ProActive, thanks to asynchronous method calls (see <xref linkend="FutureObjectCreation"/>), as well as group communications (see
    <xref linkend="TypedGroupCommunication"/>).</para>
    
 
    <para>To illustrate how parallelization can be used for computationally
    intensive tasks we have built the C3D application.
    <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://proactive.inria.fr/c3d.htm">C3D</link> is
    a Java benchmark application that measures the performance of a 3D
    raytracer renderer distributed over several Java virtual machines using
    Java RMI. It showcases some of the benefits of ProActive, notably the ease
    of distributed programming, and the speedup through distributed parallel
    calculation. This benchmark gives indication of 
     the performance of the serialization process and Java RMI 
     itself. The benchmark is an automated version of C3D, which is both 
     a collaborative application and a distributed raytracer: users can 
     interact through messaging and voting facilities in order to choose 
     a scene that is renderer using a set of distributed rendering engines 
     working in parallel. Near-linear speedup is achieved with up to half 
     a dozen rendering engines running in parallel that communicate using Java RMI
     and controlled by a central dispatcher.</para>
   
    <figure><info><title>The active objects in the c3d application</title></info>
      

      <mediaobject>
        <imageobject>
          <imagedata scalefit="1" width="100%" contentdepth="100%"    fileref="images/c3d.png" format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>
	<section><info><title>How to use C3D</title></info>
		
	<para>
	The C3D application uses three scripts that can be found under <literal>ProActive/scripts/unix</literal>
	or  <literal>ProActive\scripts\windows</literal>:
	</para>
	<itemizedlist>
		<listitem>
			<para><literal>c3d_one_user.sh</literal> or <literal>c3d_one_user.bat
			 </literal> launches  the C3D Dispatcher with four rendering engines and one user.</para>
		</listitem>

 		<listitem><para>
			<literal>c3d_no_user.sh</literal> or <literal>c3d_no_user.bat</literal> 
			launches the C3D Dispatcher with four rendering engines and no user
			</para>
		</listitem>
		<listitem>
			<para>
			<literal>c3d_add_user.sh</literal> or <literal>
			c3d_add_user.bat</literal> adds another users
			</para>
		</listitem>
	</itemizedlist>
	
	<para>To use the application first start the dispatcher using either
	<literal>c3d_one_user.sh/bat</literal> or <literal>c3d_no_user.sh/bat</literal>
	and then add users with <literal>c3d_add_user.sh/bat</literal> </para>
	<para>
      <informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/screenshots/c3d_dispatcher_app.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </informalfigure>
		</para>
		<para>
       <informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/screenshots/c3d_specify_host.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </informalfigure>
      </para>
      <para>
		<informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/screenshots/c3d_user_alice.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </informalfigure>
		</para>
 	</section>

  </section>

  <section><info><title>Readers/Writers Application</title></info>
    

    <para>ProActive provides an advanced synchronization mechanism that allows
    an easy and safe implementation of complex synchronization
    policies.</para>

      <para>
      The readers/writers application showcases the synchronization 
      capabilities of ProActive. In order
      to allow concurrency while ensuring the consistency of the readings,
      accesses to the data have to be synchronized upon a specified policy.
      </para>

      <para>The <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://proactive.inria.fr/reader_writers.htm">implementation
      with ProActive</link> uses 3 active objects: Reader, Writer, and the
      controller class (ReaderWriter).</para>
	
      <section><info><title>How to use the Readers/Writers</title></info>
        

        <para>To start the application use <literal>Proactive/scripts/unix/readers.sh</literal>
        or <literal>Proactive\scripts\windows\readers.bat</literal> depending on your operating
        system.
        </para>

        <para>ProActive starts a node (i.e. a JVM) on the current machine, and
        creates 3 Writers, 3 Readers, a ReaderWrite (the controller of the
        application), and a ReaderDisplay, all of which are active objects.</para>

      <para>The examples has three synchronization modes "Priority to Writers", 
		"Priority to Readers", and "Even Policy". The application is able
		to assign different priority to readers or writers without blocking on reading or writing.     
	</para>


        <para><figure><info><title>A GUI is started that illustrates the activities of the
            Reader and Writer objects.</title></info>
            

            <mediaobject>
              <imageobject>
                <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/screenshots/readers_app.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </figure></para>
    
        
     </section>
	</section>
	<section><info><title>The dining philosophers</title></info>
      

      <para>The 'dining philosophers' problem is a classic exercise in
      concurrent programming with the goal of avoiding deadlocks. In the 
      problem there are five philosophers sitting around a dinner table 
      and sharing five forks. The philosophers alternate between eating and 
      thinking. When eating, a philosopher must use the two forks adjacent to him.
      As there are not enough forks for all the philosophers to eat at the 
      same time, the possibility of deadlock arises.</para>

      <para>We have provided <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://proactive.inria.fr/dining_philosophers.htm">an
      illustration of the solution</link> using ProActive, where all the
      philosophers are active objects, as well as the table (controller) and
      the dinner frame (user interface).</para>

      <section><info><title>How to use the philosophers application</title></info>
        

      <para>To start the application use <literal>Proactive/scripts/unix/philosophers.sh</literal>
        or <literal>Proactive\scripts\windows\philosophers.bat</literal> depending on your operating
        system.
        </para>

        <para>ProActive creates a new node and instantiates the active objects
        of the application: DinnerLayout, Table, and Philosopher</para>

        <para>
        	<figure><info><title>The Dining Philosophers Example</title></info>
            
            <mediaobject>
              <imageobject>
                <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/screenshots/philosophers_app.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </figure>
         </para>
    
        <para>The pictures represent the state of the philosophers. They can
        be:</para>

        <itemizedlist>
          <listitem>
            <para><inlinemediaobject>
                <imageobject>
                  <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/think.png" format="PNG"/>
                </imageobject>
              </inlinemediaobject> <emphasis role="bold">philosophizing</emphasis></para>
          </listitem>

          <listitem>
            <para><inlinemediaobject>
                <imageobject>
                  <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/wait.png" format="PNG"/>
                </imageobject>
              </inlinemediaobject> <emphasis role="bold">hungry, wants the
            fork!</emphasis></para>
          </listitem>

          <listitem>
            <para><inlinemediaobject>
                <imageobject>
                  <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/eat.png" format="PNG"/>
                </imageobject>
              </inlinemediaobject> <emphasis role="bold">eating</emphasis></para>
          </listitem>
        </itemizedlist>

        <para>The forks can have two states:</para>

        <itemizedlist>
          <listitem>
            <para><inlinemediaobject>
                <imageobject>
                  <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/fork1.png" format="PNG"/>
                </imageobject>
              </inlinemediaobject> <emphasis role="bold">taken</emphasis></para>
          </listitem>

          <listitem>
            <para><inlinemediaobject>
                <imageobject>
                  <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/fork0.png" format="PNG"/>
                </imageobject>
              </inlinemediaobject> <emphasis role="bold">free</emphasis></para>
          </listitem>
        </itemizedlist>
      <para>You can either run the application in autopilot mode running it by
       itself without encountering a
        deadlock or in manual mode where you click on the philosophers' heads to switch their modes.
        You can starve one of the philosophers. (i.e. the
        others alternate eating and thinking while one never eats!)</para>
      </section>

    
  </section>

  <section><info><title>Migration of active objects</title></info>
    

    <indexterm>
      <primary>Migration</primary>

      <secondary>example</secondary>
    </indexterm>

    <para>ProActive allows the transparent migration of active objects between
    virtual machines. The migration happens while the application containing the
    active objects is running and without interruptions in the application.</para>

   
    <para>The penguin migration example shows how a set of <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www-sop.inria.fr/oasis/ProActive/apps/penguin.html">mobile
    agents</link>can move around  from machine to machine   while 
    still communicating with their base and
    with each other. It also features the ability to move a swing window
    between screens while moving an agent from one JVM to the other.</para>

    <section><info><title>How to use the penguin application</title></info>
      
      
      <para>Use the <literal>ProActive/scripts/unix/migration/penguin.sh</literal>
       script to start the penguin controller. The controller allows you to add
       a new agent (penguin), and control its itinerary. </para>
    

	<informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/screenshots/penguin_controller.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </informalfigure>
        
  
      <para><informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/screenshots/penguin.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </informalfigure></para>

  
          <para>The active object is moving between the machines (specified
          in the deployment descriptor) ,
          and that the penguin window disappears and reappears on the screen
          associated with the new JVM.</para>
  </section>
    <section><info><title>How to use the Penguin Controller</title></info>
      

      <para>After selecting them, use the buttons to:</para>

      <itemizedlist>
         <listitem>
          <para>Add agents - Start Agent</para>
        </listitem>
        <listitem>
          <para>Communicate with them ('chained calls')</para>
        </listitem>

        <listitem>
          <para>Send the agent on the itinerary - Start, Suspend, Resume</para>
        </listitem>

        <listitem>
	          <para>Trigger a communication between them ('call another
          agent')</para>
        </listitem>
      </itemizedlist>
      
     
    </section>
  </section>

	<section><info><title>Chat example</title></info>
	
	
	<para>
		ProActive has support for groups and migration. To show this we
		have programmed a simple chat application using the groups framework.
		The clients  in the application can communicate to each other in a decentralized
		manner and 	can migrate from computer to computer.</para>
		
		<section><info><title>How to run the Chat application</title></info>
			
		<para>
			To start a chat client run <literal>chat.sh</literal>
			or <literal>chat.bat</literal> from the <literal>ProActive/scripts/unix|windows/groups</literal>folder. 
			The syntax is <literal> chat.sh|bat user_name host_to_connect_to user_to_connect_to </literal>.
		</para>
		<para>
			When you start the first client the last argument can have any value. However if you want
			to connect to another chat you have to supply a valid user name and host. The communication
			is not dependent on any particular user. The first user that created the chat can leave and
			the other users can still communicate. 
		</para>
		
		<para>Start the first user by running <literal> chat.sh|bat toto localhost no_user </literal>.
		The following window appears.</para>
		<para>	
		
		<informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/screenshots/toto_chat.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </informalfigure>
		</para>
		
		<para> To connect the user tutu run <literal> chat.sh|bat tutu localhost toto </literal>.</para>
		<para>
		
		<informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/screenshots/tutu_chat.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </informalfigure>
		</para>
		
		<para>You can further connect other users in the same manner. Run <literal> chat.sh|bat tata localhost tutu </literal>.
		You can connect to any user in the chat and you will have access to all the users. </para>
		
		
	
		</section>
		
		<section><info><title>Chat migration</title></info>
			
			<para>
			The chat application can be migrated to another computer.
			All we have to do to fully migrate one chat is start a node on the 
			remote computer using 
			<literal>startNode.sh</literal> or <literal>startNode.bat</literal> from 
			the scripts folder. We have to use a parameter in the form of
			<literal>rmi://hostname/node_name</literal> to start the node.
			After starting the node we can migrate the chat application
			by putting the URL <literal>//hostname/node_name</literal> in the
			migrate to textbox and clicking on the Migrate button. 
			The application will be recreated on the remote computer with its state 
			intact and ready to communicate to the other users.
			</para>
		</section>
	</section>

  
  <!-- add from the other chapters -->
  
  <!-- //TODO  this example doesn't work in the 3.9 release 
  
      <sect1>
        <title>PI (3.14)</title>

		    <para>
		    	The PI application calculates the number
		    	 PI using the Bailey-Borwein-Plouffe (BPP) algorithm. The BPP
		    	  algorithm allows the computation of the n-th PI digit without 
		    	  knowing the previous n-1  digits. This property makes possible   
		    	  the easy  distribution of the computation on several machines at 
		    	  the same time.  
		    </para>
		    <sect2>
		    	<title>Running PI(3.14)</title>
			<para>
				To start the PI application use the scripts <literal> xxxx </literal>
				in <literal>pathxxx</literal> with the parameters XXXXX.
			</para>
			</sect2>
  </sect1>  
  
   -->
  <!-- 
  <sect1 id="OOSPMDJacobiexample">
    <title>OO SPMD on a Jacobi example</title>

    <sect2>
      <title>How to run the Jacobi code</title>



        <para>To run the Jacobi example, you have to
        run:</para>
        <screen>ProActive/scripts/unix/group/jacobi.sh</screen>
or
        <screen>ProActive\scripts\unix\group\jacobi.bat</screen>

        <para>The computation stops after a minimal difference is reached
        between two iterations (constant MINDIFF in class Jacobi.java), or
        after a fixed number of iteration (constant ITERATIONS in class
        Jacobi.java).</para>

        <para>The provided script creates 4 JVMs on
        the current machine using a XML descriptor. The Jacobi class creates an SPMD group of 9
        Active Objects; 2 or 3 AOs per JVM.</para>
	</sect2>
  </sect1>
 -->
  <!-- Pi MPI -> Pi ProActive -->

  <section><info><title>Integral Pi</title></info>
    

      <para>The MPI PI program approximates <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://en.wikipedia.org/wiki/Pi">pi</link> by computing :</para>

      <para>pi = <emphasis role="bold">integral</emphasis> from <emphasis role="bold">0</emphasis> to <emphasis role="bold">1</emphasis> of
      <emphasis role="bold"><emphasis role="bold">4</emphasis>/( 1+x*x )
      dx</emphasis></para>

      <para>Which is approximated by :</para>

      <para><emphasis role="bold">sum</emphasis> from <emphasis role="bold">k=1</emphasis> to <emphasis role="bold">N</emphasis> of
      <emphasis role="bold">4 / ( ( 1 +( k-1/2 ) **2 )</emphasis></para>

      <para>The only input data required is N, the number of
      iterations.</para>


        <para>The communication pattern is  done in 2 steps by
        first having the process 0 broadcast N and wait for the result from each
        other process. After the results are recieved the process sums the values.</para>


    <section><info><title>Introduction</title></info>
      

      <para>In this chapter we are going to see a simple example of an MPI
      written program ported to ProActive.</para>

      <para>First let's introduce what we are going to compute.</para>

      <para>This simple program approximates <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://en.wikipedia.org/wiki/Pi">pi</link> by computing :</para>

      <para>pi = <emphasis role="bold">integral</emphasis> from <emphasis role="bold">0</emphasis> to <emphasis role="bold">1</emphasis> of
      <emphasis role="bold"><emphasis role="bold">4</emphasis>/( 1+x*x )
      dx</emphasis></para>

      <para>Which is approximated by :</para>

      <para><emphasis role="bold">sum</emphasis> from <emphasis role="bold">k=1</emphasis> to <emphasis role="bold">N</emphasis> of
      <emphasis role="bold">4 / ( ( 1 +( k-1/2 ) **2 )</emphasis></para>

      <para>The only input data required is N, the number of
      iterations.</para>

      <para>Involved files :</para>

      <itemizedlist>
        <listitem>
          <para>ProActive/doc-src/mpi_files/int_pi2.c : the original MPI
          implementation</para>
        </listitem>

        <listitem>
          <para>ProActive/src/Examples/org/objectweb/proactive/examples/integralpi/Launcher.java
          : the main class</para>
        </listitem>

        <listitem>
          <para>ProActive/src/Examples/org/objectweb/proactive/examples/integralpi/Worker.java
          : the class implementing the SPMD code</para>
        </listitem>
      </itemizedlist>
    </section>

    <section><info><title>Initialization</title></info>
      

      <section><info><title>MPI Initialization primitives</title></info>
        

        <para>Some basic primitives are used, notice that MPI provides a rank
        to each process and the group size ( the number of involved processes
        ).</para>

        <programlisting>  // All instances call startup routine to get their instance number (mynum) 
  MPI_Init(&amp;argc, &amp;argv);
  MPI_Comm_rank(MPI_COMM_WORLD, &amp;mynum);
  MPI_Comm_size(MPI_COMM_WORLD, &amp;nprocs);

  // Get a value for N
  solicit (&amp;N, &amp;nprocs, mynum);</programlisting>
      </section>

      <section><info><title>ProActive Initialization primitives</title></info>
        

        <para>First we need to create the group of workers (MPI processes
        represented by active objects). Notice that the creation of active
        objects is done in Launcher.java.</para>

        <para>The group of active objects is created using specified
        parameters and the nodes specified in the deployment
        descriptor.</para>

        <programlisting xml:lang="java">  // Group creation           
  Worker workers = (Worker) PASPMD.newSPMDGroup(
         Worker.class.getName(), params, provideNodes(args[0]));

  // Once the group is created and the value for N is entered we can start the workers job
  // Workers starts their job and return a group of Futures
  DoubleWrapper results = workers.start( numOfIterations );</programlisting>

        <para>As with MPI, the ProActive's SPMD layer provides some initialization
        primitives. In Worker.java you can identify this initialization. Note
        that one-to-one communications will be done thanks to an array view on
        the created group.</para>

        <programlisting xml:lang="java">  // Worker initialization
  rank = PASPMD.getMyRank();
  groupSize = PASPMD.getMySPMDGroupSize();

  // Get all workers references
  workersArray = (Worker[]) ProActiveGroup.getGroup(PASPMD.getSPMDGroup()).toArray(new Worker[0]);</programlisting>
      </section>
    </section>

    <section><info><title>Communication primitives</title></info>
      

      <section><info><title>Communication pattern</title></info>
        

        <para>The communication pattern is very simple, it's done in 2 steps.
        First the process 0 Broadcasts N then waits for the result from each
        other process and sums the received values.</para>
      </section>

      <section><info><title>MPI Approach</title></info>
        

        <para>The MPI implementation involves 3 communication primitives
        :</para>

        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">MPI_Send</emphasis> ( Sends data to
            one process )</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">MPI_Recv</emphasis> ( Receives data
            from a sending process )</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">MPI_Bcast</emphasis> ( Broadcast a
            data to all processes )</para>
          </listitem>
        </itemizedlist>

        <para>Please note that MPI_Bcast, MPI_Send and MPI_Recv primitives are
        blocking.</para>

        <programlisting>  // Get a value of N from stdin for the next run and Broadcast it
  <emphasis role="bold">MPI_Bcast</emphasis>(pN, 1, MPI_INT, source, MPI_COMM_WORLD);

  // LOCAL COMPUTATION LOOP
  // ... 

  if ( mynum == 0 ) { // Check if i'm the leader process
     for (i=1; i&lt;nprocs; i++) {
        source = i;
        info = <emphasis role="bold">MPI_Recv</emphasis>(&amp;x, 1, MPI_FLOAT, source, type, MPI_COMM_WORLD, &amp;status); // waits the value from source process
        sum=sum+x; // sum up the receive value
     }
  } else {
     info = <emphasis role="bold">MPI_Send</emphasis>(&amp;sum, 1, MPI_FLOAT, dest, type, MPI_COMM_WORLD); // if i'm not the process 0 i send my sum      
  }  </programlisting>
      </section>

      <section><info><title>ProActive Approach</title></info>
        

        <para>The ProActive implementation is quite similar to MPI one. The
        fact is that all communications in ProActive are asynchronous (
        non-blocking ) by default, therefore we need to specify explicitly to
        block until a specific request.</para>

        <programlisting xml:lang="java">  // The leader collects partial results.
  // Others just send their computed data to the rank 0.
  
  if ( rank==0 ) { // Check if i'm the leader worker 
     for ( i=1; i&lt;groupSize; i++ ) {
         <emphasis role="bold">body.serve(body.getRequestQueue().blockingRemoveOldest("updateX"))</emphasis>; // block until an updateX call
         sum += x;
     }            
  } else {
     <emphasis role="bold">workersArray[0].updateX(sum)</emphasis>;
  }</programlisting>

        <para>The leader blocks his request queue until another worker will do
        a distant call on the leader's <emphasis role="bold">updateX</emphasis> method which is :</para>

        <programlisting>  public void updateX(double value){
     this.x = value;
  } </programlisting>
      </section>
    </section>

    <section><info><title>Running the PI example</title></info>
      

        <para>In ProActive/scripts/unix or windows run integralpi.sh or .bat,
        you can specify the number of workers from the command line. Feel free
        to edit scripts to specify another deployment descriptor.</para>

        <screen>bash-3.00$ ./integralpi.sh

--- IntegralPi --------------------------------------------------
The number of workers is 4
 --&gt; This ClassFileServer is reading resources from classpath 2011
Created a new registry on port 1099
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
************* Reading deployment descriptor: file:./../../descriptors/Matrix.xml ********************
created VirtualNode name=matrixNode
**** Starting jvm on amda.inria.fr
**** Starting jvm on amda.inria.fr
**** Starting jvm on amda.inria.fr
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
 --&gt; This ClassFileServer is reading resources from classpath 2012
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
 --&gt; This ClassFileServer is reading resources from classpath 2013
 --&gt; This ClassFileServer is reading resources from classpath 2014
**** Starting jvm on amda.inria.fr
Detected an existing RMI Registry on port 1099
Detected an existing RMI Registry on port 1099
Detected an existing RMI Registry on port 1099
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
 --&gt; This ClassFileServer is reading resources from classpath 2015
//amda.inria.fr/matrixNode2048238867 successfully bound in registry at //amda.inria.fr/matrixNode2048238867
**** Mapping VirtualNode matrixNode with Node: //amda.inria.fr/matrixNode2048238867 done
//amda.inria.fr/matrixNode690267632 successfully bound in registry at //amda.inria.fr/matrixNode690267632
**** Mapping VirtualNode matrixNode with Node: //amda.inria.fr/matrixNode690267632 done
//amda.inria.fr/matrixNode1157915128 successfully bound in registry at //amda.inria.fr/matrixNode1157915128
**** Mapping VirtualNode matrixNode with Node: //amda.inria.fr/matrixNode1157915128 done
Detected an existing RMI Registry on port 1099
//amda.inria.fr/matrixNode-814241328 successfully bound in registry at //amda.inria.fr/matrixNode-814241328
**** Mapping VirtualNode matrixNode with Node: //amda.inria.fr/matrixNode-814241328 done
4 nodes found
Generating class : pa.stub.org.objectweb.proactive.examples.integralpi.Stub_Worker

Enter the number of iterations (0 to exit) : 100000
Generating class : pa.stub.org.objectweb.proactive.examples.integralpi.Stub_Worker
Generating class : pa.stub.org.objectweb.proactive.examples.integralpi.Stub_Worker
Generating class : pa.stub.org.objectweb.proactive.examples.integralpi.Stub_Worker
Generating class : pa.stub.org.objectweb.proactive.examples.integralpi.Stub_Worker

         Worker 2 Calculated x = 0.7853956634245252 in 43 ms


         Worker 3 Calculated x = 0.7853906633745299 in 30 ms


         Worker 1 Calculated x = 0.7854006634245316 in 99 ms


         Worker 0 Calculated x = 3.141592653598117 in 12 ms


Calculated PI is 3.141592653598117 error is 8.324008149429574E-12

Enter the number of iterations (0 to exit) :  </screen>
    </section>
  </section>
  
   
  
	<!-- NBODY -->
	
	<section xml:id="nbody"><info><title>The nbody example</title></info>
    

            <para>
                n-body is a classic problem consisting of calculating
                the position of bodies in space. The position depends only on
                the gravitational forces that apply to them. 
                In short, one considers several bodies (sometimes called
                particles) in space, where the only force is due to
                gravity. When only two bodies are at hand, this is
                expressed as
            </para>
            <para>
                <informaltable colsep="0" frame="none">
                    <tgroup cols="2">
                        <tbody>
                            <row>
                                <entry>
                                    <para>
                                        <informalfigure>
                                            <mediaobject>
                                                <imageobject>
                                                    <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/nbody/interactions.png" format="PNG"/>
                                                </imageobject>
                                            </mediaobject>
                                        </informalfigure>
                                    </para>
                                </entry>
                                <entry>
                                    <para>
                                        <informalfigure>
                                            <mediaobject>
                                                <imageobject>
                                                    <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/nbody/forces_simple.png" format="PNG"/>
                                                </imageobject>
                                            </mediaobject>
                                        </informalfigure>
                                        F
                                        <subscript>p-&gt;b</subscript>
                                        is the force that p applies on
                                        b, G is the gravitational
                                        constant, m
                                        <subscript>p</subscript>
                                        m
                                        <subscript>b</subscript>
                                        describe the mass of the bodies,
                                        r is the distance between p and
                                        b, andu is a unit vector in the
                                        direction going from p to b.
                                        When we consider all the forces
                                        that apply to one given body, we
                                        have to sum up the contribution
                                        of all the other bodies:
                                    </para>
                                    <para>
                                        <informalfigure>
                                            <mediaobject>
                                                <imageobject>
                                                    <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/nbody/forces_sum.png" format="PNG"/>
                                                </imageobject>
                                            </mediaobject>
                                        </informalfigure>
                                    </para>
                                    <para>
                                        This should be read as: the
                                        total force on the body b is the
                                        sum of all the forces applied to
                                        b, generated by all the other
                                        bodies in the system.
                                    </para>
                                    <para>
                                        This is the force that has to be
                                        computed for every body in the
                                        system. With this force, using
                                        the usual physics formulae,
                                        (Newton's second Law)
                                    </para>
                                    <para>
                                        <informalfigure>
                                            <mediaobject>
                                                <imageobject>
                                                    <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/nbody/acc.png" format="PNG"/>
                                                </imageobject>
                                            </mediaobject>
                                        </informalfigure>
                                    </para>
                                    <para>
                                        one may now compute the movement
                                        of a particle for a given time
                                        step (a the acceleration, v the
                                        velocity, x the position, t the
                                        time):
                                    </para>
                                    <para>
                                        <informalfigure>
                                            <mediaobject>
                                                <imageobject>
                                                    <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/nbody/movement_equations.png" format="PNG"/>
                                                </imageobject>
                                            </mediaobject>
                                        </informalfigure>
                                    </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
        
        <section><info><title>How to run the n-body example</title></info>
            
            <para>
                With the script located in the folder
                <literal>ProActive/script/[unix|windows]</literal>
                do:
            </para>
        <programlisting xml:lang="screen"><textobject><textdata fileref="guided_tour/code_snippets/nbody_run.txt"/></textobject></programlisting>
            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis role="bold">No parameter</emphasis>
                        starting in default mode (2D).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="bold">-nodisplay</emphasis>
                        starting in console mode.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="bold">-displayft</emphasis>
                        starting with fault-tolerance configuration.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="bold">-3d</emphasis>
                        starting GUI in 3D, must have
                        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://java3d.dev.java.net/">
                            Java3d
                        </link>
                        (≥ 1.4) installed and also must have ProActive
                        compiled with it installed.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="bold">-3dft</emphasis>
                        same as above with fault-tolerance
                        configuration.
                    </para>
                </listitem>
            </itemizedlist>
            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis role="bold">totalNbBodies</emphasis>
                        is the total number of bodies, default is 4
                        bodies.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="bold">maxIter</emphasis>
                        is the maximun number of iterations, default is
                        10,000 iterations.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Right after starting the application, users have to
                choose one algorithm for computing. The choice is
                between:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Simplest version, one-to-one communication and
                        master.
                    </para>
                </listitem>
                <listitem>
                    <para>Group communication and master.</para>
                </listitem>
                <listitem>
                    <para>
                        Group communication, odd-even-synchronization.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Group communication, oospmd synchronization.
                    </para>
                </listitem>
                <listitem>
                    <para>Barnes-Hut.</para>
                </listitem>
            </itemizedlist>
            <para>Mouse controls with the 3D GUI:</para>
            <itemizedlist>
                <listitem>
                    <para>Left click: rotating.</para>
                </listitem>
                <listitem>
                    <para>Right click: moving the scene.</para>
                </listitem>
                <listitem>
                    <para>Scroll whell: zoom in/out</para>
                </listitem>
            </itemizedlist>
        </section>
        <section><info><title>Barnes-Hut</title></info>
            
            <para>
                This way to construct the nbody simulation is based on a
                very different algorithm. This is inserted to show how
                one can express this algorithm in ProActive, but breaks
                off from the previous track, having such a different
                approach to solving the problem. Here's how it works:
            </para>
            <para>
                To avoid broadcasting to every active object the new
                position of every particle, a tree implementation can
                simplify the problem by agglomerating sets of particles
                as a single particle, with a mass equal to the sum of
                masses of the all the particles:. This is the core of
                the Barnes-Hut algorithm. This method allows us to have a complexity brought
                down to O(N log N).
            </para>
            <para>
                In our parallel implementation, we have defined an
                <literal>Active Object</literal>
                called
                <literal>Domain</literal>
                , which represents a volume in space, and which contains
                <literal>Planets</literal>
                . It is either subdivided into smaller
                <literal>Domains</literal>
                , or is a leaf of the total tree, and then only contains
                <literal>Planets</literal>
                . A Planet is still an Object with mass, velocity and
                position, but is no longer on a one-to-one connection
                with a
                <literal>Domain</literal>
                . We have cut down communications to the biggest
                <literal>Domains</literal>
                possible : when a
                <literal>Planet</literal>
                is distant enough, its interactions are not computed,
                but it is grouped with its local neighbours to a bigger
                particle. Here is an example of the
                <literal>Domains</literal>
                which would be known by the
                <literal>Domain</literal>
                drawn in red:
            </para>
            <informaltable frame="none">
                <tgroup cols="2">
                    <tbody>
                        <row>
                            <entry>
                                <para>
                                    <informalfigure>
                                        <mediaobject>
                                            <imageobject>
                                                <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/nbody/Domain_subdivision.png" format="PNG"/>
                                            </imageobject>
                                        </mediaobject>
                                    </informalfigure>
                                </para>
                            </entry>
                            <entry>
                                <para>
                                    <informalfigure>
                                        <mediaobject>
                                            <imageobject>
                                                <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/nbody/tree.png" format="PNG"/>
                                            </imageobject>
                                        </mediaobject>
                                    </informalfigure>
                                </para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <para>
                The Domain in the lower left hand-corner, drawn in blue,
                is also divided into sub-Domains, but this needs not be
                known by the Domain in red: it assumes all the particles
                in the blue Domain are only one big one, centered at the
                center of mass of all the particles within the blue.
            </para>
            <para>
                In this version, the
                <literal>Domains</literal>
                communicate with a reduced set of other
                <literal>Domains</literal>
                , spanning on volumes of different sizes.
                Synchronization is achieved by sending explicitely
                iteration numbers, and returning when needed older
                positions. You may notice that some
                <literal>Domains</literal>
                seem desynchronized with other ones, having several
                iterations inbetween. That is no problem because if they
                then need to be synchronized and send each other
                information, a mechanism saving the older positions
                permits to send them when needed.
            </para>
              <para>
       			 This is a snapshot of the ProActive n-body
                example running on 3 hosts with 8 bodies:
            </para>
            <para>
                <informalfigure>
                    <mediaobject>
                        <imageobject>
                            <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/nbody/gui.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
                </informalfigure>
            </para>
				<para>
				 n-body screenshot, with the application GUI and
                        Java3D installed:
                </para>

            <para>
                <informalfigure>
                    <mediaobject>
                        <imageobject>
                            <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="guided_tour/pics/nbody/gui3d.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
                </informalfigure>
            </para>
            
        </section>
    </section>
	
	<!-- COMPONENTS -->
	
    <section xml:id="C3D_component_example"><info><title>C3D - Active Objects to Components</title></info>
    
        <para>
            The standard C3D example has been
            taken as a basis, and component wrappers have been created.
           This is an example of an application that is refactored to
            fit the components dogma. 
            This way, one can see what is needed to transform an
            application into component-oriented code.
        </para>
        <!-- Only the name of the package appears in the pdf -->
        <para os="pdf">
            You may find the code in the
            <literal>examples/components/c3d</literal>
            directory of the proactive source.
        </para>
		<section><info><title>Refactoring C3D  with components</title></info>
        
                <para>
           
            Add wrappers around the
            original object classes (C3D*) and instead of linking the
            classes together by setting fields through the initial
            methods, do that in the binding methods. In other words, we
            have to spot exactly where C3DRenderingEngine, C3DUser and
            C3DDispatcher are used by a class other than itself, and
            turn these references into component bindings. Of course, we
            also have to expose the interfaces that we are going to use,
            hence the Dispatcher, Engine and User interface that have to
            be implemented.
        </para>
        
            <figure><info><title>
                    Informal description of the C3D Components hierarchy
                </title></info>
                
                <mediaobject>
                    <imageobject>
                        <imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="components/pics/C3D-Components-UML.png" format="PNG"/>
                    </imageobject>
                </mediaobject>
            </figure>
        <para>
            First of all, have a look at the doc on C3D to remember how
            this application is written, in
            <xref linkend="C3D_example"/>
            . Most important is the class diagram, showing C3DUser,
            C3DDispatcher and C3DRederingEngine. We decided that the
            only objects worth wrapping in components were those three.
            The rest is too small to be worth the hassle.
        </para>
    </section>

        <section><info><title>Creating the interfaces</title></info>
            
            <para>
                What we need to do is to extract the interfaces of the
                Objects, ie find which methods are going to be called on
                the components. This means find out what methods are
                called from outside the Active Object. You can do that
                by searching in the classes where the calls are made on
                active objects. For this,
                <emphasis role="bold">
                    you have to know in detail which classes are going
                    to be turned into component
                </emphasis>
                . If you have a code base which closely follows Object
                Oriented Programming rules, the interfaces are already
                there. Indeed, when a class is written, it should always
                go with one or more interfaces, which present to the
                world what the class abilities are. In C3D (Active
                Object version), these interfaces already exist: they
                are called
                <literal>User</literal>
                ,
                <literal>Engine</literal>
                and
                <literal>Dispatcher</literal>
                .
            </para>
            <note>
                <para>
                    <emphasis role="bold">Tricky part:</emphasis>
                    whatever way you look at components, you'll have to
                    modify the initial code if these interfaces were not
                    created at first go. You have to replace all the
                    class references by their interface, when you use
                    them in other files. For example, if we had not
                    already used interfaces in the C3D Object code, we
                    would have had to replace all occurrences of
                    C3DDispatcher by occurrences of Dispatcher.
                </para>
            </note>
            <para>
                Why do we have to do that, replacing classes by
                interfaces? That's due to the way components work. When
                the components are going to be bound, you're not binding
                the classes themselves (ie the container which performs
                operations), but [proxies to] the interfaces presenting
                the behaviour available. And these proxies implement the
                interfaces, and do not extend the classes. What is
                highlighted here is that components enforce good code
                design by separating behaviours.
            </para>
        </section>
        <section><info><title>Creating the Component Wrappers</title></info>
            
            <para>
                You now have to create a class that englobes the
                previous Active Objects, and which is a component
                representing the same functionality. How do you do that?
                Pretty simple. All you need to do is extend the Active
                Object class, and add to it the non-functional
                interfaces which go with the component. You have the
                binding interfaces to create, which basically say how to
                put together two Components, tell who is already
                attached, and how to separate them. These are the
                <literal>lookupFc</literal>
                ,
                <literal>listFc</literal>
                ,
                <literal>bindFc</literal>
                and
                <literal>unbindFc</literal>
                methods.
            </para>
            <para>
                This has been done in the
                <literal>*Impl</literal>
                files. Let's consider, for example, the UserImpl class
                (it is shown below).What you have here are those
                component methods. Be even more careful with this
                <literal>bindFc</literal>
                method. In fact, it really binds the protected
                <literal>Dispatcher</literal>
                variable
                <literal>c3ddispatcher</literal>
                . This way, the
                <literal>C3DUser</literal>
                code can now use this variable as if it was addressing
                the real Active Object. Just to be precise, we have to
                point out that you're going through proxies before
                reaching the Component, then the Active Object. This is
                hidden by the ProActive layer, all you should know is
                you're addressing a
                <literal>Dispatcher</literal>
                , and you're fine! The
                <literal>findDispatcher</literal>
                method has been overridden because component lookup
                doesn't work like standard Active Object lookup.
            </para>
            <para>
                Suppose you are only dealing with packaged software.
                That means you may not modify the source code of some
                part of your application, for instance because it is
                kindly given to you by some other company, which wants
                to keep parts of its codebase secret. Let's say that the
                deployment descriptor you're using does not reference
                the proper
                <literal>VirtualNodes</literal>
                . How can you still deploy your application in this
                case? Well, you have to
                <emphasis>rename</emphasis>
                those Nodes into the names that are fitting to your
                application. You should do that after the definition of
                the interfaces that are defined inside the component.
                Here's an example of how to do that, renaming the
                externally provided name 'UserVirtualNode' to the name
                internally used by UserImpl 'User':
            </para>
            <para>
                In the main ADL file (
                <literal>userAndComposite.fractal</literal>
                )
            </para>
            <programlisting xml:lang="xml">  &lt;component ... /&gt;
       
    &lt;!-- mapping the node names in the descriptor file to others referenced in the component's adl files. --&gt;
    &lt;exportedVirtualNodes&gt;
      &lt;exportedVirtualNode name="UserVirtualNode"&gt;
        &lt;composedFrom&gt;
           &lt;composingVirtualNode component="user" name="User"/&gt;
        &lt;/composedFrom&gt;
      &lt;/exportedVirtualNode&gt;
    &lt;/exportedVirtualNodes&gt;
       
    &lt;!-- Creating one user component --&gt;</programlisting>
            <para>
                In the User ADL file (
                <literal>UserImpl.fractal</literal>
                )
            </para>
            <example><info><title>How to rename Virtual Nodes in ADL files</title></info>
                
                <programlisting xml:lang="xml">&lt;content class="org.objectweb.proactive.examples.components.c3d.UserImpl"/&gt;
       
    &lt;!-- Recalling a renamed Virtual Node --&gt;
    &lt;exportedVirtualNodes&gt;
      &lt;exportedVirtualNode name="User"&gt;
        &lt;composedFrom&gt;
          &lt;composingVirtualNode component="this" name="User"/&gt;
        &lt;/composedFrom&gt;
      &lt;/exportedVirtualNode&gt;
    &lt;/exportedVirtualNodes&gt;
       
    &lt;controller desc="primitive"/&gt;</programlisting>
            </example>
            <para>
                If you add this code into the adl, you are saying that
                the
                <literal>VirtualNode</literal>
                called
                <literal>UserVirtualNode</literal>
                (found in the deployment descriptor file the application
                is using) should be recognized by the application as if
                it was called
                <literal>User</literal>
                .
            </para>
            <note>
                <para>
                    Above has been described the way to rename a
                    <literal>VirtualNode</literal>
                    ; this can be used on packaged software, when the
                    <literal>VirtualNodes</literal>
                    provided do not fit the
                    <literal>VirtualNodes</literal>
                    needed by your application.
                </para>
            </note>
        </section>
        <section><info><title>Component lookup and registration</title></info>
            
            <para>
                When running the User Component alone, you are prompted
                for an address on which to lookup a Dispatcher
                Component. Then the two components are bound through a
                lookup mechanism. This is very simple to use. Here's the
                code to do that:
            </para>
            <example><info><title>Component Lookup and Register</title></info>
                
                <para>The component Registration</para>
                <para>
                    <programlisting xml:lang="java">Fractive.register(Fractive.getComponentRepresentativeOnThis(),
      UrlBuilder.buildUrlFromProperties("localhost", "Dispatcher"));</programlisting>
                </para>
                <para>The Component lookup</para>
                <para>
                    <programlisting xml:lang="java">ProActiveComponentRepresentative a = Fractive.lookup(
      UrlBuilder.buildUrl(this.hostName, "Dispatcher", protocol, this.portNumber));
      this.c3dDispatcher = (Dispatcher) a.getFcInterface("user2dispatcher");</programlisting>
                </para>
            </example>
            <para>
                For the registeration, you only need a reference on the
                component you want to register, and build a url
                containing the name of the host, containing an alias for
                the Component.
            </para>
            <para>
                The
                <literal>Fractive.lookup</literal>
                method uses a Url to find the host which holds the
                component. This Url contains the machine name of the
                host, communication protocl and portNumber, but also the
                lookup name under which the desired Component has been
                registered under , here "Dispatcher". The last operation
                consists only in retreiving the correct interface to
                which to connect to. If the interface is not known at
                compile-time, it can be discovered at run-time with the
                <literal>getFcInterfaces()</literal>
                method, which lists all the interfaces available.
            </para>
        </section>
        <section><info><title>How to run components C3D </title></info>
        
        <para>
            There is only one access point for this example in the
            scripts directory:
        </para>
        <screen>ProActive/scripts/unix/components$ ./c3d.sh
--- Fractal C3D example ---------------------------------------------
Parameters : descriptor_file [fractal_ADL_file]
        The first file describes your deployment of computing nodes.
                You may want to try ../../../descriptors/components/C3D_all.xml
        The second file describes your components layout.
                Default is org.objectweb.proactive.examples.components.c3d.adl.userAndComposite
---------------------------------------------------------</screen>
        <para>
            There are two  ways to start the components C3D. If you only
            want to start the Composite (Dispatcher + Renderer): 
        </para>
        <screen>ProActive/scripts/unix/components$ ./c3d.sh \
../../../descriptors/components/C3D_all.xml \
org.objectweb.proactive.examples.components.c3d.adl.compositeOfDispRend</screen>
        <para>
            If you want to start only a User, you will be asked for the
            address of a Dispatcher to which to connect to:
        </para>
        <screen>ProActive/scripts/unix/components$ ./c3d.sh \
../../../descriptors/components/C3D_all.xml \
org.objectweb.proactive.examples.components.c3d.adl.UserImpl</screen>
        </section>
		<section><info><title>Conclusion</title></info>
			
				<para>These are a few of the examples present in the ProActive
				distribution. To see a full list of the examples go to 
				the
				<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://proactive.inria.fr/index.php?page=applications">
				application</link> web page.</para> 
		</section>
    </section>

</chapter>
