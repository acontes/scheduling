<!-- Converted by db4-upgrade version 1.0 -->

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="MasterWorker"><info><title>Master/Worker API</title></info>
    

    <para>The outline of this short handbook:</para>

    <orderedlist>
        <listitem>
            <para>
                <link linkend="ms_overview">Introduction</link>
            </para>
        </listitem>

        <listitem>
            <para>
                <link linkend="ms_principle">Principle and Usage</link>
            </para>
        </listitem>

        <listitem>
            <para>
                <link linkend="ms_api">The API Description</link>
            </para>
        </listitem>

        <listitem>
            <para>
                <link linkend="ms_example">A Simple Example</link>
            </para>
        </listitem>
        <listitem>
            <para>
                <link linkend="ms_advanced">Advanced usage</link>
            </para>
        </listitem>
    </orderedlist>

    <section xml:id="ms_overview"><info><title>Overview</title></info>
        

        <para>
            Master/Worker computations
            are the most common case of distributed computations. They are 
            are suited well for embarrassingly parallel problems, for which
            the problem is easy to segment into a very large number of parallel tasks, and
            for which there is no essential dependency (or communication) between
            those parallel tasks.
        </para>

        <para>
            The main goal of the Master/Worker API is to provide an
           	easy to use framework
            for parallelizing embarrassingly parallel applications.
        </para>

        <para>The main features are:</para>

        <itemizedlist>
            <listitem>
                <para>
                    Automatic tasks
                    scheduling for the Workers.
                </para>
            </listitem>

            <listitem>
                <para>
                    Automatic
                    load-balancing
                    between the Workers
                </para>
            </listitem>

            <listitem>
                <para>
                    Automatic
                    fault-tolerance
                    mechanism (i.e. when a Worker is missing, the task is
                    rescheduled)
                </para>
            </listitem>

            <listitem>
                <para>
                    Very simple mechanism for
                    solution gathering
                    
                </para>
            </listitem>

            <listitem>
                <para>
                    All the internal concepts of ProActive are hidden from
                    the user
                </para>
            </listitem>

            <listitem>
                <para>Open and extensible API</para>
            </listitem>
        </itemizedlist>
    </section>

    <section xml:id="ms_principle"><info><title>The Master/Worker API </title></info>
        

        <para>
            The usage of the Master/Worker API is simple and it consists
            basically of four steps:
        </para>

        <orderedlist>
            <listitem>
                <para>
                   Deployment
                    of the Master/Worker framework.
                </para>
            </listitem>

            <listitem>
                <para>
                    Task definition 
                    and submission
                 
                </para>
            </listitem>

            <listitem>
                <para>
                    Results gathering
                </para>
            </listitem>

            <listitem>
                <para>
                    Optionally,
                    release
                    of acquired resources
                </para>
            </listitem>
        </orderedlist>

        <section xml:id="ms_principle_deployment"><info><title>Deployment of the Master/Worker framework</title></info>
            

            <para>
                The deployment of the Master/Worker framework relies on
                the
                ProActive deployment mechanism.
                In order to deploy a set of workers, the master needs
                either:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        a ProActive deployment descriptor                     
                        to be used by the master to deploy its resources.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        a set of already deployed
                        ProActive resources like a VirtualNode object or a Collection of
                        Node objects
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                For a full explanation of the ProActive deployment
                mechanism and of ProActive deployment descriptors, see
                <xref linkend="XML_Descriptors"/>
                .:
            </para>

            <para>
                <figure><info><title>
                        Deployment of the Master/Worker framework
                    </title></info>
                    

                    <mediaobject>
                        <imageobject>
                            <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="images/MasterWorker1.png" format="PNG" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>
            <para/>

        </section>

        <section xml:id="ms_principle_submission"><info><title>Tasks definition and submission</title></info>

            

            <para>
                In order to submit tasks to the Master, the
                <emphasis>Task</emphasis>
                interface from the Master/Worker API needs to be
                implemented. In this interface, the unique method
                <emphasis>run</emphasis>
                will correspond to the code being executed remotely.
                After tasks have been submitted to him, the master will
                dispatch tasks automatically to the workers.
            </para>
            <para>
                <emphasis>Warning !</emphasis>
                : when a Java object implementing the Task interface
                (i.e. a user task) is submitted to the master, the
                object will be deep-copied to the master. In
                consequence, every referenced objects will also be
                copied. When tasks are submitted to the remote workers,
                the user task objects will be
                <emphasis>serialized</emphasis>
                and sent though the network. As a consequence,
                information which means something only locally will be
                lost (database connections, reference to a thread,
                etc...)
            </para>

            <para>
                <figure><info><title>Tasks definition and submission</title></info>
                    

                    <mediaobject>
                        <imageobject>
                            <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="images/MasterWorker2.png" format="PNG" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>
            <para/>
        </section>

        <section xml:id="ms_principle_gathering"><info><title>Results gathering</title></info>
            
		<para>
			The Monte-Carlo methods groups under the same name 
				method which solves a problem by generating
				random numbers and examining how a fraction of
				the generated numbers follow certain patterns.
				The method can be used to obtain numerical results
				for problems which would be hard to solve through
				analytical methods. 
		 
		</para>

            <para>
                <emphasis>Results</emphasis>
                will be collected by the master when the calculations
                are complete. Users can either wait that one or every
                results are available. Users have also the option to ask
                the master for result availability and continue their
                own work until results are finally available.
            </para>

            <para>
                <figure><info><title>Results gathering</title></info>
                    

                    <mediaobject>
                        <imageobject>
                            <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="images/MasterWorker3.png" format="PNG" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>

            <para>
                Two results can be received in two modes specified in
                the
                <emphasis>ResultReceptionMode</emphasis>
                :
                <itemizedlist>
                    <listitem>
                        <para>
                            <emphasis>CompletionOrder</emphasis>
                            mode (default) : in this mode, users will
                            receive the results in an
                            <emphasis>unspecified order</emphasis>
                            , depending on tasks completion order.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <emphasis>SubmissionOrder</emphasis>
                            mode : in this mode, users will receive the
                            results in the same order as they were
                            submitted to the master.
                        </para>

                    </listitem>
                </itemizedlist>
            </para>
            <para>
                The figures below explain the two different modes :
            </para>
            <para>
                <figure><info><title>Completion order</title></info>
                    

                    <mediaobject>
                        <imageobject>
                            <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="images/MSResult1.png" format="PNG" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>
            <para>
                <figure><info><title>Submission order</title></info>
                    

                    <mediaobject>
                        <imageobject>
                            <imagedata scalefit="1" width="100%" contentdepth="100%"   fileref="images/MSResult2.png" format="PNG" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>
            <para/>
        </section>
    </section>

    <section xml:id="ms_api"><info><title>The API Details</title></info>
        
        <section><info><title>Logger Settings</title></info>
        	
        	<para>
        		Before using the Master/Worker, launch the examples, or
        		write your own code, it is very useful to enable the
        		maximum logging information to have a deeper look at how
        		the API works. In order to do that you'll need to add
        		the following lines in the proactive-log4j file that you
        		are using:
        	</para>
        	<programlisting><textobject><textdata fileref="code_snippets/masterworker/logger_settings.txt"/></textobject> </programlisting>
        </section>
        <section><info><title>Master Creation And Deployment</title></info>
            

            <para>
                The Master/Worker API entry point and main class is the
                following:
            </para>
            <screen>org.objectweb.proactive.extensions.masterworker.ProActiveMaster</screen>
            <para>
                The methods of this class are described in the
                interface:
            </para>
            <screen>org.objectweb.proactive.extensions.masterworker.interfaces.Master</screen>
            <para>
                The user has the possibility to create either a local
                master or a remote master.
            </para>
            <section><info><title>Local Master creation</title></info>
                
                <para>
                    In order to create a local master the following
                    constructors can be used:
                </para>
                <programlisting xml:lang="java">    /**
     * Creates a local master (you can add resources afterwards)
     */
    public ProActiveMaster();</programlisting>
                <para>
                    Using this constructor, a master will be created in
                    the current JVM, the master will share CPU usage and
                    memory with the user JVM.
                </para>
            </section>
            <section><info><title>Remote Master creation</title></info>
                
                <para>
                    In order to create a remote master the following
                    constructors can be used:
                </para>
                <programlisting xml:lang="java">    /**
     * Creates an empty remote master that will be created on top of the given Node &lt;br&gt;
     * Resources can be added to the master afterwards
     * @param remoteNodeToUse this Node will be used to create the remote master
     */
    public ProActiveMaster(Node remoteNodeToUse);

    /**
     * Creates a remote master with the URL of a descriptor and the name of a virtual node
     * The master will be created on top of a single resource deployed by this virtual node
     * @param descriptorURL url of the ProActive descriptor
     * @param masterVNName name of the virtual node to deploy inside the ProActive descriptor
     */
     
    public ProActiveMaster(URL descriptorURL, String masterVNName);</programlisting>

                <para>
                    Using either of these constructors, a master will be
                    created in the specified remote resource(JVM), the
                    master will share CPU usage and memory with existing
                    running applications on the remote host. The
                    mechanism in use to deploy the master remotely is
                    the ProActive deployment mechanism (see
                    <xref linkend="XML_Descriptors"/>
                    for further details).
                </para>
            </section>
            <section><info><title>Adding Resources</title></info>
                
                <para>
                    Now that the master has been created, resources
                    (Workers) must be added to it. The following methods
                    can be used for creating workers:
                </para>
                <programlisting xml:lang="java">    /**
     * Adds the given Collection of nodes to the master &lt;br/&gt;
     * @param nodes a collection of nodes
     */
    void addResources(Collection&lt;Node&gt; nodes);
    
    /**
     * Adds every resource inside the given virtual node to the master &lt;br/&gt;
     * @param virtualnode a virtual node object
     */
    void addResources(VirtualNode virtualnode);

    /**
     * Adds the given descriptor to the master&lt;br&gt;
     * Every virtual nodes inside the given descriptor will be activated&lt;br/&gt;
     * @param descriptorURL URL of a deployment descriptor
     */
    void addResources(URL descriptorURL);

    /**
    * Adds the given descriptor to the master&lt;br&gt;
    * Only the specified virtual node inside the given descriptor will be activated &lt;br/&gt;
    * @param descriptorURL URL of a deployment descriptor
    * @param virtualNodeName name of the virtual node to activate
    */
    void addResources(URL descriptorURL, String virtualNodeName);</programlisting>
                <para>
                    The first two methods will tell the master to create
                    workers on already deployed ProActive resources. The
                    last two methods will ask the master to deploy
                    resources using a ProActive descriptor and to create
                    workers on top of these resources. For a complete
                    explanation of ProActive's deployment mechanism,
                    please refer to
                    <xref linkend="XML_Descriptors"/>
                    .
                </para>

            </section>
        </section>

        <section><info><title>Task Definition</title></info>
            

            <para>
                The task interface is defined at:
                <screen>org.objectweb.proactive.extensions.masterworker.interfaces.Task</screen>
            </para>

            <programlisting xml:lang="java">public interface Task&lt;R extends Serializable&gt; extends Serializable {
    /**
     * A task to be executed
     * @param memory access to the Worker memory
     * @return the result
     * @throws Exception
     */
    public R run(WorkerMemory memory) throws Exception;
};</programlisting>

            <para>
                Users need to implement the
                <emphasis>Task</emphasis>
                interface to define their tasks. The
                <emphasis>WorkerMemory</emphasis>
                parameter is explained in the
                <link linkend="ms_Workermemory">Advanced Usage</link>
                chapter.
            </para>
        </section>

        <section><info><title>Task submission</title></info>
            

            <programlisting xml:lang="java">    /**
     * Adds a list of tasks to be solved by the master &lt;br/&gt;
     * @param tasks list of tasks
     * @throws TaskAlreadySubmittedException if a task is submitted twice
     */
    void solve(List&lt;T&gt; tasks) throws TaskAlreadySubmittedException;</programlisting>
            <para>
                <emphasis>Warning !</emphasis>
                : the master keeps a track of task objects that have
                been submitted to it and which are currently computing.
                Submitting two times the same task object without
                waiting for the result of the first computation is not
                allowed.
            </para>

        </section>

        <section><info><title>Specifying result reception order</title></info>
        	
        	<para>
        		Result reception order can be switched from
        		<emphasis>Completion</emphasis>
        		order to
        		<emphasis>Submission</emphasis>
        		order using the following method :
        	</para>
        	<programlisting xml:lang="java">    /**
     * Sets the current ordering mode &lt;br/&gt;
     * If reception mode is switched while computations are in progress,&lt;br/&gt;
     * then subsequent calls to waitResults methods will be done according to the new mode.&lt;br/&gt;
     * @param mode the new mode for result gathering
     */
    void setResultReceptionOrder(OrderingMode mode);</programlisting>
        	<para>
        		The default mode of the M/S API is
        		<emphasis>Completion</emphasis>
        		order. The mode can be switched dynamically, which means
        		that subsequent calls to waitXXX methods (see below),
        		will be done according to the new mode.
        	</para>
        </section>


        <section><info><title>Collecting results</title></info>
            

            <programlisting xml:lang="java">    /**
     * Wait for all results, will block until all results are computed &lt;br&gt;
     * The ordering of the results depends on the result reception mode in use &lt;br&gt;
     * @return a collection of objects containing the result
     * @throws TaskException if a task threw an Exception
     */
    List&lt;R&gt; waitAllResults() throws TaskException;

    /**
     * Wait for the first result available &lt;br&gt;
     * Will block until at least one Result is available. &lt;br&gt;
     * Note that in SubmittedOrder mode, the method will block until the next result in submission order is available&lt;br&gt;
     * @return an object containing the result
     * @throws TaskException if the task threw an Exception
     */
    R waitOneResult() throws TaskException;

    /**
     * Wait for a number of results&lt;br&gt;
     * Will block until at least k results are available. &lt;br&gt;
     * The ordering of the results depends on the result reception mode in use &lt;br&gt;
     * @param k the number of results to wait for
     * @return a collection of objects containing the results
     * @throws TaskException if the task threw an Exception
     */
    List&lt;R&gt; waitKResults(int k) throws TaskException;

    /**
     * Tells if the master is completely empty (i.e. has no result to provide and no tasks submitted)
     * @return the answer
     */
    boolean isEmpty();

    /**
     * Returns the number of available results &lt;br/&gt;
     * @return the answer
     */
    int countAvailableResults();</programlisting>

            <para>
                Five methods can be used in order to collect results:
                <itemizedlist>
                    <listitem>
                        <para>
                            The first three methods will block the
                            current thread until the corresponding
                            result(s) is(are) available. If an exception
                            occurs during the execution of one task,
                            this exception will be thrown back to the
                            user by the wait method.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            The fourth method will give indications on
                            results availability but will not block the
                            user thread.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            The last method will tell when the user has
                            received every results of tasks previously
                            submitted.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>

        <section><info><title>Terminating the master</title></info>
            

            <programlisting xml:lang="java">    /**
     * Terminates the master (and eventually free every resources)
     * @param freeNodeResources tells if the master should as well free the node resources
     * @return success
     */
    public void terminate(boolean freeResources);</programlisting>

            <para>
                One single method is used to terminate the master. A
                boolean parameter tells the master to free resources or
                not (i.e. terminate remote JVMs).
            </para>
        </section>
    </section>

    <section xml:id="ms_example"><info><title>A Simple Example</title></info>
        

        <para>
            This very simple example computes PI using the Monte-Carlo
            method. The complete example is available, along with more complex ones under the
            following package in the
            <emphasis>Examples</emphasis>
            source directory:
        </para>

        <screen>org.objectweb.proactive.examples.masterworker</screen>

        <para>
            First, the task definition: creates randomly a set of points
            belonging to the [0, 1[x[0, 1[ interval and tests how many
            points are inside the uniter circle.
        </para>

        <programlisting xml:lang="java">    public static class ComputePIMonteCarlo implements Task&lt;Long&gt; {
        public ComputePIMonteCarlo() {
        }

        public Long run(WorkerMemory memory) throws Exception {
            long remaining = NUMBER_OF_EXPERIENCES;
            long successes = 0;
            while (remaining &gt; 0) {
                remaining--;
                if (experience()) {
                    successes++;
                }
            }
            return successes;
        }

        public boolean experience() {
            double x = Math.random();
            double y = Math.random();
            return Math.hypot(x, y) &lt; 1;
        }
    }</programlisting>

        <para>
            The example main method: the master is created and resources
            are added using a deployment descriptor .
        </para>

        <programlisting xml:lang="java">        // creation of the master
        ProActiveMaster&lt;ComputePIMonteCarlo, Long&gt; master = new ProActiveMaster&lt;ComputePIMonteCarlo, Long&gt;();
        
        // adding resources
        master.addResources(PIExample.class.getResource(
                "/org/objectweb/proactive/examples/masterWorker/WorkersLocal.xml"));</programlisting>

        <para>
            Then, the tasks are created and submitted to the master.
        </para>

        <programlisting xml:lang="java">         // defining tasks
        Vector&lt;ComputePIMonteCarlo&gt; tasks = new Vector&lt;ComputePIMonteCarlo&gt;();
        for (int i = 0; i &lt; NUMBER_OF_TASKS; i++) {
            tasks.add(new ComputePIMonteCarlo());
        }

        // adding tasks to the queue
        master.solve(tasks);</programlisting>

        <para>
            Then, the results are gathered and the result is displayed.
        </para>

        <programlisting xml:lang="java">        // waiting for results
        List&lt;Long&gt; successesList = master.waitAllResults();

        // computing PI using the results
        long sumSuccesses = 0;

        for (long successes : successesList) {
            sumSuccesses += successes;
        }

        double pi = (4 * sumSuccesses) / ((double) NUMBER_OF_EXPERIENCES * NUMBER_OF_TASKS);

        System.out.println("Computed PI by Monte-Carlo method : " + pi);</programlisting>


        <para>
            Finally, the master is terminated (all resources are freed)
            and the program exits.
        </para>

        <programlisting xml:lang="java">        master.terminate(true);
        System.exit(0);</programlisting>
    </section>
    <section xml:id="ms_advanced"><info><title>Advanced Usage</title></info>
        

        <section xml:id="ms_configuration"><info><title>Configuration of the Master/Worker</title></info>
            
            <section><info><title>Ping Period</title></info>
                
                <para>
                    At regular intervals, the Master sends a "ping"
                    message to every Workers to check if they are alive
                    and reachable. The
                    <emphasis>Ping period</emphasis>
                    configuration parameter is the period in millisecond
                    between two "ping" messages. The default value of
                    this parameter is 10000 (which corresponds to 10
                    seconds).
                </para>
                <para>
                    In order to change this default value, the method
                    described underneath can be called :
                </para>
                <programlisting xml:lang="java">    /**
     * Sets the period at which ping messages are sent to the Workers &lt;br/&gt;
     * @param periodMillis the new ping period
     */
    void setPingPeriod(long periodMillis);</programlisting>
            </section>
            <section><info><title>Task flooding</title></info>
            	
            	<para>
            		The Master/Worker API's internal scheduling
            		mechanism is quite simple. It's is based on a
            		pulling strategy. When a worker has no more task to
            		run, it asks the master for new tasks. The master
            		usually gives a worker one task at the time, except
            		the first time the worker asks for task and each
            		time the worker has no more task to compute. In this
            		case, the master will do a
            		<emphasis>flooding</emphasis>
            		, it will give to worker as many tasks as the
            		configurable parameter of the same name. The default
            		value of this parameter is 2, as it is expected to
            		have at least twice as many tasks as workers. This
            		mechanism is meant to avoid having idle workers
            		waiting for new tasks all the time. The value of the
            		flooding parameter should depend on how big your
            		tasks are. A lot of small tasks should lead to a
            		high flooding value (&gt;10) where a small number of
            		big tasks should lead to a small value (1-5).
            	</para>
            	<para>
            	The method of the API to change the flooding parameter is the following: 
            	</para>
            	<programlisting xml:lang="java">    /**
     * Sets the number of tasks initially sent to each worker
     * default is 2 tasks
     * @param number_of_tasks number of task to send
     */
    void setInitialTaskFlooding(final int number_of_tasks);</programlisting>
            </section>
        </section>
        <section xml:id="ms_Workermemory"><info><title>Using the Worker Memory</title></info>
            
            <section><info><title>Principle</title></info>
                
                <para>
                    The Worker Memory principle is to allow users to
                    store and retrieve data from a
                    <emphasis>Worker's address space</emphasis>
                    . The typical use case is when one uses the
                    Master/Worker API to compute an iterative process.
                    An iterative process consists generally of an
                    initialization step 0, followed by n computation
                    steps, where step n needs the results of step n-1.
                    The initialization steps often requires that a large
                    amount of information is "loaded" into the worker.
                    Without the worker memory access, this information
                    would be lost at each step of the iteration, which
                    means that the initialization step 0 needs to be
                    done at step 1,2, ... n, etc...
                </para>
                <para>
                	The Worker Memory let you send, when workers are
                	initialized, an initial memory. Later on, when tasks
                	are executed, workers can have access to their
                	memory and save or load data from it. Please note that
                	this memory is not at all what is called a "shared
                	memory". A shared memory would mean that the SAME
                	memory would be shared by all workers. Here, each
                	worker has its own private memory, and if a worker
                	modifies its memory, the memory of other workers
                	won't be affected.
                </para>
            </section>
            <section><info><title>Usage</title></info>
                
                <section><info><title>Structure and API</title></info>
                    
                    <para>
                        The Worker memory structure is very simple: it
                        consists of
                        <emphasis>&lt;key, value&gt;</emphasis>
                        associations. A java object value is therefore
                        saved in the memory with the given name, and
                        this name will be needed to retrieve the value
                        later on.
                    </para>
                    <para>
                        The Worker Memory API consists of three methods
                        <emphasis>save</emphasis>
                        ,
                        <emphasis>load</emphasis>
                        , and
                        <emphasis>erase</emphasis>
                        . The interface to the worker memory is available
                        when running a Task as a parameter of the run
                        method. The user can therefore use this
                        interface to save, load or erase objects in the
                        local worker's memory. Below is the detailed
                        WorkerMemory interface:
                    </para>
                    <programlisting xml:lang="java">    /**
     * Save data under a specific name
     * @param name name of the data
     * @param data data to be saved
     */
    void save(String name, Object data);

    /**
     * Load some data previously saved
     * @param name the name under which the data was saved
     * @return the data
     */
    Object load(String name);

    /**
     * Erase some data previously saved
     * @param name the name of the data which need to be erased
     */
    void erase(String name);</programlisting>
                </section>
                <section><info><title>Storing data</title></info>
                    
                    <para>
                        A user can store data in the Workers' memory
                        either when :
                    </para>
                    <orderedlist>
                        <listitem>
                            <para>Workers are created remotely</para>
                        </listitem>
                        <listitem>
                            <para>A task is run on the Worker.</para>
                        </listitem>
                    </orderedlist>
                    <para>
                        Usage of the first mechanism is done by
                        providing a list of &lt;key, value&gt; pairs
                        (Map) to the constructors of the ProActiveMaster
                        class. Every constructors detailed above have a
                        version including this extra parameter. The
                        given list will be the initial memory of every
                        Workers created by the master.
                    </para>
                    <para>
                        Usage of the second mechanism is done by using
                        the
                        <emphasis>WorkerMemory</emphasis>
                        parameter in the Task interface's
                        <emphasis>run</emphasis>
                        method. In contradiction with the first method,
                        only the Worker currently running the Task will
                        store the given data.

                    </para>
                </section>
                <section><info><title>Retrieving and using the data</title></info>
                    
                    <para>
                        Loading and using any object stored in a Worker's
                        memory is simply done through the
                        <emphasis>WorkerMemory</emphasis>
                        parameter in the
                        <emphasis>run</emphasis>
                        method of the
                        <emphasis>Task</emphasis>
                        interface.
                    </para>

                </section>
            </section>
        </section>
    </section>
</chapter>
