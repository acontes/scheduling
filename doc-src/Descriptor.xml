<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="XML_Descriptors">
  <title>XML Deployment Descriptors</title>

  <indexterm>
    <primary>Descriptors</primary>

    <secondary>definition</secondary>
  </indexterm>

  <sect1 id="Descriptor_html_objectives">
    <title>Objectives</title>

    <para>Parameters tied to the deployment of an application should be
    totally described in a xml deployment descriptor. Hence within the source
    code, there are no longer any references to:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Machine names</emphasis></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Creation Protocols</emphasis></para>

        <para><itemizedlist>
            <listitem>
              <para>local</para>
            </listitem>

            <listitem>
              <para>ssh, gsissh, rsh, rlogin</para>
            </listitem>

            <listitem>
              <para>lsf, pbs, sun grid engine, oar, prun</para>
            </listitem>

            <listitem>
              <indexterm>
                <primary>Globus</primary>

                <secondary>XML Descriptor</secondary>
              </indexterm>

              <para>globus(GT2, GT3 and GT4), unicore, glite, arc
              (nordugrid)</para>
            </listitem>
          </itemizedlist></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Registry/Lookup and Communications
        Protocols</emphasis></para>

        <para><itemizedlist>
            <listitem>
              <para>rmi</para>
            </listitem>

            <listitem>
              <para>http</para>
            </listitem>

            <listitem>
              <para>rmissh</para>
            </listitem>

            <listitem>
              <para>ibis</para>
            </listitem>

            <listitem>
              <para>soap</para>
            </listitem>
          </itemizedlist></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Files Transfers</emphasis></para>

        <para><itemizedlist>
            <listitem>
              <para>scp, rcp</para>
            </listitem>

            <listitem>
              <para>unicore, arc (nordugrid)</para>
            </listitem>

            <listitem>
              <para>other protocols like globus, glite will be supported
              soon</para>
            </listitem>
          </itemizedlist></para>
      </listitem>
    </itemizedlist>

    <para>A ProActive application can be deployed on different hosts, with
    different protocols <emphasis role="bold">without</emphasis> changing the
    source code</para>
  </sect1>

  <sect1 id="Descriptor_Principles">
    <title>Principles</title>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Within a ProActive program, active objects
        are still created on Nodes</emphasis></para>

        <para><programlisting lang="java"> newActive(String, Object[], Node); </programlisting></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Nodes can be obtained from VirtualNodes
        (VN) declared and defined in a ProActiveDescriptor</emphasis></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Nodes are actual
        entities:</emphasis></para>

        <para><itemizedlist>
            <listitem>
              <para>running into a JVM, on a host</para>
            </listitem>

            <listitem>
              <para>they are the result of mapping VN --&gt; JVMs</para>
            </listitem>
          </itemizedlist> But VirtualNodes are names in program source, to
        which corresponds one or a set of Nodes after activation</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">After activation the names of Nodes mapped
        with a VirtualNode are VirtualNode name + random
        number</emphasis></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">VNs have the following
        characteristics:</emphasis></para>

        <para><itemizedlist>
            <listitem>
              <para>a VN is uniquely identified as a String ID</para>
            </listitem>

            <listitem>
              <para>a VN is defined in a ProActiveDescriptor</para>
            </listitem>

            <listitem>
              <para>a VN has an object representation in a program after
              activation</para>
            </listitem>
          </itemizedlist></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Additional methods are provided to create
        groups of active objects on VirtualNodes. In that case an Active
        Object(member of the group) is created on each nodes mapped to the
        VirtualNode given as parameter</emphasis></para>

        <para><programlisting lang="java">       newActiveAsGroup(String, Object[], VirtualNode);
       turnActiveAsGroup(Object, String, VirtualNode); </programlisting></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Within a ProActiveDescriptor file, it is
        specified:</emphasis></para>

        <para><itemizedlist>
            <listitem>
              <para>the mapping of VN to JVMs</para>
            </listitem>

            <listitem>
              <para>the way to create, acquire JVMs using processes defined in
              the lower infrastructure part</para>
            </listitem>

            <listitem>
              <para>local, remote processes or combination of both to create
              remote jvms.</para>

              <para>For instance defining an <emphasis
              role="bold">sshProcess</emphasis> that itself references a local
              <emphasis role="bold">jvmProcess</emphasis>. At execution, the
              ssh process will launch a jvm on the remote machine specified in
              hostname attribute of <emphasis
              role="bold">sshProcess</emphasis> definition.</para>
            </listitem>

            <listitem>
              <para>files transfers</para>
            </listitem>

            <listitem>
              <para>fault tolerance, P2P, security</para>
            </listitem>
          </itemizedlist></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Example:</emphasis></para>

        <para><programlisting lang="xml"> &lt;ProActiveDescriptor
 xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
 xsi:noNamespaceSchemaLocation='DescriptorSchema.xsd'&gt;                            
  &lt;componentDefinition&gt;
   &lt;virtualNodesDefinition&gt;
   &lt;virtualNode name='<emphasis role="bold">Dispatcher</emphasis>'/&gt;
   &lt;/virtualNodesDefinition&gt;
  &lt;/componentDefinition&gt;
  &lt;deployment&gt;
   &lt;mapping&gt;
    &lt;map virtualNode='<emphasis role="bold">Dispatcher</emphasis>'&gt;
     &lt;jvmSet&gt;
      &lt;vmName value='<emphasis role="bold">Jvm1</emphasis>'/&gt;
     &lt;/jvmSet&gt;
    &lt;/map&gt;
   &lt;/mapping&gt;
   &lt;jvms&gt;
    &lt;jvm name='<emphasis role="bold">Jvm1</emphasis>'&gt;
     &lt;creation&gt;
      &lt;processReference refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
     &lt;/creation&gt;
    &lt;/jvm&gt;
   &lt;/jvms&gt;
  &lt;/deployment&gt;
  &lt;infrastructure&gt;
   &lt;processes&gt;
    &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
     &lt;jvmProcess class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
    &lt;/processDefinition&gt;
   &lt;/processes&gt;
  &lt;/infrastructure&gt;
 &lt;/ProActiveDescriptor&gt;</programlisting> This example shows a
        VirtualNode called <emphasis role="bold">Dispatcher</emphasis>, that
        is mapped to a jvm called <emphasis role="bold">Jvm</emphasis>.</para>

        <para>This <emphasis role="bold">Jvm1</emphasis>will be created using
        the process called <emphasis role="bold">jvmProcess</emphasis> which
        is defined in the infrastructure part(This part will be discussed
        later, just notice that there are two parts in the descriptor, an
        abstract one containing VirtualNode definition and deployment
        informations and a more concrete one containing concrete
        infrastructure informations, that is where all processes are
        defined).</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Typical example of a program
        code:</emphasis></para>

        <para><screen> ProActiveDescriptor pad = ProActive.getProactiveDescriptor(String xmlFile); 
        //--------- Returns a ProActiveDescriptor object from the xml file 
        VirtualNode dispatcher = pad.getVirtualNode('Dispatcher');
        //-------- Returns the VirtualNode Dispatcher described in the xml file as a java  object
        dispatcher.activate();
        // -------- Activates  the VirtualNode
        Node node = dispatcher.getNode();
        // -------- Returns the first node available among nodes mapped to the VirtualNode
        
        C3DDispatcher c3dDispatcher =  newActive(
               'org.objectweb.proactive.core.examples.c3d.C3DDispatcher',param, node); 
        ..........................</screen></para>
      </listitem>
    </itemizedlist>

    <para>Set of methods are provided in
    org.objectweb.proactive.descriptor.ProActiveDescriptor to manipulate
    VirtualNodes, to activate several VirtualNodes at the same time .... and
    in org.objectweb.proactive.core.descriptors.VirtualNode to manipulate and
    get nodes associated to VirtualNodes.</para>
  </sect1>

  <sect1 id="Descriptor_html_vn">
    <title>Different types of VirtualNodes</title>

    <sect2>
      <title>VirtualNodes Definition</title>

      <para><itemizedlist>
          <listitem>
            <para>Mapping one to one: 1 VN --&gt; 1 JVM</para>

            <para><programlisting lang="xml"> &lt;virtualNodesDefinition&gt;                                  
  &lt;virtualNode name='<emphasis role="bold">Dispatcher</emphasis>'/&gt;
 &lt;/virtualNodesDefinition&gt;
 &lt;deployment&gt;
 &lt;mapping&gt;
  &lt;map virtualNode='<emphasis role="bold">Dispatcher</emphasis>'&gt;
   &lt;jvmSet&gt;
    &lt;vmName value='<emphasis role="bold">Jvm0</emphasis>'/&gt;
   &lt;/jvmSet&gt;
  &lt;/map&gt;
 &lt;/mapping&gt;</programlisting> Another possibility for the one to one
            mapping is to map 1 VN to the jvm running the program. In that
            case the lookup protocol can be specified but is optionnal(default
            value is the property <emphasis
            role="bold">proactive.communication.protocol</emphasis>) as it is
            shown in the following:</para>

            <screen> &lt;virtualNodesDefinition&gt;                                
  &lt;virtualNode name='<emphasis role="bold">Dispatcher</emphasis>'/&gt;
 &lt;/virtualNodesDefinition&gt;
 &lt;deployment&gt;
 &lt;mapping&gt;
  &lt;map virtualNode='<emphasis role="bold">Dispatcher</emphasis>'&gt;
   &lt;jvmSet&gt;
    &lt;currentJvm protocol='rmi'/&gt; or
    &lt;currentJvm/&gt;
   &lt;/jvmSet&gt;
  &lt;/map&gt;
 &lt;/mapping&gt;</screen>

            <para>Since it is the current jvm, it has not to be redifined
            later in the descriptor. This will be shown in a complete
            example</para>
          </listitem>

          <listitem>
            <para>Mapping one to n: 1 VN --&gt; N JVMs</para>

            <para><screen> &lt;virtualNodesDefinition&gt;                                  
  &lt;virtualNode name='<emphasis role="bold">Renderer</emphasis>' property='<emphasis
                  role="bold">multiple</emphasis>'/&gt;
 &lt;/virtualNodesDefinition&gt;
 &lt;deployment&gt;
  &lt;mapping&gt;
   &lt;map virtualNode='<emphasis role="bold">Renderer</emphasis>'&gt;
    &lt;jvmSet&gt;
     &lt;currentJvm/&gt;
     &lt;vmName value='<emphasis role="bold">Jvm1</emphasis>'/&gt;
     &lt;vmName value='<emphasis role="bold">Jvm2</emphasis>'/&gt;
     &lt;vmName value='<emphasis role="bold">Jvm3</emphasis>'/&gt;
     &lt;vmName value='<emphasis role="bold">Jvm4</emphasis>'/&gt;
    &lt;/jvmSet&gt;
   &lt;/map&gt;
  &lt;/mapping&gt;</screen> Note that the <emphasis
            role="bold">property</emphasis> attribute is set to <emphasis
            role="bold">multiple</emphasis> if you want to map 1 VN to
            multiple JVMs, and then a set of JVMs is defined for the
            VirtualNode <emphasis role="bold">Renderer</emphasis>. Four values
            are possible for the <emphasis role="bold">property</emphasis>
            attribute: <emphasis role="bold">unique</emphasis> which means one
            to one mapping, <emphasis role="bold">unique_singleAO</emphasis>:
            one to one mapping and only one AO deployed on the corresponding
            node, <emphasis role="bold">multiple</emphasis>: one to N mapping,
            <emphasis role="bold">multiple_cyclic</emphasis>: one to N mapping
            in a cyclic manner. This property is not mandatory but an
            exception can be thrown in case of incompatibility. For instance
            property set to unique, and more than one jvm defined in the
            jvmSet tag. In case of property set to <emphasis
            role="bold">unique_singleAO</emphasis> method <emphasis
            role="bold">getUniqueAO()</emphasis> in class
            org.objectweb.proactive.core.descriptor.data.VirtualNode called on
            such VirtualNode returns the unique AO created</para>

            <para>Three other attributes <emphasis role="bold">timeout,
            waitForTimeout, minNodeNumber</emphasis> can be set when defining
            a virtualNode</para>

            <screen> &lt;virtualNodesDefinition&gt;                                
  &lt;virtualNode name='<emphasis role="bold">Dispatcher</emphasis>' timeout='<emphasis
                role="bold">200</emphasis>' waitForTimeout='<emphasis
                role="bold">true</emphasis>'/&gt;
  &lt;virtualNode name='<emphasis role="bold">Renderer</emphasis>' timeout='<emphasis
                role="bold">200</emphasis>' minNodeNumber='<emphasis
                role="bold">3</emphasis>'/&gt;
 &lt;/virtualNodesDefinition&gt;</screen>

            <para>The <emphasis role="bold">timeout</emphasis> attribute
            represents an amount of time(in milliseconds) to wait before
            accessing Nodes mapped on the VirtualNode. The <emphasis
            role="bold">waitForTimeout</emphasis> attribute is a boolean. If
            set to <emphasis role="bold">true</emphasis>, you will have to
            wait exaclty timeout seconds before accessing Nodes. If set to
            <emphasis role="bold">false</emphasis>, timeout represents the
            maximum amount of time to wait, it means that if all nodes are
            created before the timeout expires, you get access to the Nodes.
            Defaut value for <emphasis role="bold">waitForTimeout</emphasis>
            attribute is <emphasis role="bold">false</emphasis>. The <emphasis
            role="bold">minNodeNumber</emphasis> attribute defines the minimum
            number of nodes to be created before accessing the nodes. If not
            defined, access to the nodes will occur once the timeout expires,
            or the number of nodes expected are effectively created. Setting
            this attribute allows to redefine the number of nodes expected, we
            define it as the number of nodes needed for the VirtualNode to be
            suitable for the application. In the exammple above, once
            <emphasis role="bold">3</emphasis> nodes are created and mapped to
            the VirtualNode <emphasis role="bold">Renderer</emphasis>, this
            VirtualNode starts to give access to its nodes. Those options are
            very usefull when there is no idea about how many nodes will be
            mapped on the VirtualNode(which is often unususal). Those
            attributes are optional.</para>
          </listitem>

          <listitem>
            <para>Mapping n to one: N VN --&gt; 1 JVMs</para>

            <para><screen> &lt;virtualNodesDefinition&gt;                                  
  &lt;virtualNode name='<emphasis role="bold">Dispatcher</emphasis>' property='<emphasis
                  role="bold">unique_singleAO</emphasis>'/&gt;
  &lt;virtualNode name='<emphasis role="bold">Renderer</emphasis>' property='<emphasis
                  role="bold">multiple</emphasis>'/&gt;
 &lt;/virtualNodesDefinition&gt;
 &lt;deployment&gt;
  &lt;mapping&gt;
   &lt;map virtualNode='<emphasis role="bold">Dispatcher</emphasis>'&gt;
    &lt;jvmSet&gt;
     &lt;vmName value='<emphasis role="bold">Jvm1</emphasis>'/&gt;
    &lt;/jvmSet&gt;
   &lt;/map&gt;
   &lt;map virtualNode='<emphasis role="bold">Renderer</emphasis>'&gt;
    &lt;jvmSet&gt;
     &lt;vmName value='<emphasis role="bold">Jvm1</emphasis>'/&gt;
     &lt;vmName value='<emphasis role="bold">Jvm2</emphasis>'/&gt;
     &lt;vmName value='<emphasis role="bold">Jvm3</emphasis>'/&gt;
     &lt;vmName value='<emphasis role="bold">Jvm4</emphasis>'/&gt;
    &lt;/jvmSet&gt;
   &lt;/map&gt;
  &lt;/mapping&gt;</screen> In this example both VirtualNodes <emphasis
            role="bold">Dispatcher</emphasis> and <emphasis
            role="bold">Renderer</emphasis> have a mapping with <emphasis
            role="bold">Jvm1</emphasis>, it means that at deployment time,
            both VirtualNodes will get nodes created in the same JVM. Here is
            the notion of <emphasis role="bold">co-allocation</emphasis> in a
            JVM.</para>
          </listitem>

          <listitem>
            <para>VirtualNode registration</para>

            <para>Descriptors provide the ability to register a VirtualNode in
            a registry such RMIRegistry, JINI Lookup, HTTP registry, IBIS/RMI
            Registry Service. Hence this VirtualNode will be accessible by
            another application as it is described in the <emphasis
            role="bold">VirtualNodes Acquisition</emphasis> section. The
            protocol(registry) to use can be specified in the descriptor, if
            not specified, the VirtualNode will register using the protocol
            specified in <emphasis
            role="bold">proactive.communication.protocol</emphasis>
            property.</para>

            <screen> &lt;virtualNodesDefinition&gt;                                
  &lt;virtualNode name='<emphasis role="bold">Dispatcher</emphasis>' property='<emphasis
                role="bold">unique_singleAO</emphasis>'/&gt;
 &lt;virtualNodesDefinition/&gt;
 &lt;deployment&gt;
  &lt;register virtualNode='<emphasis role="bold">Dispatcher</emphasis>' protocol='<emphasis
                role="bold">rmi</emphasis>'/&gt;
                                <emphasis role="bold">or</emphasis>
  &lt;register virtualNode='<emphasis role="bold">Dispatcher</emphasis>'/&gt;
 &lt;!--using this syntax, registers the VirtualNode with the protocol
 specified in <emphasis role="bold">proactive.communication.protocol</emphasis> property --&gt;
  &lt;mapping&gt;
   &lt;map virtualNode='<emphasis role="bold">Dispatcher</emphasis>'&gt;
    &lt;jvmSet&gt;
     &lt;vmName value='<emphasis role="bold">Jvm0</emphasis>'/&gt;
    &lt;/jvmSet&gt;
   &lt;/map&gt;
  &lt;/mapping&gt;</screen>

            <para>The <emphasis role="bold">register</emphasis> tag allows to
            register the VirtualNode <emphasis
            role="bold">Dispatcher</emphasis> when activated, on the local
            machine in the RMIRegistry. As said before this VirtualNode will
            be accessible by another application using the lookup tag(see
            below) or using method:
            ProActive.lookupVirtualNode(String).</para>
          </listitem>
        </itemizedlist></para>
    </sect2>

    <sect2>
      <title>VirtualNodes Acquisition</title>

      <indexterm>
        <primary>Acquisition</primary>

        <secondary>VirtualNode</secondary>
      </indexterm>

      <para>Descriptors provide the ability to acquire a VirtualNode already
      deployed by another application. Such VirtualNodes are defined in
      <emphasis role="bold">VirtualNodes Acquisition</emphasis> tag as it is
      done for <emphasis role="bold">VirtualNodesDefinition</emphasis> except
      that no property and no mapping with jvms are defined since such VNs are
      already deployed. In the deployment part, the lookup tag gives
      information on where and how to acquire the VirtualNode. Lookup will be
      performed when activating the VirtualNode.</para>

      <screen> &lt;virtualNodesAcquisition&gt;                          
  &lt;virtualNode name='<emphasis role="bold">Dispatcher</emphasis>'/&gt;
 &lt;/virtualNodesAcquisition&gt;
 ..........
 &lt;deployment&gt;
 ..........
  &lt;lookup virtualNode='<emphasis role="bold">Dispatcher</emphasis>' host='machine_name' protocol='rmi' port='2020'/&gt;
 &lt;/deployment&gt;          </screen>

      <para>As mentioned in the previous section, in order to acquire
      VirtualNode <emphasis role="bold">Dispatcher</emphasis>, it must have
      been previously registered on the specified host by another application.
      Sometimes, the host where to perform the lookup will only be known at
      runtime, it that case it is specified in the descriptor with '*' for the
      host attribute</para>

      <screen> &lt;lookup virtualNode='<emphasis role="bold">Dispatcher</emphasis>'
 host='<emphasis role="bold">*</emphasis>' protocol='rmi'/&gt;
</screen>

      <para>Then when the host name is available, ProActive provides method
      <emphasis role="bold">setRuntimeInformations</emphasis> in class
      org.objectweb.proactive.core.descriptor.data.VirtualNode to update the
      value and to perform the lookup. Typical example of code:</para>

      <programlisting lang="java">ProActiveDescriptor pad = ProActive.getProactiveDescriptor(String xmlFileLocation);          </programlisting>

      <para>//----------- Returns a ProActiveDescriptor object from the xml
      file</para>

      <para><literal>pad.activateMappings;</literal></para>

      <para>// -------------------activate all VirtualNodes(definition and
      acquisition)</para>

      <para><literal>vnDispatcher =
      pad.getVirtualNode('Dispatcher');</literal></para>

      <para><literal>..........................</literal></para>

      <para><literal>vnDispatcher.setRuntimeInformations('LOOKUP_HOST','machine_name);</literal></para>

      <para>//--------------set the property 'LOOKUP_HOST at runtime</para>

      <para>To summarize all VirtualNodes are activated by calling activate
      methods except if '*' is set for a VirtualNode to be acquired. In that
      case the lookup will be performed when giving host informations.</para>

      <para>Registration and lookup can be performed automatically when using
      tags in the descriptor as well as programmatically using static methods
      provided in org.objectweb.Proactive class:</para>

      <programlisting lang="java">ProActive.registerVirtualNode(
        VirtualNode virtualNode, 
        String registrationProtocol, 
        boolean replacePreviousBinding );          </programlisting>

      <programlisting lang="java">ProActive.lookupVirtualNode(String url, String protocol);          </programlisting>

      <programlisting lang="java">ProActive.unregisterVirtualNode(VirtualNode virtualNode);          </programlisting>
    </sect2>
  </sect1>

  <sect1 id="Descriptor_html_jvms">
    <title>Different types of JVMs</title>

    <sect2>
      <title>Creation</title>

      <para><itemizedlist>
          <listitem>
            <para>1 JVM --&gt; 1 Node</para>

            <para><screen> ...........................                                  
 &lt;jvm name='<emphasis role="bold">jvm1</emphasis>'&gt;
  &lt;creation&gt;
   &lt;processReference refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 .................................</screen> In this example, <emphasis
            role="bold">jvm1</emphasis> will be created using the process
            called <emphasis role="bold">jvmProcess</emphasis> (discussed
            later, this process represents a java process and can be seen as
            java ProActiveClassname command)</para>
          </listitem>

          <listitem>
            <para>1 JVM --&gt; N Nodes on a single JVM</para>

            <para><screen> ...........................                                  
 &lt;jvm name='<emphasis role="bold">jvm1</emphasis>'
 askedNodes='<emphasis role="bold">3</emphasis>'&gt;
  &lt;creation&gt;
   &lt;processReference refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 .................................</screen></para>
          </listitem>

          <listitem>
            <para>1 JVM --&gt; N Nodes on N JVMs</para>
          </listitem>

          <listitem>
            <para>This is the case when the process referenced is a cluster
            process(LSF, PBS, GLOBUS, ....) or a process list (see <xref
            linkend="Descriptor_html_processlist" />)</para>
          </listitem>
        </itemizedlist></para>
    </sect2>

    <sect2>
      <title>Acquisition</title>

      <indexterm>
        <primary>Acquisition</primary>

        <secondary>JVM</secondary>
      </indexterm>

      <para>Descriptors give the ability to acquire JVMs instead of creating
      them. To do so, it must be specified in the <emphasis
      role="bold">acquisition</emphasis> tag which service to use in oder to
      acquire the JVMs. Services will be described below, in the
      infrastructure part. At this point 2 services are provided: <emphasis
      role="bold">RMIRegistryLookup</emphasis> and <emphasis
      role="bold">P2PService</emphasis> service.</para>

      <screen> ...........................                          
 &lt;jvm name='<emphasis role="bold">jvm1</emphasis>'&gt;
  &lt;acquisition&gt;
   &lt;serviceReference refid='<emphasis role="bold">lookup</emphasis>'/&gt;
  &lt;/acquisition&gt;
 &lt;/jvm&gt;
 .................................</screen>

      <para>In this example, <emphasis role="bold">Jvm1</emphasis> will be
      acquired using the service called <emphasis
      role="bold">lookup</emphasis> (discussed later, this service represents
      a way to acquire a JVM). Note that the name <emphasis
      role="bold">lookup</emphasis> is totally abstract, with the condition
      that a service with the id <emphasis role="bold">lookup</emphasis> is
      defined in the infrastructure part</para>
    </sect2>
  </sect1>

  <sect1 id="Descriptor_html_validation">
    <title>Validation against XML Schema</title>

    <para>To avoid mistake when building XML descriptors, ProActive provides
    an XML Schema called <emphasis
    role="bold">DescriptorSchema.xsd</emphasis>. Then to validate your file
    against this schema, the following line must be put at the top of the xml
    document as it is done for all ProActive examples.</para>

    <para><literal>&lt;ProActiveDescriptor
    xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
    xsi:noNamespaceSchemaLocation='Location_of_DescriptorSchema.xsd'&gt;</literal></para>

    <para>Note that this schema is available in the ProActive distribution
    package under ProActive\descriptor directory. Using descriptors related
    methods (Proactive.getProactiveDescriptor(file)) triggers automatic and
    transparent validation of the file using <ulink
    url="http://xml.apache.org/xerces2-j/index.html">Xerces2_4_0</ulink> if
    the ProActive property <emphasis role="bold">schema.validation</emphasis>
    is set to <emphasis role="bold">enable</emphasis> (see <xref
    linkend="Configuration" /> for more details). If a problem occurs during
    the validation, an error message is displayed. Otherwise, if the
    validation is successful, no message appear. An XML validation tool such
    as XMLSPY5.0(windows) can also be used to validate XML descriptors.</para>
  </sect1>

  <sect1>
    <title>Complete description and examples</title>

    <para>Following XML files examples are used for the C3D application. The
    first file is read when launching the C3DDispatcher. The second one is
    read every time a C3DUser is added. Both files contain many features
    described earlier in this document.</para>

    <example>
      <title>C3D_Dispatcher_Render.xml</title>

      <para><screen> &lt;ProActiveDescriptor
 xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
 xsi:noNamespaceSchemaLocation='DescriptorSchema.xsd'&gt;                            
  &lt;componentDefinition&gt;
   &lt;virtualNodesDefinition&gt;
    &lt;virtualNode name='<emphasis role="bold">Dispatcher</emphasis>' property='<emphasis
            role="bold">unique_singleAO</emphasis>'/&gt;
    &lt;virtualNode name='<emphasis role="bold">Renderer</emphasis>' property='<emphasis
            role="bold">multiple</emphasis>'/&gt;
   &lt;/virtualNodesDefinition&gt;
  &lt;/componentDefinition&gt;
  &lt;deployment&gt;
   &lt;register virtualNode='<emphasis role="bold">Dispatcher</emphasis>'/&gt;
   &lt;mapping&gt;
    &lt;map virtualNode='<emphasis role="bold">Dispatcher</emphasis>'&gt;
     &lt;jvmSet&gt;
      &lt;currentJvm/&gt;
     &lt;/jvmSet&gt;
    &lt;/map&gt;
    &lt;map virtualNode='<emphasis role="bold">Renderer</emphasis>'&gt;
     &lt;jvmSet&gt;
      &lt;vmName value='<emphasis role="bold">Jvm1</emphasis>'/&gt;
      &lt;vmName value='<emphasis role="bold">Jvm2</emphasis>'/&gt;
      &lt;vmName value='<emphasis role="bold">Jvm3</emphasis>'/&gt;
      &lt;vmName value='<emphasis role="bold">Jvm4</emphasis>'/&gt;
     &lt;/jvmSet&gt;
    &lt;/map&gt;
   &lt;/mapping&gt;
   &lt;jvms&gt;
    &lt;jvm name='<emphasis role="bold">Jvm1</emphasis>'&gt;
     &lt;creation&gt;
      &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
     &lt;/creation&gt;
    &lt;/jvm&gt;
    &lt;jvm name='<emphasis role="bold">Jvm2</emphasis>'&gt;
     &lt;creation&gt;
      &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
     &lt;/creation&gt;
    &lt;/jvm&gt;
    &lt;jvm name='<emphasis role="bold">Jvm3</emphasis>'&gt;
     &lt;creation&gt;
      &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
     &lt;/creation&gt;
    &lt;/jvm&gt;
    &lt;jvm name='<emphasis role="bold">Jvm4</emphasis>'&gt;
     &lt;creation&gt;
      &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
     &lt;/creation&gt;
    &lt;/jvm&gt;
   &lt;/jvms&gt;
  &lt;/deployment&gt;
  &lt;infrastructure&gt;
   &lt;processes&gt;
    &lt;processDefinition
 id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
     &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
    &lt;/processDefinition&gt;
   &lt;/processes&gt;
  &lt;/infrastructure&gt;
 &lt;/ProActiveDescriptor&gt;
</screen></para>
    </example>

    <para>This example represents xml deployment descriptor for the C3D
    application. The abstract part containing VirtualNodes definition and
    deployment informations has already been explained. To summarize, two
    VirtualNodes are defined <emphasis role="bold">Dispatcher</emphasis> and
    <emphasis role="bold">Renderer</emphasis>. <emphasis
    role="bold">Dispatcher</emphasis> is mapped to the jvm running the main(),
    and will be exported using the protocol specified in <emphasis
    role="bold">proactive.communication.protocol</emphasis> property. This
    VirtualNode will be registered in a Registry(still using the protocol
    specified in <emphasis
    role="bold">proactive.communication.protocol</emphasis> property) when
    activated. <emphasis role="bold">Renderer</emphasis> is mapped to a set of
    JVMs called <emphasis role="bold">Jvm1</emphasis>, ..., <emphasis
    role="bold">Jvm4</emphasis>.</para>

    <example>
      <title>C3D_User.xml</title>

      <para><screen> &lt;ProActiveDescriptor
 xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
 xsi:noNamespaceSchemaLocation='DescriptorSchema.xsd'&gt;                            
  &lt;componentDefinition&gt;
   &lt;virtualNodesDefinition&gt;
    &lt;virtualNode name='<emphasis role="bold">User</emphasis>'/&gt;
   &lt;/virtualNodesDefinition&gt;
   &lt;virtualNodesAcquisition&gt;
    &lt;virtualNode name='<emphasis role="bold">Dispatcher</emphasis>'/&gt;
   &lt;/virtualNodesAcquisition&gt;
  &lt;/componentDefinition&gt;
  &lt;deployment&gt;
   &lt;mapping&gt;
    &lt;map virtualNode='<emphasis role="bold">User</emphasis>'&gt;
     &lt;jvmSet&gt;
      &lt;currentJvm/&gt;
     &lt;/jvmSet&gt;
    &lt;/map&gt;
   &lt;/mapping&gt;
   &lt;lookup virtualNode='<emphasis role="bold">Dispatcher</emphasis>'
 host='*' protocol='rmi'/&gt;
  &lt;/deployment&gt;
  &lt;infrastructure&gt;
   &lt;processes&gt;
    &lt;processDefinition
 id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
     &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
    &lt;/processDefinition&gt;
   &lt;/processes&gt;
  &lt;/infrastructure&gt;
 &lt;/ProActiveDescriptor&gt;
</screen></para>
    </example>

    <para>This file is read when addind a C3DUser. Two VirtualNodes are
    defined <emphasis role="bold">User</emphasis> which is mapped to the jvm
    running the main(), whose acquisition method is performed by looking up
    the RMIRegistry and <emphasis role="bold">Dispatcher</emphasis> in the
    <emphasis role="bold">virtualNodesAcquisition</emphasis> part which will
    be the result of a lookup in the RMIRegistry of a host to be specified at
    runtime.</para>
  </sect1>

  <sect1 id="Descriptor_html_infrastructure">
    <title id="DESCRIPTOR_Infrastructure_and_processes">Infrastructure and
    processes</title>

    <para>In the previous example, all defined JVMs will be created using
    <emphasis role="bold">jvmProcess</emphasis> process. This name is abstract
    like the other ones, it means that it can be changed. This process is
    totally defined in the <emphasis role="bold">infrastructure</emphasis>
    part. Of course the process name in the creation part must point at an
    existing defined process in the <emphasis
    role="bold">infrastructure</emphasis> part. For instance if the name in
    the creation tag is <emphasis role="bold">localJVM</emphasis>, there must
    be a process defined in the <emphasis
    role="bold">infrastructure</emphasis> with the id <emphasis
    role="bold">localJVM</emphasis></para>

    <sect2>
      <title>Local JVMs</title>

      <indexterm>
        <primary>LocalJVM</primary>
      </indexterm>

      <para>As said before, all processes are defined in the <emphasis
      role="bold">infrastructure</emphasis> part, under the <emphasis
      role="bold">processes</emphasis> tag. In the previous example, the
      defined process <emphasis role="bold">jvmProcess</emphasis> will create
      local JVMs. The class attribute defines the class to instantiate in
      order to create the process. ProActive library provides one class to
      instantiate in order to create processes that will launch local JVMs:
      <literal>org.objectweb.proactive.core.process.JVMNodeProcess</literal></para>

      <screen> &lt;infrastructure&gt;                          
  &lt;processes&gt;
   &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
    &lt;<emphasis role="bold">jvmProcess</emphasis> class='org.objectweb.proactive.core.process.JVMNodeProcesss'&gt;
     &lt;classpath&gt;
      &lt;absolutePath
 value='/home/ProActive/classes'/&gt;
      &lt;absolutePath
 value='/home/ProActive/lib/bcel.jar'/&gt;
      &lt;absolutePath
 value='/home/ProActive/lib/asm.jar'/&gt;
      &lt;absolutePath
 value='/home/ProActive/lib/jini-core.jar'/&gt;
      &lt;absolutePath
 value='/home/ProActive/lib/jini-ext.jar'/&gt;
      &lt;absolutePath
 value='/home/ProActive/lib/reggie.jar'/&gt;
     &lt;/classpath&gt;
     &lt;javaPath&gt;
      &lt;absolutePath
 value='/usr/local/jdk1.4.0/bin/java'/&gt;
     &lt;/javaPath&gt;
     &lt;policyFile&gt;
      &lt;absolutePath
 value='/home/ProActive/scripts/proactive.java.policy'/&gt;
     &lt;/policyFile&gt;
     &lt;log4jpropertiesFile&gt;
      &lt;relativePath origin='user.home'
 value='ProActive/scripts/proactive-log4j'/&gt;
     &lt;/log4jpropertiesFile&gt;
     &lt;ProActiveUserPropertiesFile&gt;
      &lt;absolutePath
 value='/home/config.xml'/&gt;
     &lt;/ProActiveUserPropertiesFile&gt;
     &lt;jvmParameters&gt;
      &lt;parameter
 value='-Djava.library.path=/home1/fabrice/workProActive/ProActive/lib'/&gt;
      &lt;parameter
 value='-Dsun.boot.library.path=/home1/fabrice/workProActive/ProActive/lib'/&gt;
      &lt;parameter value=-Xms512
 -Xmx512'/&gt;
     &lt;/jvmParameters&gt;
    &lt;/<emphasis role="bold">jvmProcess</emphasis>&gt;
   &lt;/processDefinition&gt;
  &lt;/processes&gt;
 &lt;/infrastructure&gt;
</screen>

      <indexterm>
        <primary>CLASSPATH</primary>

        <secondary>deployment descriptor</secondary>
      </indexterm>

      <para>As shown in the example above, <emphasis
      role="bold">ProActive</emphasis> provides the ability to define or
      change the <emphasis role="bold">classpath</emphasis> environment
      variable, the <emphasis role="bold">java path</emphasis>, the <emphasis
      role="bold">policy file path</emphasis>, the <emphasis role="bold">log4j
      properties file path</emphasis>, the <emphasis role="bold">ProActive
      properties file path</emphasis> (see <xref linkend="Configuration" />
      for more details) and also to pass <emphasis
      role="bold">parameters</emphasis> to the JVM to be created. <emphasis
      role="bold">Note that parameters to be passed here are related to the
      jvm in opposition to properties given in the configuration file (see
      <xref linkend="Configuration" />), which is more focused on ProActive or
      application behaviour. In fact parameters given here will be part of the
      java command to create other jvms, whereas properties given in the
      config file will be loaded once the jvm is created.</emphasis></para>

      <para>If not specified, there is a default value (except for the
      jvmParameters element) for each of these variables. In the first example
      of this section, just the <emphasis role="bold">Id</emphasis> of the
      process, and the <emphasis role="bold">class</emphasis> to instantiate
      are defined. You might want to define the <emphasis
      role="bold">classpath</emphasis> or <emphasis role="bold">java
      path</emphasis> or <emphasis role="bold">policyfile path</emphasis>,
      etc, when creating remote JVMs(discussed later) if the home directory is
      not the same on your machine and on the machine where you want to create
      the JVM or for instance if you want to interact with <emphasis
      role="bold">Windows OS</emphasis> if you work on Linux and vice versa.
      As shown in the example <emphasis role="bold">paths</emphasis> to files
      can be either <emphasis role="bold">absolute</emphasis> or <emphasis
      role="bold">relative</emphasis>. If relative, an origin must be
      provided, it can be <emphasis role="bold">user.home</emphasis> or
      <emphasis role="bold">user.dir</emphasis> or <emphasis
      role="bold">user.classpath</emphasis> and it is resolved <emphasis
      role="bold">locally</emphasis>, i.e on the jvm reading the descriptor
      and not on the remote jvm that is going to be created.</para>

      <para>As mentionned in the configuration file (see <xref
      linkend="Configuration" />), if the &lt;ProActiveUserPropertiesFile&gt;
      is not defined for remote jvms, they will load a default one once
      created.</para>

      <para>Even if not shown in this example, a specific tag is provided for
      XbootClasspath option under the form</para>

      <screen> &lt;bootclasspath&gt;                          
  &lt;relativePath origin='user.home'
 value='/IOFAb/Ibis/'/&gt;
  &lt;relativePath origin='user.home'
 value='/IOFAb/classlibs/jdk'/&gt;
 &lt;/bootclasspath&gt;
</screen>
    </sect2>

    <sect2>
      <title>Remote JVMs</title>

      <para>With XML Deployment Descriptor, <emphasis
      role="bold">ProActive</emphasis> provides the ability to create remote
      Nodes (remote JVMs). You can specify in the descriptor if you want to
      access the remote host with <emphasis role="bold">rsh</emphasis>,
      <emphasis role="bold">ssh</emphasis>, <emphasis
      role="bold">rlogin</emphasis>, <emphasis role="bold">lsf</emphasis>,
      <emphasis role="bold">pbs</emphasis>, <emphasis
      role="bold">oar</emphasis>, <emphasis role="bold">prun</emphasis>,
      <emphasis role="bold">globus</emphasis>, <emphasis
      role="bold">unicore</emphasis>, <emphasis role="bold">arc
      (nordugrid)</emphasis>, <emphasis role="bold">glite</emphasis>. How to
      use these protocols is explained in the following examples. Just remind
      that you can also combine these protocols.The principle of combination
      is fairly simple, you can imagine for instance that you will log on a
      remote cluster frontend with <emphasis role="bold">ssh</emphasis>, then
      use <emphasis role="bold">pbs</emphasis> to book nodes and to create
      <emphasis role="bold">jvms</emphasis> on each. You will also notice that
      there is at least one combination for each remote protocol. Indeed each
      remote protocol <emphasis role="bold">must</emphasis> have a pointer
      either on another remote protocol or on a <emphasis
      role="bold">jvmProcess</emphasis> to create a jvm(discussed
      previoulsy).</para>

      <!-- This paragraph only appears in the html version  -->

      <para os="html">You can find <ulink url="../examples/">here</ulink>
      several examples of supported protocols and useful combinations.</para>

      <!-- This paragraph only appears in the pdfversion  -->

      <para os="pdf">You can find in <xref linkend="xmlFileSrc" /> several
      examples of supported protocols and useful combinations.</para>

      <para><emphasis role="bold">Note that it is mandatory for using all
      these features, that ProActive is installed on each host, of course on
      the local host as well as on each host where you want to create
      Nodes</emphasis></para>

      <itemizedlist>
        <listitem>
          <para>RSH</para>

          <para><screen>  ...........................                                
 &lt;jvm name='<emphasis role="bold">jvm1</emphasis>'&gt;
  &lt;creation&gt;
   &lt;processReference
 refid='<emphasis role="bold">rshProcess</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 .................................
 &lt;processes&gt;
  &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
   &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">rshProcess</emphasis>'&gt;
   &lt;rshProcess
 class='org.objectweb.proactive.core.process.rsh.RSHProcess'
 hostname='sea.inria.fr'&gt;
    &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
   &lt;/rshProcess&gt;
  &lt;/processDefinition&gt;
 &lt;/processes&gt;
</screen> For the <emphasis role="bold">Jvm2</emphasis> the creation process
          is <emphasis role="bold">rshProcess</emphasis>(still an abstract
          name), which is defined in the <emphasis
          role="bold">infrastructure</emphasis> section. To define this
          process you have to give the class to instantiate to create the
          <emphasis role="bold">rsh</emphasis> process. <emphasis
          role="bold">ProActive</emphasis> provides
          <literal>org.objectweb.proactive.core.process.rsh.RSHProcess</literal>
          to create <emphasis role="bold">rsh</emphasis> process. You must
          give the remote host name to log on with rsh. You can define as well
          <literal>username='toto'</literal> if you plan to use rsh with
          <emphasis role="bold">-l option</emphasis>. As said before this
          <emphasis role="bold">rsh</emphasis> process <emphasis
          role="bold">must</emphasis> reference a local process, and in the
          example, it references the process defined with the id <emphasis
          role="bold">jvmProcess</emphasis>. It means that once logged on
          sea.inria.fr with rsh, a local JVM will be launched, ie a ProActive
          node will be created on sea.inria.fr thanks to the process defined
          by <emphasis role="bold">jvmProcess</emphasis>.</para>

          <para>Check <xref linkend="examples/RSH_Example.xml"
          role="xmlFileSrc" /> for a complete rsh deployment example.</para>
        </listitem>

        <listitem>
          <para>RLOGIN</para>

          <para><screen> ...........................                                
 &lt;jvm name='<emphasis role="bold">jvm1</emphasis>'&gt;
  &lt;creation&gt;
   &lt;processReference
 refid='<emphasis role="bold">rloginProcess</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 .................................
 &lt;processes&gt;
  &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
   &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">rloginProcess</emphasis>'&gt;
   &lt;rloginProcess
 class='org.objectweb.proactive.core.process.rlogin.RLoginProcess'
 hostname='sea.inria.fr'&gt;
    &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
   &lt;/rloginProcess&gt;
  &lt;/processDefinition&gt;
 &lt;/processes&gt;
</screen> You can use <emphasis role="bold">rlogin</emphasis> in the same way
          that you would use <emphasis role="bold">rsh</emphasis></para>
        </listitem>

        <listitem>
          <para>SSH</para>

          <para><screen> ...........................                                
 &lt;jvm name='<emphasis role="bold">jvm1</emphasis>'&gt;
  &lt;creation&gt;
   &lt;processReference
 refid='<emphasis role="bold">sshProcess</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 .................................
 &lt;processes&gt;
  &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
   &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">sshProcess</emphasis>'&gt;
   &lt;sshProcess
 class='org.objectweb.proactive.core.process.ssh.SSHProcess'
 hostname='sea.inria.fr'&gt;
    &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
   &lt;/sshProcess&gt;
  &lt;/processDefinition&gt;
 &lt;/processes&gt;
</screen> <emphasis role="bold">ProActive</emphasis> provides
          <literal>org.objectweb.proactive.core.process.ssh.SSHProcess</literal>
          to create <emphasis role="bold">ssh</emphasis> process.</para>

          <para>In order to use ssh to log on a remote host, you must perform
          some actions. First you need to copy your public key (located in
          identity.pub under ~/.ssh on your local machine) in the
          authorized_keys(located under ~/.ssh) file of the remote host. Then
          to avoid interactivity, you will have to launch on the local host
          the ssh-agent command: <emphasis role="bold">ssh-agent
          $SHELL</emphasis>, this command can be put in your .xsession file,
          in order to run it automatically when logging on your station. Then
          launching <emphasis role="bold">ssh-add</emphasis> command to add
          your identity. Running this command will ask you to enter your
          <emphasis role="bold">passphrase</emphasis>, it is the one you
          provided when asking for an ssh key pair.</para>

          <para>Note also that if the generated key pair is not encrypted (no
          passphrase), you do not need to run neither the ssh-agent, nor the
          ssh-add command. Indeed it is sufficient when using non encrypted
          private key, to only copy the public key on the remote host (as
          mentionned above) in order to get logged automatically on the remote
          host.</para>

          <para>These steps must be performed <emphasis
          role="bold">before</emphasis> running any ProActive application
          using <emphasis role="bold">ssh</emphasis> protocol. If you are not
          familiar with ssh, see <ulink
          url="http://www.openssh.org">openSSH</ulink></para>

          <para>Check <xref linkend="examples/SSH_Example.xml"
          role="xmlFileSrc" /> for a complete ssh deployment example.</para>
        </listitem>

        <listitem id="Descriptor_html_processlist" xreflabel="Process list">
          <para>Process list</para>

          <para>ProActive provides a way to define a list of processes for
          <emphasis role="bold">RSH, SSH, RLOGIN</emphasis> protocols. Using
          <emphasis role="bold">processList</emphasis> or <emphasis
          role="bold">processListbyHost</emphasis> elements avoids having a
          long deployment file when many machines with similar names are going
          to be connected with protocols mentionned before. The first example
          below shows how to use <emphasis role="bold">processList</emphasis>
          tag, the second how to use <emphasis
          role="bold">processListbyHost</emphasis>.</para>

          <screen> ...........................                              
 &lt;jvm name='<emphasis role="bold">jvm1</emphasis>'&gt;
  &lt;creation&gt;
   &lt;processReference
 refid='<emphasis role="bold">processlist</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 .................................
 &lt;processes&gt;
  &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
   &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">processlist</emphasis>'&gt;
   &lt;processList
 class='org.objectweb.proactive.core.process.ssh.SSHProcessList'
 fixedName='node-' list='[0-100;2]^[10,20]'
 padding='3' domain='sophia.grid5000.fr'&gt;
    &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
   &lt;/processList&gt;
  &lt;/processDefinition&gt;
 &lt;/processes&gt;
</screen>

          <para>When using <emphasis role="bold">processList tag</emphasis>,
          the <emphasis role="bold">class</emphasis> attribute can take 3
          values: <itemizedlist>
              <listitem>
                <para>org.objectweb.proactive.core.process.ssh.SSHProcessList
                (see <xref linkend="core/process/ssh/SSHProcessList.java"
                role="javaFileSrc" />),</para>
              </listitem>

              <listitem>
                <para>org.objectweb.proactive.core.process.rsh.RSHProcessList
                (see <xref linkend="core/process/rsh/RSHProcessList.java"
                role="javaFileSrc" />),</para>
              </listitem>

              <listitem>
                <para>org.objectweb.proactive.core.process.rlogin.RLoginProcessList
                (see <xref
                linkend="core/process/rlogin/RLoginProcessList.java"
                role="javaFileSrc" />),</para>
              </listitem>
            </itemizedlist> according to the protocol being used is ssh, rsh
          or rlogin. The <emphasis role="bold">fixedName</emphasis> attribute
          is mandatory and represents the fixed part shared by all machine's
          names. The <emphasis role="bold">list</emphasis> attribute is also
          mandatory and can take several forms: <emphasis
          role="bold">[m-n]</emphasis> means from m to n with a step 1,
          <emphasis role="bold">[m-n;k]</emphasis> means from m to n with a
          step k (m, m+k, m+2k, ....), <emphasis
          role="bold">[m-n]^[x,y]</emphasis> means from m to n exluding x and
          y, <emphasis role="bold">[m-n]^[x,y-z]</emphasis> means from m to n
          exluding x and values from y to z, <emphasis
          role="bold">[m-n;k]^[x,y]</emphasis> same as before except that the
          step is k. The <emphasis role="bold">padding</emphasis> attribute is
          optional (default is 1) and represents the number of digits. Finally
          the <emphasis role="bold">domain</emphasis> attribute is mandatory
          and represents the last part shared by all machine's names. So in
          the exemple above, a jvm is going to be created using ssh on
          machines: node000.sophia.grid5000.fr,
          node002.sophia.grid5000.fr,..., node098.sophia.grid5000.fr,
          node100.sophia.grid5000.fr (note that step is 2) excluding machines:
          node010.sophia.grid5000.fr and node020.sophia.grid5000.fr.</para>

          <screen> ...........................                              
 &lt;jvm name='<emphasis role="bold">jvm1</emphasis>'&gt;
  &lt;creation&gt;
   &lt;processReference
 refid='<emphasis role="bold">processlist</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 .................................
 &lt;processes&gt;
  &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
   &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">processlist</emphasis>'&gt;
   &lt;processListbyHost
 class='org.objectweb.proactive.core.process.ssh.SSHProcessList'
 hostlist='crusoe waha nahuel' domain='inria.fr'&gt;
    &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
   &lt;/processListbyHost&gt;
  &lt;/processDefinition&gt;
 &lt;/processes&gt;
</screen>

          <para>Using <emphasis role="bold">processListbyHost</emphasis>
          element allows to give a hostlist separated with a whitespace. The
          class attribute is defined as described in the processList tag. The
          <emphasis role="bold">domain</emphasis> attribute is optional since
          the complete hostname can also be provided in the hostlist
          attribute. In the example, a jvm is going to be created using ssh on
          crusoe.inria.fr, waha.inria.fr, nahuel.inria.fr.</para>

          <para>Check <xref linkend="examples/SSHList_example.xml"
          role="xmlFileSrc" /> or <xref
          linkend="examples/SSHListbyHost_Example.xml" role="xmlFileSrc" />
          for list examples.</para>
        </listitem>

        <listitem>
          <para>LSF</para>

          <indexterm>
            <primary>Cluster</primary>
          </indexterm>

          <para>This protocol is used to create Nodes(JVMs) on a cluster.
          <emphasis role="bold">ProActive</emphasis> provides
          <literal>org.objectweb.proactive.core.process.lsf.LSFBSubProcess</literal>
          to create <emphasis role="bold">bsub</emphasis> process.</para>

          <para>In this part we assume that you want to submit a job from a
          machine which is not the cluster frontend. As described before, you
          can combine protocols. In this case , you will have to define a
          process to log on the front-end of the cluster(<emphasis
          role="bold">rlogin</emphasis> if your machine is on the same LAN
          than the cluster front-end, else <emphasis
          role="bold">ssh</emphasis> (Remember that to use <emphasis
          role="bold">ssh</emphasis> you will have to run some commands as
          explained above).</para>

          <screen> &lt;jvm name='<emphasis role="bold">Jvm2</emphasis>'&gt;                              
  &lt;creation&gt;
  &lt;processReference refid='<emphasis role="bold">sshProcess</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 ...................................................
 &lt;processes&gt;
  &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
   &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">bsubInriaCluster</emphasis>'&gt;
   &lt;bsubProcess
 class='org.objectweb.proactive.core.process.lsf.LSFBSubProcess'&gt;
    &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
    &lt;bsubOption&gt;
     &lt;hostlist&gt;cluster_machine1
 cluster_machine2&lt;hostlist/&gt;
     &lt;processor&gt;6&lt;/processor&gt;
     &lt;scriptPath&gt;
      &lt;absolutePath
 value='/home/ProActive/scripts/cluster/startRuntime.sh'/&gt;
     &lt;/scriptPath&gt;
    &lt;/bsubOption&gt;
   &lt;/bsubProcess&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">sshProcess</emphasis>'&gt;
   &lt;sshProcess
 class='org.objectweb.proactive.core.process.ssh.SSHProcess'
 hostname='sea.inria.fr'&gt;
    &lt;processReference
 refid='<emphasis role="bold">bsubInriaCluster</emphasis>'/&gt;
   &lt;/sshProcess&gt;
  &lt;/processDefinition&gt;
 &lt;/processes&gt;
</screen>

          <para>In this example, the JVM called <emphasis
          role="bold">Jvm2</emphasis> will be created using <emphasis
          role="bold">ssh</emphasis> to log on the cluster front end. Then a
          <emphasis role="bold">bsub</emphasis> command will be generated
          thanks to the process defined by <emphasis
          role="bold">bsubInriaCluster</emphasis>. This <emphasis
          role="bold">bsub</emphasis> command will create Nodes on several
          cluster machines, since <emphasis
          role="bold">bsubInriaCluster</emphasis> references the <emphasis
          role="bold">jvmProcess</emphasis> defined process. All tags defined
          under &lt;<emphasis role="bold">bsubOption</emphasis>&gt; are not
          mandatory, but they can be very usefull. The &lt;hostlist&gt; tag
          defines possible candidates in the job attribution, if not set the
          job will be allocated among all cluster's machines. The
          &lt;processor&gt; tag defines the number of processor requested, if
          not set, one processor is requested. The &lt;resourceRequirement&gt;
          tag defines the expected number of processors per machine. For
          instance &lt;resourceRequirement value='span[ptile=2]'/&gt; ensures
          that 2 processors per machines will be used, whereas
          value='span[ptile=1]' forces that LSF allocates only only one
          processor per machine. It represents the <emphasis
          role="bold">-R</emphasis> option of LSF. At last &lt;scriptPath&gt;
          defines the path on the cluster front end of the script
          startRuntime.sh which is necessary to run ProActive on a cluster.
          This script is located under Proactive/scripts/unix/cluster. If not
          set the default location is set as
          ~/Proactive/scripts/unix/cluster.</para>

          <para>It is exactly the same with <emphasis
          role="bold">rlogin</emphasis> instead of <emphasis
          role="bold">ssh.</emphasis></para>

          <para>If you want to submit the job directly from the cluster entry
          point, define only the <emphasis role="bold">bsubProcess</emphasis>,
          like in the above example and skip the ssh definition.</para>

          <screen> &lt;jvm name='<emphasis role="bold">Jvm2</emphasis>'&gt;                              
  &lt;creation&gt;
  &lt;processReference refid='<emphasis role="bold">bsubInriaCluster</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 ...................................................
 &lt;processes&gt;
  &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
   &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">bsubInriaCluster</emphasis>'&gt;
   &lt;bsubProcess
 class='org.objectweb.proactive.core.process.lsf.LSFBSubProcess'
 interactive='true' queue='short'&gt;
    &lt;processReference refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
    &lt;bsubOption&gt;
     &lt;hostlist&gt;cluster_machine1
 cluster_machine2&lt;hostlist/&gt;
     &lt;processor&gt;6&lt;/processor&gt;
     &lt;scriptPath&gt;
      &lt;absolutePath value='/home/ProActive/scripts/unix/cluster/startRuntime.sh'/&gt;
     &lt;/scriptPath&gt;
    &lt;/bsubOption&gt;
   &lt;/bsubProcess&gt;
  &lt;/processDefinition&gt;
 &lt;/processes&gt;</screen>

          <para>Note that in the example above two attributes: <emphasis
          role="bold">interactive</emphasis> and <emphasis
          role="bold">queue</emphasis> appear. They are optional, and have a
          default value: respectively <emphasis role="bold">false</emphasis>
          and <emphasis role="bold">normal</emphasis>. They represent option
          in the bsub command: interactive mode, and the name of the
          queue.</para>

          <para>Check also <xref linkend="examples/SSH_LSF_Example.xml"
          role="xmlFileSrc" /> .</para>
        </listitem>

        <listitem>
          <para>PBS</para>

          <indexterm>
            <primary>Cluster</primary>
          </indexterm>

          <para>This protocol is used to create jobs on cluster managed by
          PBS, PBSPro or Torque. ProActive provides
          <literal>org.objectweb.proactive.core.process.pbs.PBSBSubProcess</literal>
          to create <emphasis role="bold">pbs</emphasis> processes. As
          explained for LSF you can combine protocols in order for instance to
          log on the cluster's frontal with ssh, then to create nodes using
          PBS, or you can also use only PBS without ssh if you are already
          logged on the frontend. Example below shows how to combine an ssh
          process to log on the cluster, then a PBS process that references a
          <emphasis role="bold">jvmProcess</emphasis> in order to create nodes
          on processors requested by PBS.</para>

          <screen> &lt;jvm name='<emphasis role="bold">Jvm2</emphasis>'&gt;                              
  &lt;creation&gt;
  &lt;processReference refid='<emphasis role="bold">sshProcess</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 ...................................................
 &lt;processes&gt;
  &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
   &lt;jvmProcess class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">pbsCluster</emphasis>'&gt;
   &lt;pbsProcess
 class='org.objectweb.proactive.core.process.pbs.PBSSubProcess'&gt;
    &lt;processReference refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
    &lt;pbsOption&gt;
     &lt;hostsNumber&gt;4&lt;/hostsNumber&gt;
     &lt;processorPerNode&gt;1&lt;/processorPerNode&gt;
     &lt;bookingDuration&gt;00:15:00&lt;/bookingDuration&gt;
     &lt;outputFile&gt;/home1/rquilici/out.log&lt;/outputFile&gt;
     &lt;scriptPath&gt;
      &lt;absolutePath value='/home/ProActive/scripts/unix/cluster/pbsStartRuntime.sh'/&gt;
     &lt;/scriptPath&gt;
    &lt;/pbsOption&gt;
   &lt;/pbsProcess&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">sshProcess</emphasis>'&gt;
   &lt;sshProcess
 class='org.objectweb.proactive.core.process.ssh.SSHProcess'
 hostname='frontend'&gt;
    &lt;processReference refid='<emphasis role="bold">pbsCluster</emphasis>'/&gt;
   &lt;/sshProcess&gt;
  &lt;/processDefinition&gt;
 &lt;/processes&gt;</screen>

          <para>Note that not all options are listed here, and some options
          mentionned in the example are optionnal: <emphasis
          role="bold">hostsNumber</emphasis> represents the number of host
          requested using pbs(default is 1), <emphasis
          role="bold">processorPerNode</emphasis> represents the number of
          processor per hosts requested(1 or 2, default is 1), <emphasis
          role="bold">bookingDuration</emphasis> represents the duration of
          the job(default is 1 minute), <emphasis
          role="bold">outputFile</emphasis> represents the file where to put
          the ouput of the job(default is specified by pbs), <emphasis
          role="bold">scriptPath</emphasis> represents the location on the
          frontend_host of the script pbsStartRuntime.sh(default is
          /user.home/ProActive/scripts/unix/cluster/pbsStartRuntime.sh).</para>

          <para>Check also <xref linkend="examples/SSH_PBS_Example.xml"
          role="xmlFileSrc" />.</para>
        </listitem>

        <listitem>
          <para>Sun Grid Engine</para>

          <indexterm>
            <primary>Cluster</primary>
          </indexterm>

          <para>This protocol is used to create jobs on cluster managed by Sun
          Grid Engine. ProActive provides
          <literal>org.objectweb.proactive.core.process.gridengine.GridEngineSubProcess</literal>
          to create <emphasis role="bold">grid engine</emphasis> processes. As
          explained above you can combine protocols in order for instance to
          log on the cluster's frontal with ssh, then to create nodes using
          SGE, or you can also use only SGE without ssh if you are already
          logged on the frontend. Example below shows how to combine an ssh
          process to log on the cluster, then a SGE process that references a
          <emphasis role="bold">jvmProcess</emphasis> in order to create nodes
          on processors requested by SGE.</para>

          <screen> &lt;jvm name='<emphasis role="bold">Jvm2</emphasis>'&gt;                              
  &lt;creation&gt;
  &lt;processReference refid='<emphasis role="bold">sshProcess</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 ...................................................
 &lt;processes&gt;
  &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
   &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">sgeCluster</emphasis>'&gt;
   &lt;gridengineProcess
 class='org.objectweb.proactive.core.process.gridengine.GridEngineSubProcess'&gt;
    &lt;processReference refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
    &lt;gridEngineOption&gt;
     &lt;hostsNumber&gt;4&lt;/hostsNumber&gt;
     &lt;bookingDuration&gt;00:15:00&lt;/bookingDuration&gt;
     &lt;scriptPath&gt;
      &lt;absolutePath value='/home/ProActive/scripts/unix/cluster/gridEngineStartRuntime.sh'/&gt;
     &lt;/scriptPath&gt;
     &lt;parallelEnvironment&gt;mpi&lt;/parallelEnvironment&gt;
    &lt;/gridEngineOption&gt;
   &lt;/gridengineProcess&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">sshProcess</emphasis>'&gt;
   &lt;sshProcess
 class='org.objectweb.proactive.core.process.ssh.SSHProcess'
 hostname='frontend'&gt;
    &lt;processReference
 refid='<emphasis role="bold">sgeCluster</emphasis>'/&gt;
   &lt;/sshProcess&gt;
  &lt;/processDefinition&gt;
 &lt;/processes&gt;</screen>

          <para>As mentionned previously, many options exist, and correspond
          to the main options specified in an SGE system. <emphasis
          role="bold">ScriptPath</emphasis> represents the location on the
          frontend_host of the script gridEngineStartRuntime.sh (default is
          /user.home/ProActive/scripts/unix/cluster/gridEngineStartRuntime.sh).</para>

          <para>Check also <xref linkend="examples/SSH_SGE_Example.xml"
          role="xmlFileSrc" />.</para>
        </listitem>

        <listitem>
          <para>OAR:</para>

          <indexterm>
            <primary>Cluster</primary>
          </indexterm>

          <para>OAR is a cluster protocol developed at INRIA Alpes and used on
          <ulink url="http://www.grid5000.fr">Grid5000</ulink>. ProActive
          provides
          <literal>org.objectweb.proactive.core.process.oar.OARSubProcess</literal>
          to use such protocol.As explained above you can combine protocols in
          order for instance to log on the cluster's frontal with ssh, then to
          create nodes using OAR, or you can also use only OAR without ssh if
          you are already logged on the frontend. Example below shows how to
          combine an ssh process to log on the cluster, then an OAR process
          that references a <emphasis role="bold">jvmProcess</emphasis> in
          order to create nodes on processors requested by OAR.</para>

          <screen> &lt;jvm name='<emphasis role="bold">Jvm2</emphasis>'&gt;                              
  &lt;creation&gt;
  &lt;processReference refid='<emphasis role="bold">sshProcess</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 ...................................................
 &lt;processes&gt;
  &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
   &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">oarCluster</emphasis>'&gt;
   &lt;oarProcess
 class='org.objectweb.proactive.core.process.oar.OARSubProcess'&gt;
    &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
    &lt;oarOption&gt;
     &lt;resources&gt;node=2,weight=2&lt;/resources&gt;
     &lt;scriptPath&gt;
      &lt;absolutePath value='/home/ProActive/scripts/unix/cluster/oarStartRuntime.sh'/&gt;
     &lt;/scriptPath&gt;
    &lt;/oarOption&gt;
   &lt;/oarProcess&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">sshProcess</emphasis>'&gt;
   &lt;sshProcess
 class='org.objectweb.proactive.core.process.ssh.SSHProcess'
 hostname='frontend'&gt;
    &lt;processReference
 refid='<emphasis role="bold">oarCluster</emphasis>'/&gt;
   &lt;/sshProcess&gt;
  &lt;/processDefinition&gt;
 &lt;/processes&gt;</screen>

          <para>As mentionned previously, many options exist, and correspond
          to the main options specified in an OAR system. <emphasis
          role="bold">ScriptPath</emphasis> represents the location on the
          frontend_host of the script oarStartRuntime.sh (default is
          /user.home/ProActive/scripts/unix/cluster/oarStartRuntime.sh).</para>

          <para>Check also <xref linkend="examples/SSH_OAR_Example.xml"
          role="xmlFileSrc" /> and <xref
          linkend="examples/SSH_OARGRID_Example.xml"
          role="xmlFileSrc" />.</para>
        </listitem>

        <listitem>
          <para>PRUN:</para>

          <indexterm>
            <primary>Cluster</primary>
          </indexterm>

          <para>PRUN is a cluster protocol developed at Amsterdam to manage
          their <ulink
          url="http://www.cs.vu.nl/das/prun/prun.1.html">cluster</ulink>.
          ProActive provides
          <literal>org.objectweb.proactive.core.process.prun.PrunSubProcess</literal>
          to use such protocol.</para>

          <para>Check also <xref linkend="examples/SSH_PRUN_Example.xml"
          role="xmlFileSrc" />.</para>
        </listitem>

        <listitem>
          <indexterm significance="preferred">
            <primary>Globus</primary>

            <secondary>XML Descriptor</secondary>
          </indexterm>

          <para>GLOBUS</para>

          <para>Like <emphasis role="bold">ssh</emphasis>, using <emphasis
          role="bold">globus</emphasis> requires some steps to be performed.
          In particular the <emphasis role="bold">java COG Kit</emphasis> (no
          need for the whole GT) must be installed on the machine that will
          originates the <emphasis role="bold">RSL</emphasis> request. See
          <ulink url="http://www.cogkit.org/">COG Kit Installation</ulink> for
          how to install the client kit. Then you have to initialize your
          proxy by running <emphasis role="bold">COG_INSTALLATION/bin
          /grid-proxy-init</emphasis>, you will be asked for a passphrase, it
          is the one you provided when requesting a user certificate at
          globus.org. Once these steps are performed you can run <emphasis
          role="bold">ProActive</emphasis> application using <emphasis
          role="bold">GRAM</emphasis> protocol.</para>

          <para><emphasis role="bold">ProActive</emphasis> provides
          <literal>org.objectweb.proactive.core.process.globus.GlobusProcess</literal>
          to create <emphasis role="bold">globus</emphasis> process.</para>

          <indexterm>
            <primary>Globus</primary>

            <secondary>XML Descriptor</secondary>

            <tertiary>GlobusProcess</tertiary>
          </indexterm>

          <screen> &lt;jvm name='<emphasis role="bold">Jvm2</emphasis>'&gt;                              
  &lt;creation&gt;
  &lt;processReference refid='<emphasis role="bold">globusProcess</emphasis>'/&gt;
  &lt;/creation&gt;
 &lt;/jvm&gt;
 ...................................................
 &lt;processes&gt;
  &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
   &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
  &lt;/processDefinition&gt;
  &lt;processDefinition id='<emphasis role="bold">globusProcess</emphasis>'&gt;
   &lt;globusProcess
 class='org.objectweb.proactive.core.process.globus.GlobusProcess'
 hostname='globus1.inria.fr'&gt;
    &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
    &lt;environment&gt;
     &lt;variable name='DISPLAY'
 value='machine_name0.0'/&gt;
    &lt;/environment&gt;
    &lt;globusOption&gt;
     &lt;count&gt;10&lt;/count&gt;
    &lt;/globusOption&gt;
   &lt;/globusProcess&gt;
  &lt;/processDefinition&gt;
 &lt;/processes&gt;</screen>

          <para>In this example, <emphasis role="bold">Jvm2</emphasis> will be
          created using <emphasis role="bold">GRAM</emphasis>. An <emphasis
          role="bold">RSL</emphasis> request will be generated with
          informations provided in the descriptor. For instance, the
          &lt;environment&gt; tag is not mandatory, but for the globus host to
          export the DISPLAY on your machine, you can define the value in the
          descriptor as well as other environment variable, except the
          classpath(or java path,...) which must be defined in the <emphasis
          role="bold">jvmProcess</emphasis> referenced by <emphasis
          role="bold">globusProcess</emphasis> as explained before.
          &lt;globusOption&gt; is neither manatory. Default value for
          &lt;count&gt; element is 1. It represents the number of processor
          requested.</para>

          <para>Check also <xref linkend="examples/Globus_Example.xml"
          role="xmlFileSrc" />.</para>
        </listitem>

        <listitem>
          <para>UNICORE:</para>

          <para>ProActive provides
          <literal>org.objectweb.proactive.core.process.unicore.UnicoreProcess</literal>
          to use such protocol.</para>

          <para>Check also <xref linkend="examples/Unicore_Example.xml"
          role="xmlFileSrc" />.</para>
        </listitem>

        <listitem>
          <para>ARC (NorduGrid):</para>

          <para>ProActive provides
          <literal>org.objectweb.proactive.core.process.nordugrid.NGProcess</literal>
          to use such protocol.</para>

          <para>To use ARC you will need to download the <ulink
          url="http://ftp.nordugrid.org/download/index.php">ARC
          Client</ulink></para>

          <para>Check also <xref linkend="examples/NorduGrid_Example.xml"
          role="xmlFileSrc" />.</para>
        </listitem>

        <listitem>
          <para>GLITE</para>

          <indexterm significance="preferred">
            <primary>GLITE</primary>

            <secondary>XML Descriptor</secondary>
          </indexterm>

          <para>ProActive provides
          <literal>org.objectweb.proactive.core.process.glite.GLiteProcess</literal>
          to use such protocol.</para>

          <para>Check also <xref linkend="examples/SSH_GLite_Example.xml"
          role="xmlFileSrc" />.</para>
        </listitem>

        <listitem>
          <para>MPI</para>

          <para>ProActive provides
          <literal>org.objectweb.proactive.core.process.mpi.MPIDependentProcess</literal>
          to use such protocol. You have to couple this process with the
          DependentListProcessDecorator explained below.</para>

          <para>Check also <xref linkend="examples/SSH_MPI_Example.xml"
          role="xmlFileSrc" />.</para>

          <para><screen>
&lt;processDefinition id='<emphasis role="bold">mpiProcess</emphasis>'&gt;
 &lt;mpiProcess class='<emphasis role="bold">org.objectweb.proactive.core.process.mpi.MPIDependentProcess</emphasis>' mpiFileName='my_mpi_program'&gt;
  &lt;commandPath value='/usr/bin/mpirun' /&gt;
  &lt;mpiOptions&gt;
    &lt;hostsNumber&gt;16&lt;/hostsNumber&gt;
    &lt;localRelativePath&gt;
      &lt;relativePath origin="user.home" value='/ProActive/scripts/unix' /&gt;
      &lt;/localRelativePath&gt;
      &lt;remoteAbsolutePath&gt;
       &lt;absolutePath value='/home/user' /&gt;
      &lt;/remoteAbsolutePath&gt;
     &lt;/mpiOptions&gt;
    &lt;/mpiProcess&gt;
   &lt;/processDefinition&gt;
   &lt;processDefinition id='<emphasis role="bold">dependentProcessSequence</emphasis>'&gt;
    &lt;dependentProcessSequence class='<emphasis role="bold">org.objectweb.proactive.core.process.DependentListProcessDecorator</emphasis>'&gt;
     &lt;processReference refid='<emphasis role="bold">pbsProcess</emphasis>' /&gt;
     &lt;processReference refid='<emphasis role="bold">mpiProcess</emphasis>' /&gt;
    &lt;/dependentProcessSequence&gt;
   &lt;/processDefinition&gt;
   &lt;processDefinition id='<emphasis role="bold">sshProcess</emphasis>'&gt;
    &lt;sshProcess class='<emphasis role="bold">org.objectweb.proactive.core.process.ssh.SSHProcess</emphasis>' hostname='frontend' &gt;
     &lt;processReference refid='<emphasis role="bold">dependentProcessSequence</emphasis>' /&gt;
    &lt;/sshProcess&gt;
   &lt;/processDefinition&gt;
</screen></para>

          <para><screen> &lt;?xml version='1.0'
 encoding='UTF-8'?&gt;                                
 &lt;ProActiveDescriptor
 xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
 xsi:noNamespaceSchemaLocation='DescriptorSchema.xsd'&gt;
 &lt;virtualNodesDefinition&gt;
  &lt;virtualNode name='<emphasis role="bold">PenguinNode</emphasis>'
 property='<emphasis role="bold">multiple</emphasis>'/&gt;
 &lt;virtualNodesDefinition/&gt;
 &lt;deployment&gt;
  &lt;mapping&gt;
   &lt;map virtualNode='<emphasis role="bold">PenguinNode</emphasis>'&gt;
    &lt;jvmSet&gt;
     &lt;vmName value='<emphasis role="bold">Jvm1</emphasis>'/&gt;
     &lt;vmName value='<emphasis role="bold">Jvm2</emphasis>'/&gt;
     &lt;vmName value='<emphasis role="bold">Jvm3</emphasis>'/&gt;
     &lt;vmName value='<emphasis role="bold">Jvm4</emphasis>'/&gt;
    &lt;/jvmSet&gt;
   &lt;/map&gt;
  &lt;/mapping&gt;
  &lt;jvms&gt;
   &lt;jvm name='<emphasis role="bold">Jvm1</emphasis>'&gt;
    &lt;creation&gt;
     &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
    &lt;/creation&gt;
   &lt;/jvm&gt;
   &lt;jvm name='<emphasis role="bold">Jvm2</emphasis>'&gt;
    &lt;creation&gt;
     &lt;processReference
 refid='<emphasis role="bold">jvmProcess</emphasis>'/&gt;
    &lt;/creation&gt;
   &lt;/jvm&gt;
   &lt;jvm name='<emphasis role="bold">Jvm3</emphasis>'&gt;
    &lt;creation&gt;
     &lt;processReference
 refid='<emphasis role="bold">sshInriaCluster</emphasis>'/&gt;
    &lt;/creation&gt;
   &lt;/jvm&gt;
   &lt;jvm name='<emphasis role="bold">Jvm4</emphasis>'&gt;
    &lt;creation&gt;
     &lt;processReference
 refid='<emphasis role="bold">globusProcess</emphasis>'/&gt;
    &lt;/creation&gt;
   &lt;/jvm&gt;
  &lt;/jvms&gt;
 &lt;/deployment&gt;
 &lt;infrastructure&gt;
  &lt;processes&gt;
   &lt;processDefinition id='<emphasis role="bold">jvmProcess</emphasis>'&gt;
    &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
   &lt;/processDefinition&gt;
   &lt;processDefinition id='<emphasis role="bold">jvmProcess1</emphasis>'&gt;
    &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'&gt;
     &lt;classpath&gt;
      &lt;relativePath origin='userHome'
 value='/ProActive/classes'/&gt;
      &lt;relativePath origin='userHome'
 value='/ProActive/lib/bcel.jar'/&gt;
      &lt;relativePath origin='userHome'
 value='/ProActive/lib/asm.jar'/&gt;
      &lt;relativePath origin='userHome'
 value='/ProActive/lib/jini-core.jar'/&gt;
      &lt;relativePath origin='userHome'
 value='/ProActive/lib/jini-ext.jar'/&gt;
      &lt;relativePath origin='userHome'
 value='/ProActive/lib/reggie.jar'/&gt;
 .............
     &lt;/classpath&gt;
     &lt;javaPath&gt;
      &lt;absolutePath
 value='/usr/local/jdk1.4.0/bin/java'/&gt;
     &lt;/javaPath&gt;
      &lt;policyFile&gt;
      &lt;absolutePath
 value='/home/ProActive/scripts/proactive.java.policy'/&gt;
     &lt;/policyFile&gt;
     &lt;log4jpropertiesFile&gt;
      &lt;absolutePath
 value='/home/ProActive/scripts/proactive-log4j'/&gt;
     &lt;/log4jpropertiesFile&gt;
     &lt;ProActiveUserPropertiesFile&gt;
      &lt;absolutePath
 value='/home/config.xml'/&gt;
     &lt;/ProActiveUserPropertiesFile&gt;
    &lt;/jvmProcess&gt;
   &lt;/processDefinition&gt;
   &lt;processDefinition
 id='<emphasis role="bold">bsubInriaCluster</emphasis>'&gt;
    &lt;bsubProcess
 class='org.objectweb.proactive.core.process.lsf.LSFBSubProcess'&gt;
     &lt;processReference
 refid='<emphasis role="bold">jvmProcess1</emphasis>'/&gt;
     &lt;bsubOption&gt;
      &lt;hostlist&gt;cluster_group1
 cluster_group2&lt;hostlist/&gt;
      &lt;processor&gt;4&lt;/processor&gt;
      &lt;resourceRequirement
 value='span[ptile=2]'/&gt;
      &lt;scriptPath&gt;
       &lt;absolutePath
 value='/home/ProActive/scripts/unix/cluster/startRuntime.sh'/&gt;
      &lt;/scriptPath&gt;
     &lt;/bsubOption&gt;
    &lt;/bsubProcess&gt;
   &lt;/processDefinition&gt;
   &lt;processDefinition
 id='<emphasis role="bold">sshInriaCluster</emphasis>'&gt;
    &lt;sshProcess
 class='org.objectweb.proactive.core.process.ssh.SSHProcess'
 hostname='sea.inria.fr'&gt;
     &lt;processReference
 refid='<emphasis role="bold">bsubInriaCluster</emphasis>'/&gt;
    &lt;/sshProcess&gt;
   &lt;/processDefinition&gt;
   &lt;processDefinition
 id='<emphasis role="bold">globusProcess</emphasis>'&gt;
    &lt;globusProcess
 class='org.objectweb.proactive.core.process.globus.GlobusProcess'
 hostname='cluster.inria.fr'&gt;
     &lt;processReference
 refid='<emphasis role="bold">jvmProcess1</emphasis>'/&gt;
     &lt;environment&gt;
      &lt;variable name='DISPLAY'
 value='machine_name0.0'/&gt;
     &lt;/environment&gt;
     &lt;globusOption&gt;
      &lt;count&gt;10&lt;/count&gt;
     &lt;/globusOption&gt;
    &lt;/globusProcess&gt;
   &lt;/processDefinition&gt;
  &lt;/processes&gt;
 &lt;/infrastructure&gt;
 &lt;/ProActiveDescriptor&gt;</screen></para>
        </listitem>
      </itemizedlist>

      <para>This xml deployment descriptor shows how to deploy the Penguin
      application on several places. Two Nodes will be created locally. We can
      see that with the definition of <emphasis role="bold">Jvm1</emphasis>
      and <emphasis role="bold">Jvm2</emphasis>. These JVMs will be created
      locally since they reference directly the process defined by <emphasis
      role="bold">jvmProcess</emphasis>. <emphasis role="bold">Jvm3</emphasis>
      will be created on the cluster using <emphasis
      role="bold">ssh</emphasis> to log on sea.inria.fr (cluster entry
      point)and then bsub to request processors and to create jvms on each.
      Here, two nodes will be created on machines that belong to <emphasis
      role="bold">cluster_group1 or cluster_group2</emphasis> since processor
      tag is set to 2, and the hoslist tag gives cluster_group1 cluster_group2
      as candidates. At Last <emphasis role="bold">Jvm4</emphasis> will be
      created using globus It will access cluster.inria.fr and request 10
      processors. We can notice that two local processes were defined, the
      reason is that the first one <emphasis role="bold">jvmProcess</emphasis>
      will use default value for the classpath, java path and policyfile path,
      whereas for the second one <emphasis role="bold">jvmProcess1</emphasis>
      , we need to define these value, since the home directory is different
      between the local machine, and globus and the cluster(home dir is the
      same on globus machines and on the cluster, that is why both processes
      reference the same local process: <emphasis
      role="bold">jvmProcess1</emphasis>).</para>

      <para>Even if quite a lot of things can be configured in the xml files,
      sometimes you will have to perform additional steps to get everything
      working properly, it is the case when using ssh, or globus as seen
      before. In this example, DISPLAY variable is defined for the globus
      process, that means that we want the penguin icon to appears on the
      local machine, be carefull to authorize your X server to display such
      icons by running the following command before launching the application:
      xhost +cluster.inria.fr. On the cluster side you need to create under
      ~/.ssh a file called environment where you define the DISPLAY variable.
      If you are not familiar with ssh, see <ulink
      url="http://www.openssh.org">openSSH</ulink></para>
    </sect2>

    <sect2>
      <title>DependentListProcessDecorator</title>

      <para>This process is used when a process is dependent on an another
      process. The first process of the list can be any process but the second
      one must be a DependentProcess thus has to implement the
      org.objectweb.proactive.core.process.DependentProcess interface.</para>

      <para>Check also <xref linkend="examples/SSH_MPI_Example.xml"
      role="xmlFileSrc" />.</para>

      <para><screen>   &lt;processDefinition id='<emphasis role="bold">dependentProcessSequence</emphasis>'&gt;
    &lt;dependentProcessSequence class='<emphasis role="bold">org.objectweb.proactive.core.process.DependentListProcessDecorator</emphasis>'&gt;
     &lt;processReference refid='<emphasis role="bold">pbsProcess</emphasis>' /&gt;
     &lt;processReference refid='<emphasis role="bold">mpiProcess</emphasis>' /&gt;
    &lt;/dependentProcessSequence&gt;
   &lt;/processDefinition&gt;
   &lt;processDefinition id='<emphasis role="bold">sshProcess</emphasis>'&gt;
    &lt;sshProcess class='<emphasis role="bold">org.objectweb.proactive.core.process.ssh.SSHProcess</emphasis>' hostname='frontend' &gt;
     &lt;processReference refid='<emphasis role="bold">dependentProcessSequence</emphasis>' /&gt;
    &lt;/sshProcess&gt;
   &lt;/processDefinition&gt;</screen></para>
    </sect2>
  </sect1>

  <sect1 id="Descriptor_html_services">
    <title>Infrastructure and services</title>

    <para>As mentionned previously, instead of creating jvms, ProActive gives
    the possibility to acquire existing jvms. To do so, as shown in the
    example below, a service must be referenced in the <emphasis
    role="bold">acquisition</emphasis> tag. At this point two services are
    implemented: <emphasis role="bold">RMIRegistryLookup</emphasis>: this
    service performs a lookup in an RMIRegistry at the <emphasis
    role="bold">url specified in the service definition</emphasis> to find a
    ProActiveRuntime(a jvm) with the given name. <emphasis
    role="bold">P2PService</emphasis> service allows when using ProActive's
    P2P infrastructure to get as many jvms as desired.</para>

    <programlisting lang="xml"> &lt;?xml version='1.0' encoding='UTF-8'?&gt;                      
 &lt;ProActiveDescriptor
 xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
 xsi:noNamespaceSchemaLocation='DescriptorSchema.xsd'&gt;
  &lt;componentDefinition&gt;
   &lt;virtualNodesDefinition&gt;
    &lt;virtualNode name='<emphasis role="bold">VnTest</emphasis>'
 property='multiple'/&gt;
   &lt;/virtualNodesDefinition&gt;
  &lt;/componentDefinition&gt;
  &lt;deployment&gt;
   &lt;mapping&gt;
    &lt;map virtualNode='<emphasis role="bold">VnTest</emphasis>'&gt;
     &lt;jvmSet&gt;
      &lt;vmName value='<emphasis role="bold">Jvm1</emphasis>'/&gt;
      &lt;vmName value='<emphasis role="bold">Jvm2</emphasis>'/&gt;
     &lt;/jvmSet&gt;
    &lt;/map&gt;
   &lt;/mapping&gt;
   &lt;jvms&gt;
    &lt;jvm name='<emphasis role="bold">Jvm1</emphasis>'&gt;
     &lt;<emphasis role="bold">acquisition</emphasis>&gt;
      &lt;<emphasis role="bold">serviceReference</emphasis> refid='<emphasis
        role="bold">lookupRMI</emphasis>'/&gt;
     &lt;/<emphasis role="bold">acquisition</emphasis>&gt;
    &lt;/jvm&gt;
    &lt;jvm name='<emphasis role="bold">Jvm2</emphasis>'&gt;
     &lt;<emphasis role="bold">acquisition</emphasis>&gt;
      &lt;<emphasis role="bold">serviceReference</emphasis> refid='<emphasis
        role="bold">lookupP2P</emphasis>'/&gt;
     &lt;/<emphasis role="bold">acquisition</emphasis>&gt;
    &lt;/jvm&gt;
   &lt;/jvms&gt;
  &lt;/deployment&gt;
  &lt;infrastructure&gt;
   &lt;services&gt;
    &lt;serviceDefinition id='<emphasis role="bold">lookupRMI</emphasis>'&gt;
     &lt;<emphasis role="bold">RMIRegistryLookup</emphasis> url='//localhost:2020/PA_JVM1'/&gt;
    &lt;/serviceDefinition&gt;
    &lt;serviceDefinition id='<emphasis role="bold">lookupP2P</emphasis>'&gt;
     &lt;<emphasis role="bold">P2PService</emphasis> nodesAsked='2'acq='rmi' port='2410' NOA='10' TTU='60000' TTL='10'&gt;
      &lt;peerSet&gt;
       &lt;peer&gt;rmi://localhost:3000&lt;/peer&gt;
      &lt;/peerSet&gt;
     &lt;/P2PService&gt;
    &lt;/serviceDefinition&gt;
   &lt;/services&gt;
  &lt;/infrastructure&gt;
 &lt;/ProActiveDescriptor&gt;</programlisting>

    <para>The <emphasis role="bold">RMIRegistryLookup</emphasis> service needs
    only an <emphasis role="bold">url</emphasis> to perform the lookup. Many
    options exist for the <emphasis role="bold">P2PService</emphasis> service:
    <emphasis role="bold">nodesAsked</emphasis> represents the number of JVMs
    to acquire, the <emphasis role="bold">peer</emphasis> element represents
    an entry point in the P2P system, many peers can be specified. Elements
    <emphasis role="bold">acq</emphasis> and <emphasis
    role="bold">port</emphasis> represent the communication protocol and the
    listening port for the P2P Service, if a P2P Service is already running
    with this configuration the descriptor will use this one else a new one is
    started. <xref linkend="p2p" /> provides more information.</para>

    <para>The example above shows a VirtualNode <emphasis
    role="bold">VnTest</emphasis>, that is mapped with two jvms, <emphasis
    role="bold">Jvm1 and Jvm2</emphasis>. <emphasis
    role="bold">Jvm1</emphasis> represents one jvm that will be acquired using
    an RMI Lookup, <emphasis role="bold">Jvm2</emphasis> represents two jvms
    that will be found in the P2P infrastructure, so at the end 3 acquired
    jvms are expected.</para>

    <para>Fault Tolerance can also be defined at the service level. See <xref
    linkend="faultTolerance" /> for more information.</para>

    <para></para>
  </sect1>

  <sect1>
    <title>How to terminate a ProActive application</title>

    <indexterm>
      <primary>Kill</primary>

      <secondary>Nodes</secondary>
    </indexterm>
	<sect2>
		<title>Destroying active objects</title>
		<para>In the master slave paradigm, the master should wait for all of
		its slaves to be known. Then all active objects can be destroyed by
		letting the master terminate all the slaves and then itself.</para>

		<para>In a more complex topology, a distributed termination algorithm
		must be designed.</para>

		<para>The simplest alternative is to enable the DGC by setting the
		<emphasis>proactive.dgc</emphasis> property to <emphasis>true</emphasis>
		and let it destroy unreferenced active objects and cycles of idle active
		objects.</para>
		
		<para>The default configuration should be suitable in most case, but
		it is possible to alter the timing of the DGC algorithm using two
		parameters: <emphasis>proactive.dgc.ttb</emphasis> and
		<emphasis>proactive.dgc.tta</emphasis>.</para>
		
		<para><emphasis>proactive.dgc.ttb</emphasis> specifies the period of the
		heartbeat in milliseconds, and <emphasis>proactive.dgc.tta</emphasis>
		specifies the time to wait in milliseconds before assuming a beat was
		received from all referencers.</para>
		
		<para>Scientifically speaking, <emphasis>proactive.dgc.tta</emphasis> must
		be much greater than <emphasis>proactive.dgc.ttb</emphasis> to account for
		the network latency. By default  <emphasis>proactive.dgc.ttb</emphasis> is
		30 seconds and <emphasis>proactive.dgc.tta</emphasis> is 150 seconds.</para>
	</sect2>
	<sect2>
		<title>Killing JVMs</title>
		<para>Once active objects are destroyed, JVMs must be killed in order
		to complete the cleanup. Alternatively, one can focus on killing the
		JVMs, that will get rid of the active objects too.</para>
		
    <para>ProActive gives the ability to kill all JVMs and Nodes deployed with
    an XML descriptor with the method: killall(boolean softly) in class
    ProActiveDescriptor (this class's code is in <xref
    linkend="core/descriptor/data/ProActiveDescriptor.java"
    role="javaFileSrc" />)</para>

    <para><programlisting lang="java">ProActiveDescriptor pad = ProActive.getProactiveDescriptor(String xmlFileLocation);
//----------- Returns a ProActiveDescriptor object from the xml file
pad.activateMappings();

...

pad.killall(false);
//----------- Kills every jvms deployed with the descriptor</programlisting></para>

    <para>If <emphasis role="bold">softly</emphasis> is set to false, all jvms
    created when activating the descriptor are killed abruptely. If true a jvm
    that originates the creation of a rmi registry waits until registry is
    empty before dying. To be more precise a thread is created to ask
    periodically the registry if objects are still registered.</para>
    
    <para>An alternative is to set the "proactive.exit_on_empty" property to "true",
    this way, when the last active object running in a JVM is destroyed, the latter
    JVM is destroyed too.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Processes</title>

    <para>There is the possiblity to use only the infrastructure part in order
    to create processes. A Schema called ProcessSchema located in the examples
    directory allows to validate XML files for processes. ProActive provides
    also the ability to use all processes defined above without using XML
    Deployment Descriptor. You can programmatically create such
    processes.</para>

    <para>In order to get familiar on how to create processes
    programmatically, see the Process package</para>

    <screen><ulink
        url="../api/org/objectweb/proactive/core/process/package-summary.html">org.objectweb.proactive.core.process</ulink></screen>
  </sect1>
</chapter>