<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="OOSPMD">
  <title>OOSPMD</title>

  <sect1 >
    <title>OOSPMD: Introduction</title>

    <indexterm><primary>OOSPMD</primary><secondary>definition</secondary></indexterm>
    
    <para>SPMD stands for Single Program Multiple Data. Merged into an
    object-oriented framework, an SPMD programming model becomes an OOSPMD
    programming model.</para>

    <para>The typed group communication system can be used to simulate
    MPI-style collective communication. Contrary to MPI that requires all
    members of a group to collectively call the same communication primitive,
    our group communication scheme let the possibility to one activity to call
    a method on the group.</para>

    <para>The purpose of our group communication is to free the programmer
    from having to implement the complex communication code required for
    setting identical group in each SPMD activity, group communication,
    thereby allowing the focus to be on the application itself.</para>

    <para>This page presents the mechanism of typed group communication as an
    new alternative to the old SPMD programming model. While being placed in
    an object-oriented context, this mechanism helps the definition and the
    coordination of distributed activities. The approach offers, through
    modest size API, a better structuring flexibility and implementation. The
    automation of key communication mechanisms and synchronization simplifies
    the writing of the code.</para>

    <para>The main principle is rather simple: an spmd group is a group of
    active objects where each one has a group referencing all the active
    objects.</para>
  </sect1>

  <sect1 >
    <title>SPMD Groups</title>

    <indexterm><primary>OOSPMD</primary><secondary>groups</secondary></indexterm>
    
    <para>An spmd group is a ProActive typed group built with the <emphasis
    role="bold">PASPMD.newSPMDGroup()</emphasis> method. This method looks
    like the <emphasis role="bold">ProActiveGroup.newGroup()</emphasis>; they
    have similar behavior (and overloads). The difference is that each members
    of an spmd group have a reference to a group containing all the others
    members and itself (i.e. a reference to the spmd group itself).</para>

    <para>Given a standard Java class:</para>

    
      <para><programlisting lang="java">class A { 
  public A() {}
  public void foo (...) {...}
  public void bar (...) {...}
  ...
}</programlisting></para>
    

    <para>The spmd group is built as follow:</para>

    
      <para><programlisting lang="java">  Object[][] params = {{...} , {...} , ... }; 
  Node[] nodes  = { ... , ..., ... }; 
  A agroup = (A) PASPMD.newSPMDGroup('A', params[], nodes); </programlisting></para>
    

    <para>Object members of an spmd group are aware about the whole group.
    They can obtain some informations about the spmd group they belong to such
    as the size of the group, their rank in the group, and a reference to the
    group in order to get more informations or to communicate with method
    invocations. Those informations are respectively obtained using the static
    methods <emphasis role="bold">getMySPMDGroupSize()</emphasis>, <emphasis
    role="bold">getMyRank()</emphasis>, and <emphasis
    role="bold">getSPMDGroup()</emphasis> of the <emphasis
    role="bold">PASPMD</emphasis> class.</para>
  </sect1>

  <sect1 >
    <title>Barrier: Introduction</title>

    <indexterm><primary>Barriers</primary><secondary>definition</secondary></indexterm>

    <para>ProActive provides three kinds of barrier to synchronize activities.
    The feature is specially useful in a SPMD programming style. A barrier
    stops the activity of the active object that invokes it (ie. stop serving
    the requests which are in its request queue) until a special
    condition is satisfied. Notice that, as the opposite of MPI or such
    libraries, the ProActive barriers do not stop the current activity
    immediately (when the <emphasis role="bold">barrier</emphasis> method is
    encountered). The current request actually keeps on executing until the
    end. The barrier will be activated at the end of the request: no other
    request will be served until all the AOs involved in the barrier are at
    that same point.</para>

    <para>The three barriers are named:</para>

    <itemizedlist>
      <listitem>
        <para>the <emphasis role="bold">Total Barrier</emphasis></para>
      </listitem>

      <listitem>
        <para>the <emphasis role="bold">Neighbor Barrier</emphasis></para>
      </listitem>

      <listitem>
        <para>the <emphasis role="bold">Method-based Barrier</emphasis></para>
      </listitem>
    </itemizedlist>

    <para>Here is a presentation about how to use those barriers.</para>
  </sect1>

  <sect1 >
    <title>Total Barrier</title>

    <para>Total barrier directly involves the spmd group. A call to <emphasis
    role="bold">barrier(String)</emphasis> will block until all the members in
    the spmd group have themselves reach and called the identical <emphasis
    role="bold">PASPMD.barrier()</emphasis> primitive. Such call communicates
    with all the members of the spmd group. The barrier is released when the
    Active Object has received a <emphasis>barrier message</emphasis> from all
    other members of the spmd group (including itself).</para>

    <para>The string parameter is used as a unique identity name for the
    barrier. <emphasis>It is the programmer responsibility to ensure that two (or more)
    different barriers with the same id name are not invoked
    simultaneously.</emphasis></para>

    <para>Let us take a Java class that contains a method calling a total
    barrier, here the method <emphasis role="bold">foo</emphasis>:</para>

    
      <para><programlisting lang="java">class A { 
  public A() {}
  public void foo (...) {
    ...
    PASPMD.barrier('MyBarrier');
  }
  public void bar (...) {...}
  ...
}</programlisting></para>
    

    <para>Note that usually, strings used as unique ID are more complex; they
    can be based on the full name of the class or the package (<emphasis
    role="bold">org.objectweb.proactive.ClassName</emphasis>), for example.
    The spmd group is built as follow:</para>

    
      <para><programlisting lang="java">  Object[][] params = {{...} , {...} , ... }; 
  Node[] nodes  = { ... , ..., ... }; 
  A agroup = (A) PASPMD.newSPMDGroup('A', params[], nodes); </programlisting></para>
    

    <para>Here the main method of our application:</para>

    
      <para><programlisting lang="java">  agroup.foo();
  agroup.bar();</programlisting></para>
    

    <para>The call to <emphasis role="bold">barrier</emphasis> launched by all
    members (in the invocation of <emphasis role="bold">foo</emphasis>)
    ensures that no one will initiate the <emphasis role="bold">bar</emphasis>
    method before all the <emphasis role="bold">foo</emphasis> methods
    end.</para>

    <para>The programmer have to ensure that <emphasis role="bold">all the
    members of an spmd group call the barrier method</emphasis> otherwise the
    members of the group may indefinitely wait.</para>
  </sect1>

  <sect1 >
    <title>Neighbor
    barrier</title>

    <para>The Neighbor barrier is a kind of light weighted barrier, involving
    not all the member of an spmd group, but only the Active Objects specified
    in a given group.</para>

    <para><emphasis role="bold">barrier(String,group)</emphasis> initiates a
    barrier only with the objects of the specified group. Those objects, that
    contribute to the end of the barrier state, are called
    <emphasis>neighbors</emphasis> as they are usually local to a given
    topology, an object that invokes the Neighbor barrier HAVE TO BE IN THE
    GROUP given as parameter. The <emphasis>barrier message</emphasis> is only
    sent to the group of neighbors.</para>

    <para>The programmer has to explicitly build this group of neighbors. The
    topology API can be used to build such group. Topologies are
    groups. They just give special access to their members or (sub)groups
    members. For instance, a matrix fits well with the topology <emphasis
    role="bold">Plan</emphasis> that provides methods to get the reference of
    neighbor members (<emphasis role="bold">left</emphasis>, <emphasis
    role="bold">right</emphasis>, <emphasis role="bold">up</emphasis>,
    <emphasis role="bold">down</emphasis>). 
    
    See the javadoc of the topology package for more information:</para>
   
    <!-- This url can only work in the html generated files: in pdf there's no ".." -->
   <screen><ulink os="html" 
       url="../api/org/objectweb/proactive/core/group/topology/package-summary.html">org.objectweb.proactive.core.group.topology</ulink><phrase 
       os="pdf">org.objectweb.proactive.core.group.topology</phrase></screen>
   
    <para>Like for the Total barrier, the string parameter represents a unique
    identity name for the barrier. The second parameter is the group of
    neighbors built by the programmer. Here is an example:</para>

    
      <para><programlisting lang="java"> PASPMD.barrier('MyString', neighborGroup); </programlisting></para>
    

    <para>Refer to the <emphasis>Jacobi</emphasis> example to see a use-case of the
    Neighbor barrier. Each submatrix needs only to be synchronized with the
    submatrixes which are in its cardinal neighbors.</para>

    <para>This barrier increases the asynchronism and reduce the amount of
    exchanged messages.</para>
  </sect1>

  <sect1 >
    <title>Method Barrier</title>

    <para>The Method barrier does no more involve extra messages to
    communicate (i.e. the <emphasis>barrier messages</emphasis>).
    Communications between objects to release a barrier are achieved by the
    standard method call and request reception of ProActive.</para>

    <para>As a standard barrier, the method <emphasis role="bold">barrier(String[])</emphasis>
    will finish the current request served by the active object that calls it, but it then wait for a request on the specified
    methods to resume. The array of string contains the name of the awaited
    methods. The order of the methods does not matter. For example:</para>

    
      <para><programlisting lang="java"> PASPMD.barrier({'foo', 'bar', 'gee'}); </programlisting></para>
    

    <para>The caller will stop and wait for the three methods. bar or gee can
    came first, then foo. If one wants wait for foo, then wait for bar, then
    wait for gee, three calls can be successively done:</para>

    
      <para><programlisting lang="java">   PASPMD.barrier({'foo'});
   PASPMD.barrier({'bar'});
   PASPMD.barrier({'gee'}); </programlisting></para>
    

    <para>A method barrier is used without any group (spmd or not). To learn
     more on Groups, please refer to <xref linkend="TypedGroupCommunication"/>.</para>
  
  </sect1>
  <sect1>
   <title>When does a barrier get triggered?</title>
   <para>
   
    Barriers are not triggered at the place they are declared in the code. 
    Instead, they are run at the end of the method. Look at this code:</para>
    <programlisting lang="java">public void MyMethodWithBarrier () {
    foo();
    PASPMD.barrier("barrier");
    bar();
    } </programlisting>
  <para>In this case, the call to bar() will be made <emphasis>BEFORE</emphasis> 
   the barrier is really triggered. In fact, the barriers only start blocking 
   at the <emphasis>END</emphasis> of the method. If you use something like 
   <literal>this.asyncRefToSelf.bar()</literal>, it's ok, because then this 
   call is put on the request queue, and will be effectively run 
   <emphasis>AFTER</emphasis> the end of the current method. But if, like in the 
   previous case (with the <literal> bar()</literal> method), a call is declared 
   before the end of the method, then the barrier will be run after this call 
   is made.</para>
  
  <para>To enforce the barrier, you should make the barrier the last action 
   of your method, or you can use this trick:</para>
  <programlisting lang="java">    foo();
    PASPMD.barrier("barrier");
    this.asyncRefToSelf.bar();</programlisting>
    
    <note><para>The behavior of barrier is peculiar in this sense. You should keep 
      in mind this particularity when writing code with barriers.</para></note>
  </sect1>
</chapter>