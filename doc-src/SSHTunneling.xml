<!-- Converted by db4-upgrade version 1.0 -->

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="SSHTunneling"><info><title>Using SSH tunneling for RMI or HTTP communications</title></info>
  

  <!--  File: /home/irosenbe/PA_new_doc/docbook-tuto/SSHTunneling.html  -->

  <section><info><title>Overview</title></info>
    

    <para>ProActive allows users to <emphasis role="bold">tunnel</emphasis>
    all of their RMI or HTTP communications over <emphasis role="bold">SSH</emphasis>: it is possible to specify in ProActive
    deployment descriptors which JVMs should <emphasis role="bold">export</emphasis> their RMI objects through a SSH
    tunnel.</para>

    <para>This kind of feature is useful for two reasons:</para>

    <itemizedlist>
      <listitem>
        <para>it might be necessary to encrypt the RMI communications to
        improve the RMI security model.</para>
      </listitem>

      <listitem>
        <para>the configuration of the network in which a given ProActive
        application is deployed might contain firewalls which reject or drop
        direct TCP connections to the machines which host RMI objects. If
        these machines are allowed to receive ssh conections over their port
        22 (or another port number), it is possible to multiplex and
        demultiplex all RMI connections to that host through its ssh
        port.</para>
      </listitem>
    </itemizedlist>

    <para>To successfully use this feature with reasonable performance, it is
    <emphasis role="bold">mandatory</emphasis> to understand:</para>

    <itemizedlist>
      <listitem>
        <para>the configuration of the underlying network: <emphasis role="bold">location and configuration of the
        firewalls</emphasis>.</para>
      </listitem>

      <listitem>
        <para>the communication patterns of the underlying ProActive runtime:
        <emphasis role="bold">which JVM makes requests to which
        JVMs.</emphasis></para>
      </listitem>

      <listitem>
        <para>the communication patterns of your ProActive objects: <emphasis role="bold">which object makes requests to which object</emphasis>.
        For example: A -&gt; B, B -&gt; C, A -&gt;C</para>
      </listitem>
    </itemizedlist>
  </section>

  <section><info><title>Configuration of the
    network</title></info>
    

    <para>No two networks are alike. The only thing they share is the fact
    that they are all different. Usually, what you must look for is:</para>

    <itemizedlist>
      <listitem>
        <para>is A <emphasis role="bold">allowed</emphasis> to open a
        connection to B?</para>
      </listitem>

      <listitem>
        <para>is B <emphasis role="bold">allowed</emphasis> to open a
        connection to A? (networks are rarely symetric)</para>
      </listitem>
    </itemizedlist>

    <para>If you use a TCP or a UDP-based communication protocol (ie: RMI is
    based on TCP), these questions can be translated into 'what <emphasis role="bold">ports</emphasis> on B is A <emphasis role="bold">allowed</emphasis> to open a connection to?'. Once you have
    answered this question for all the hosts used by your application, write
    down a small diagram which outlines what kind of connection is possible.
    For example:</para>

    <screen>  Firewall                         Firewall
     |   *                        *    |
     | ----&gt;     Internet       &lt;----  |
A    | &lt;----                    ----&gt;  |    B
     |   22                       22   |
</screen>

    <para>This diagram summarizes the fact that host A is protected by a
    firewall which allows outgoing connections without control but allows only
    incoming connections on port 22. Host B is also protected by a similar
    firewall.</para>
  </section>

  <section><info><title>ProActive runtime
    communication patterns</title></info>
    

    <para>To execute a ProActive application, you need to <emphasis role="bold">'deploy'</emphasis> it. Deployment is performed by the
    ProActive runtime and is configured by the ProActive deployment descriptor
    of the initial host. During deployment, each newly- created ProActive
    runtime performs a request to the initial ProActive runtime. The initial
    runtime also performs at least one request on each of these distant
    runtime.</para>

    <para>This 2-way communication handshake makes it necessary to <emphasis role="bold">correctly configure the network</emphasis> to make sure that
    the filtering described above does not interfere with the normal operation
    of the ProActive runtimes.</para>
  </section>

  <section><info><title>ProActive application
    communication patterns.</title></info>
    

    <para>Once an application is properly deployed, the application objects
    deployed by the ProActive runtime start making requests to each other. It
    is important to properly identify what object connects to what object to
    identify the influence of the network configuration on these communication
    patterms.</para>
  </section>

  <section><info><title>ProActive communication
    protocols</title></info>
    

    <para>Whenever a request is made to a non-local ProActive object, this
    request is performed with the communication protocol specified by the
    destination JVM. Namely, each JVM is characterized by a a unique property
    named <emphasis role="bold">proactive.communication.protocol</emphasis>
    which is set to one of:</para>

    <itemizedlist>
      <listitem>
        <para>rmi</para>
      </listitem>

      <listitem>
        <para>http</para>
      </listitem>

      <listitem>
        <para>rmissh</para>
      </listitem>

      <listitem>
        <para>ibis</para>
      </listitem>

      <listitem>
        <para>jini</para>
      </listitem>
    </itemizedlist>

    <para>This property uniquely identifies the protocol which is used by each
    client of the JVM to send data to this JVM. To use different protocols for
    different JVMs, two solutions exist:</para>

    <itemizedlist>
      <listitem>
        <para>one is to edit the <emphasis role="bold">ProActive deployment
        descriptors</emphasis> and to pass the property as a command-line
        option to the JVM:</para>
      </listitem>

      <listitem>
        <para><screen>   <emphasis role="bold">&lt;jvmProcess class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
....
&lt;jvmParameters&gt;
    &lt;parameter value='-Dproactive.communication.protocol=rmissh'/&gt;
&lt;/jvmParameters&gt;
...
&lt;/jvmProcess&gt;</emphasis></screen></para>
      </listitem>

      <listitem>
        <para>the other one is to set in the <emphasis role="bold">ProActive
        Configuration file</emphasis>(introduced in a previous chapter) on the
        remote host the property proactive.communication.protocol to the
        desired protocol</para>

        <screen><emphasis role="bold">&lt;prop key='proactive.communication.protocol' value='rmissh'/&gt; </emphasis></screen>
      </listitem>
    </itemizedlist>

    <para>Finally, if you want to set this property on the <emphasis role="bold">initial</emphasis> deployment JVM (the JVM that starts the
    application), you will need to specify the
    -Dproactive.communication.protocol=rmissh argument yourself on the JVM
    command line.</para>
  </section>

  <section><info><title>The rmissh communication
    protocol.</title></info>
    

    <para>This protocol is a bit special because it keeps a lot of
    compatibility with the rmi protocol and a lot of options are available to
    <emphasis role="bold">'optimize'</emphasis> it.</para>

    <para>This protocol can be used to automatically <emphasis role="bold">tunnel</emphasis> all RMI communications through SSH tunnels.
    Whenever a client wishes to access a distant rmissh server, rather than
    connecting directly to the distant server, it first creates a SSH tunnel
    (so-called port-forwarding) from a random port locally to the distant
    server on the distant host/port. Then, all it has to do to connect to this
    server is to pretend this server is listening on the local random port
    choosen by the ssh tunnel. The ssh daemon running on the server host
    receives the data for this tunnel, decapsulates it and forwards it to the
    real server.</para>

    <para>Thus, whenever you request that a JVM be accessed only through
    rmissh (namely, whenever you set its <emphasis role="bold">proactive.communication.protocol to rmissh</emphasis>), you
    need to make sure that an ssh daemon is running on its host. ProActive
    uses the <emphasis role="bold">ganymed</emphasis> client ssh library to
    connect to this daemon.</para>

    <para>The properties you can set to configure the behavior of the ssh
    tunneling code are listed below. All these properties are client-side
    properties:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">proactive.ssh.port</emphasis>: the port
        number on which all the ssh daemons to which this JVM must connect to
        are expected to listen. If this property is not set, the default is
        22.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">proactive.ssh.username</emphasis>: Two
        possible syntaxes: username alone .e.g. <emphasis role="bold">proactive.ssh.username=jsmith</emphasis>, it represents
        the username which will be used during authentication with all the ssh
        daemons to which this JVM will need to connect to.</para>

        <para>Or you can use the form <emphasis role="bold">proactive.ssh.username=username1@machine1;username2@machine2;...;usernameN@machineN</emphasis>.
        Note that several usernames without machine's names is not allowed and
        won't be parsed properly.</para>

        <para>If this property is not set, the default is the user.name java
        property.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">proactive.ssh.known_hosts</emphasis>: a
        filename which identifies the file which contains the traditional ssh
        known_hosts list. This list of hosts is used during authentication
        with each ssh daemon to which this JVM will need to connect to. If the
        host key does not match the one stored in this file, the
        authentication will fail. If this property is not set, the default is
        System.getProperty ('user.home') + '/.ssh/known_hosts'</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">proactive.ssh.key_directory</emphasis>: a
        directory which is expected to contain the pairs of public/private
        keys used during authentication. the private keys must not be
        encrypted. The public keys filenames must match '*.pub'. Private keys
        are ignored if their associated public key is not present. If this
        property is not set, the default is System.getProperty ('user.home') +
        '/.ssh/'</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">proactive.tunneling.try_normal_first</emphasis>: if this
        property is set to 'yes', the tunneling code always attempts to make a
        direct rmi connection to the remote object before tunneling. If this
        property is not set, the default is not to make these
        direct-connection attempts. This property is especially useful if you
        want to deploy a number of objects on a LAN where only one of the
        hosts needs to run with the rmissh protocol to allow hosts outside the
        LAN to connect to this frontend host. The other hosts located on the
        LAN can use the try_normal_first property to avoid using tunneling to
        make requests to the LAN frontend.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">proactive.tunneling.connect_timeout</emphasis>: this
        property specifies how long the tunneling code will wait while trying
        to establish a connection to a remote host before declaring that the
        connection failed. If this property is not set, the default value is
        2000ms.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">proactive.tunneling.use_gc</emphasis>: if
        this property is set to 'yes', the client JVM does not destroy the ssh
        tunnels as soon as they are not used anymore. They are queued into a
        list of unused tunnels which can be reused. If this property is not
        set or is set to another value, the tunnels are destroyed as soon as
        they are not needed anymore by the JVM.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">proactive.tunneling.gc_period</emphasis>:
        this property specifies how long the tunnel garbage collector will
        wait before destroying a unused tunnel. If a tunnel is older than this
        value, it is automatically destroyed. If this property is not set, the
        default value is 10000ms.</para>
      </listitem>
    </itemizedlist>

    <para>Note that the use of SSH tunneling over RMI still allows dynamic
    classloading through HTTP. For the dynamic classloading our protocol
    creates an SSH tunnel over HTTP, in order to get missing classes. It is
    also important to notice that all you have to do in order to use SSH
    tunneling is to set the <emphasis role="bold">proactive.communication.protocol</emphasis> property to
    <emphasis role="bold">rmissh</emphasis> and to use the related properties
    if needed(in major cases default behavior is sufficient), ProActive takes
    care of everything else.</para>
  </section>
</chapter>
