<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="../viewDocbook.css"?>
<chapter id="ProActive_Scheduler">
  <title>ProActive Scheduler</title>

    <para><emphasis role="bold">IMPORTANT NOTE</emphasis> - Some parts of the ProActive Scheduler rely on Java Scripting capabilities (<ulink url="http://jcp.org/en/jsr/detail?id=223">JSR 223</ulink>). As a consequence, it requires either:
    <itemizedlist>
          <listitem> a 1.6 or greater Java Runtime Environment, without any modifications, </listitem>
          <listitem> or, with a 1.5 JRE, the <ulink url="http://jcp.org/aboutJava/communityprocess/final/jsr223/index.html">JSR 223 jar files</ulink>. Those files must be added in the <literal>/ProActive/dist/lib/</literal> directory if
          you are using the bin release or ProActive, or in the <literal>/ProActive/lib/</literal> directory if you build ProActive from the source release.</listitem>
    </itemizedlist>
    </para>

  <sect1 id="overview">
    <title>Overview</title>

    <para>The execution of parallel tasks on a pool of distributed resources,
    such as network of desktops or clusters, requires a main system for
    managing resources and handling task execution: <emphasis role="bold">a
    batch scheduler</emphasis>. A batch scheduler provides an abstraction of
    resources to users. Users submit jobs containing tasks to the <emphasis
    role="bold">scheduler</emphasis>, who is in charge of executing these
    tasks on the resources. A <emphasis role="bold">scheduler</emphasis>
    allows several users to share a same pool of resources and also to manage
    all issues related to distributed environment, such as faulted
    resources.</para>

    <para>In this chapter we present a ProActive based Scheduler accessible either from
    <emphasis role="bold">a JAVA programming API</emphasis>, <emphasis
    role="bold">a command-line based job submitter</emphasis>, <emphasis
    role="bold">or from a graphical user or admin interface</emphasis> (Eclipse
    RCP Plugin, see <xref linkend="Scheduler_Eclipse_Plugin" />) which can be
    plugged on the scheduler core application.</para>

    <para>In the rest of this chapter, we will expose how the scheduler works,
    what policies govern the job management, how to create a job and how to
    get the jobs and the nodes state using either the shell communicator or
    the GUI.</para>
    
  </sect1>

  <sect1 id="scheduler_concept">
    <title>Scheduler Concept</title>

    <sect2 id="what_is_job">
      <title>What is a Job ?</title>

      <para>A <emphasis role="bold">Job</emphasis> is the entity to be given
      to the scheduler, and is composed of one or more <emphasis
      role="bold">Tasks</emphasis>. A Job can have one of the following types
      : <itemizedlist>
          <listitem>
            <para><emphasis role="bold">TASKSFLOW</emphasis>, represents a Job
            that contains a bag of Tasks, which can be execute in parallel or
            according to a dependence tree. The Tasks inside this Job type can
            be either Java or Native. </para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">PROACTIVE</emphasis>, represents a Job
            that contains a ProActive application (only one ProActive Task).
            Its execution will start with a given predefined number of nodes
            on which you can start the computation. This kind of Job requires
            the usage of the ProActive API, in order to use the given
            nodes.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">PARAMETER SWEEPING (not yet implemented)</emphasis>, is a
            Job that represents multiple executions of one type of Task with
            different given parameters. It is typically executed in parallel.
            The Tasks inside this job can also be Java or Native. </para>
          </listitem>
        </itemizedlist></para>

      <para>A finished Job contains a result, which in turn contains all of
      its tasks' results or only those marked as <emphasis
      role="bold">precious</emphasis>. In the event of a failure, the finished
      Job contains the cause exceptions. Further details on how to
      create a Job and the different options can be found in: <xref
      linkend="job_creation" />.</para>
    </sect2>

    <sect2 id="what_is_task">
      <title>What is a Task ?</title>

      <para>The <emphasis role="bold">Task</emphasis> is the smallest
      schedulable entity. It is included in a <emphasis
      role="bold">Job</emphasis> (see <xref linkend="what_is_job" />) and will
      be executed in accordance with the scheduling policy (see <xref
      linkend="scheduling_policy" />) on the available
      resources.</para>

      <para>There are three types of Tasks : <itemizedlist>
          <listitem>
            <para><emphasis role="bold">JAVA</emphasis>; its execution is defined by 
            a java class extending the <literal>org.objectweb.proactive.extensions.scheduler.common.task.executable.JavaExecutable</literal> 
            class. </para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">NATIVE</emphasis>; its execution can be any user program specified by a simple command line, or by a 'generation script', that can dynamicaly generates 
            the command line to be executed.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">PROACTIVE</emphasis>, its execution is defined by 
            a java class extending the <literal>org.objectweb.proactive.extensions.scheduler.common.task.executable.ProActiveExecutable</literal> class.
            Coding this last one requires a knowledge base on the use of
            ProActive.</para>
          </listitem>
        </itemizedlist></para>

      <para>During its execution, a Task may crash due to host or code failure. 
      A Task can be re-started a parameterizable number of time (see re-runnable in section <xref
      linkend="task_creation" />).</para>

      <para>A Task may optionally be accompanied by 3 kinds of scripts
      (preScript, postScript and selectionScript) whose explanations are
      provided in the documentation of the ProActive Resource Manager (<xref
      linkend="resources_manager" />).</para>

      <para>Dependencies between Tasks can also be defined; this apsect is detailed in
      <xref linkend="how_dependences" />.</para>

      <para>The result of a Task can be marked as <emphasis
      role="bold">precious</emphasis>, to make it available in the Job
      Result.</para>
    </sect2>

    <sect2 id="how_dependences">
      <title>What can be done with dependencies ?</title>

      <para>Dependencies can be set between Tasks in a TaskFlow Job. It
      provides a way to execute your tasks in an ordered fashion, but also to
      forward the results of a task to another one. An example is better than
      a thousand words :</para>

      <figure id="scheduler_job_img">
        <title>Task flow job example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="scheduler/pics/core/schedulerJob.jpg"
                       format="JPG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In this example we made an 8 Task Job (where the Job's type is
      TaskFlow). As you can see, Task 4 depends on Task 1, Task 5 depends on
      Tasks 2 and 3, etc... In other words, Task 4 will wait for Task 1 to
      finish before starting, Task 5 will wait for Task 2
      <emphasis>AND</emphasis> 3, etc... In addition, the order in which you
      specify that Task 5 depends of Task 2 and 3 is very important. Indeed,
      if you set the list of dependencies for Task 5 as : 2 then 3, the result
      of these two task will be given to Task 5 in this order. (TODO missing
      example comparing both cases )</para>

      <para>As shown in the following lines, the given array of TaskResults
      (<emphasis>results</emphasis>) will be an array of two results
      (TaskResult 2 and 3) in this order. Therefore you can use them to
      perform Task 5 process. <programlisting lang="java">@Override
public Object execute(TaskResult... results) throws Throwable {
    //user code for task 5...
}</programlisting></para>

      <para>We will see how to define the dependencies and the order when we
      create our first job in <xref linkend="job_creation" />. In this
      example, result of Task 7 and 8 could be <emphasis
      role="bold">precious</emphasis>, which means that you can retrieve
      easily this two results.</para>
    </sect2>

    <sect2 id="scheduling_policy">
      <title>Scheduling Policy</title>

      <para><emphasis role="bold">By default</emphasis>, the scheduler
      schedules tasks according to the default <emphasis role="bold">FIFO
      (First In First Out) with job priority</emphasis> policy. We'll see
      later that the policy can be changed by implementing an interface.
      (<xref linkend="add_policy" />)</para>
    </sect2>
  </sect1>

  <sect1 id="scheduler_architecture">
    <title>Scheduler Architecture</title>

    <sect2 id="Scheduler_Global_Architecture">
      <title>Scheduler Global Architecture</title>

      <para>The Scheduler Service is the result of a collaboration between 2
      entities (the Scheduler and the Resource Manager) each one of them has
      its own functionality.</para>

      <para>The Scheduler is the main entity and is a non GUI daemon which is
      connected to the Resources Manager. It is in charge of scheduling
      submitted Jobs, in accordance with the scheduling policy.</para>

      <para>In order to launch Jobs, the Scheduler must obtain nodes
      (resources) from the Resources Manager. As describe below (<xref
      linkend="scheduler2entities" />), the user interacts only with the
      Scheduler entity and the managed resources can be simple host or peer to peer resource.</para>

      <figure id="scheduler2entities">
        <title>The Scheduler Entities</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="scheduler/pics/core/scheduler2entities.jpg"
                       format="JPG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para><emphasis role="bold">In this section</emphasis> we will explain
      how the <emphasis role="bold">scheduler entity works and how it can be
      used.</emphasis></para>
    </sect2>

    <sect2 id="Scheduler_entity_Architecture">
      <title>Scheduler Entity Architecture</title>

      <para><xref linkend="schedulerEntity">
          The architecture of the scheduler
        </xref> is built around 3 Active Objects : <itemizedlist>
          <listitem>
            <para><emphasis role="bold">The Authentication
            interface</emphasis> which is the first object that the user may
            have to contact. It is in charge of authenticatubg the user and
            allowing him access (or not) to the Scheduler. The authentication
            security system can interact with files or LDAP.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">The Front-end</emphasis> which is the
            interface returned by the Authentication Interface and allows
            interaction with the scheduler. This interface allows users to
            submit jobs, get scheduling state, retrieves job result
            etc...</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">The Core</emphasis> which is the main
            entity of the Scheduler. It is in charge of scheduling Jobs
            according with the policy (which is FIFO by default), retrieve
            scheduling events to the user and make storages in data base (TODO
            link reference to details on data base).</para>
          </listitem>
        </itemizedlist></para>

      <para>Users cannot interact directly with the Scheduler Core and must
      use the Front-end gateway.</para>

      <figure id="schedulerEntity">
        <title>The Scheduler Entity</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="scheduler/pics/core/schedulerEntity.jpg"
                       format="JPG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
  </sect1>

  <sect1 id="scheduler_use">
    <title>Using the ProActive Scheduler</title>

	<sect2 id="define_executable">
		<title>Define your own executable</title>
		<para>
	      	First of all, you must know that you can create your own task by implementing scheduler executable interfaces.
	      	It is possible to implement two types of executables :
	      	<itemizedlist>
	      		<listitem>
	      			<emphasis role="bold">JavaExecutable</emphasis> : to make your own java executable process.
	      			Here's an example of implementation for this type :
	      			<programlisting lang="java">
		public class WaitAndPrint extends JavaExecutable {
		
		    @Override
		    public Object execute(TaskResult... results) throws Throwable {
		        String message;
		
		        try {
		            System.err.println("Démarrage de la tache WaitAndPrint");
		            System.out.println("Parameters are : ");
		
		            for (TaskResult tRes : results) {
		                if (tRes.hadException()) {
		                    System.out.println("\t " + tRes.getTaskId() + " : " +
		                        tRes.getException().getMessage());
		                } else {
		                    System.out.println("\t " + tRes.getTaskId() + " : " +
		                        tRes.value());
		                }
		            }
		
		            message = URIBuilder.getLocalAddress().toString();
		            Thread.sleep(10000);
		
		        } catch (Exception e) {
		            message = "crashed";
		            e.printStackTrace();
		        }
		
		        System.out.println("Terminaison de la tache");
		
		        return (message + "\t slept for 10 sec");
		    }
	    }
	      			</programlisting>
	      			<para>
	      				This task will print an initial message, then check if there are results from previous tasks and if so,
	      				print the value of these "parameters".
	      				It will then return a message containing what the task did. The return value will be store in the job result.
	      			</para>
	      			<para>
	      				It is also possible to get a list of arguments that you can give to the task at its start
	      				by overriding the init method on a java task.
	      				How to give arguments will be explain further in task creation section
	      				(<xref linkend="task_creation" />). We get back the foo, bar and test arguments to
	      				illustrate the task creation example below.
	      				<programlisting lang="java">
	private boolean foo;
	private int bar;
	private String arg;
	
	@Override
    public void init(Map&lt;String, Object&gt; args) {
        foo = (Boolean)args.get("foo");
        bar = (Integer)args.get("bar");
        arg = (String)args.get("arg");
    }
	      				</programlisting>
	      			</para>
	      		</listitem>
	      		<listitem>
	      			<emphasis role="bold">ProActiveExecutable</emphasis> : to make your own ProActive application process.
	      			Here's an example overview of implementation for this type :
	      			<programlisting lang="java">
	@Override
    public Object execute(ArrayList&lt;Node&gt; nodes) {
        System.out.println("ProActive job started !!");

        // create workers (on local node)
        Vector&lt;Worker&gt; workers = new Vector&lt;Worker&gt;();

        for (Node node : nodes) {
            try {
                Worker w = (Worker) PAActiveObject.newActive(Worker.class.getName(),
                        new Object[] {  }, node);
                workers.add(w);
            } catch (ActiveObjectCreationException e) {
                e.printStackTrace();
            } catch (NodeException e) {
                e.printStackTrace();
            }
        }

        // create controller
        Controller controller = new Controller(workers);
        int result = controller.findNthPrimeNumber(numberToFind);

        System.out.println("last prime : " + result);

        return result;
    }
	      			</programlisting>
	      			<para>
	      				As shown in a ProActive tutorial, this example uses the given nodes with 
	      				the ProActive API in order to launch 'workers' on them. The <emphasis>execute(nodes)</emphasis> method
	      				shows what can be done inside this kind of task.
	      				For more details about how to use the ProActive API, see the appropriate documentation.
	      			</para>
	      		</listitem>
	      		<listitem>
	      			<emphasis role="bold">NativeExecutable</emphasis> : just use this class when you'd like
	      			to run a native process on the scheduler. You don't have to extend this class,
	      			just use it as shown in the next section.
	      		</listitem>
	      	</itemizedlist>
	      </para>
	</sect2>

	<sect2 id="without_java_API">
		<title>Using XML descriptors</title>
		
		<sect2 id="start_scheduler_xml">
	      <title>Starting the scheduler</title>
			<para>To start a local scheduler, run the
		      <emphasis>scheduler.sh</emphasis> script in scripts/scheduler directory.
		      Without arguments, the scheduler will start on the local host and create
		      its own Resources Manager.
		    </para>
		
		    <para>
		    	<emphasis>scheduler.sh</emphasis> can be started with 1 optional
		      	argument : <itemizedlist>
		          <listitem>
		            <para>
		            	The URL of a resources manager already started. (ie:
		            	<emphasis role="bold">//hostname/</emphasis>)
		            </para>
		          </listitem>
		        </itemizedlist>
		   	</para>
		</sect2>
	</sect2>
	
	
	<sect2 id="with_java_API">
		<title>Using the java API</title>
		
		<sect2 id="start_scheduler_API">
	      <title>Starting the scheduler</title>
	
	      <para>You can start the scheduler using the java API. Supposing
	      that a Resources Manager is already started (see Resource Manager
	      documentation <xref linkend="resources_manager" />), this can be done in
	      the following way:</para>
	
	      <programlisting lang="java">AdminScheduler.createScheduler(
	    LocalSchedulerExample.class.getResource("login.cfg").getFile(),
	                LocalSchedulerExample.class.getResource("groups.cfg").getFile(),
	                rm,
	                "org.objectweb.proactive.extra.scheduler.policy.PriorityPolicy");</programlisting>
	
	      <para>Arguments are respectively : <orderedlist>
	          <listitem>
	            <para><emphasis>loginFile</emphasis> : A file describing the users
	            and passwords authorized to connect to the scheduler.</para>
	          </listitem>
	
	          <listitem>
	            <para><emphasis>groupFile</emphasis> : A file describing the group
	            on which each user belongs. These groups will be used to identify
	            admin or user rights. </para>
	          </listitem>
	
	          <listitem>
	            <para><emphasis>rm</emphasis> : A reference on an already started
	            Resources Manager instance. </para>
	          </listitem>
	
	          <listitem>
	            <para><emphasis>policyFullClassName</emphasis> : The scheduling
	            policy to use, as a string representing the complete name of the
	            class. </para>
	          </listitem>
	        </orderedlist></para>
	
	      <para>Another way is to start the scheduler AND connect an administrator
	      at the same time :</para>
	
	      <programlisting lang="java">AdminScheduler.createScheduler(
	   LocalSchedulerExample.class.getResource("login.cfg").getFile(),
	                LocalSchedulerExample.class.getResource("groups.cfg").getFile(),
	                "login",
	                "password",
	                rm,
	                "org.objectweb.proactive.extra.scheduler.policy.PriorityPolicy");</programlisting>
	
	      <para>Where arguments are the same plus a <emphasis>login</emphasis> and
	      a <emphasis>password</emphasis> as a string. The user must be in the
	      login file and his group must be admin in the group file.</para>
	    </sect2>
	    
		<sect2 id="how_to_make_job">
			<title>Job Creation</title>
			<sect3 id="task_creation">
		      <title>Create task(s)</title>
		      
		      <para>
		      	As it has been said, it is possible to create 3 types of tasks. These 3 types have some
		      	common features like name, description, scripts, etc... Here's the details of each of these common features :
		      	<itemizedlist>
		      		<listitem>
		      			<emphasis>name</emphasis> is the name assigned to the task. It can be whatever you
		      			want as a String. This name must be unique for each task.
		      			<programlisting lang="java">
	aTask.setName("task 1");
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>description</emphasis> is a human readable description of the task.
		      			It is for human use only. This field is optional but it is better to set it.
		      			<programlisting lang="java">
	aTask.setDescription("This task will do something...");
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>precious result</emphasis> is the way to define that a result of a task
		      			is important or not. For example, in a job result, you could have to retrieve only
		      			some task results that are important for you. By setting the precious result to true
		      			you'll be able to retrieve easily these results. (default is false)
		      			<programlisting lang="java">
	aTask.setPreciousResult(true);
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>re-runnable</emphasis> is a way to define how many times a task will be
		      			reran if a user or network problems occur. Set this value to <emphasis>n</emphasis> if you want the task
		      			to be restarted <emphasis>n</emphasis> times and so, started a maximum of <emphasis>n+1</emphasis> times.
		      			(default is 1)
		      			<programlisting lang="java">
	aTask.setRerunnable(2);
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>result preview</emphasis> allows to specify how the result of a task should be displayed in 
		      			the Scheduler graphical client. The user should implement a result preview class (that extends <literal>org.objectweb.proactive.extensions.scheduler.common.task.ResultPreview</literal> 
		      			abstract class) which specifies result rendrering in two different manners :
		      			<itemizedlist>
		      				<listitem> a textual manner, by implementing <literal>public abstract String getTextualDescription(TaskResult result);</literal>. 
		      				This method, similarily to <literal>String Object.toString()</literal> should return a <literal>String</literal> object that describes the result;
		      				</listitem>
		      				<listitem> a graphical manner, by implementing <literal>public abstract JPanel getGraphicalDescription(TaskResult result);</literal>.
		      				This method should return a Swing <literal>JPanel</literal> object that describes the result.
		      				</listitem>
		      			</itemizedlist>
		      			Some usefull methods to create a specific preview class can be found in <literal>org.objectweb.proactive.extensions.scheduler.common.task.util.ResultPreviewTool</literal>, 
		      			such as automatic display of an image file, or automatic translation between windows and unix path.
		      			<programlisting lang="java">
	aTask.setResultPreview(UserDefinedResultPreview.class);
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>scripts</emphasis>
		      			<para> The ProActive scheduler supports portable scripts execution through the JSR 223 Java Scripting 
		      			capabilities; scripts can be written in any language supported by the underlying Java Runtime Environment. 
		      			Scripts are used in the ProActive scheduler to :
		      			<itemizedlist>
		      				<listitem>Execute some simple pre and post processings: optional pre-script and post-script 
		      			</listitem>
		      			<listitem>Select among available resources the node that suitable for the execution: optional selection-script can 
		      			be associated to a task.</listitem>
		      			<listitem>Dynamic building of a command line for a native task: optional generation-script (detailled in next section).</listitem>
		      			</itemizedlist>
		      			Here are some details and examples:
		      			</para>
		      			<itemizedlist>
		      				<listitem>
		      					<emphasis>pre-script</emphasis> The pre-script is always executed on the node that has been selected by
		      					the resource manager <emphasis>before</emphasis> the execution of the task itself.
		      					<programlisting lang="java">
	//If the script to use is in a file or URL
	String[] args = new String("foo","bar");
	File scriptFile = new File("path/to/script_file");
	// File scriptURL = new URL("url/to/script_file");
	Script script = new SimpleScript(scriptFile, args);
	// Script script = new SimpleScript(scriptURL, args);
	aTask.setPreScript(script);
	//If the script to use is in a java string for example
	Script script = new SimpleScript("Script_content", "type_of_language");
	//where type_of_language can be any langage supported by teh underlying JRE
	aTask.setPreScript(script);
		      					</programlisting>
		      				</listitem>
		      				<listitem>
		      					<emphasis>post-script</emphasis> The pre-script is always executed on the node that has been selected by
		      					the resource manager <emphasis>after</emphasis> the execution of the task itself.
		      					<programlisting lang="java">
	//same construction for the script
	aTask.setPostScript(script);
		      					</programlisting>
		      				</listitem>
		      				<listitem>
		      					<emphasis>selection script</emphasis> The selection script is always executed before the task itself on any candidate node:
		      					the execution of a selection script must set the boolean variable <literal>selected</literal>, that indicates if the candidate node
		      					is suitable for the execution of the associated task.
		      					<programlisting lang="java">
	//same construction for the script
	//the last parameter is still not used in the current implementation
	SelectionScript selScript = new SelectionScript(script, true);
	aTask.setSelectionScript(selScript);
		      					</programlisting>
		      				</listitem>
		      			</itemizedlist>
		      		</listitem>
		      	</itemizedlist>
		      	
		      	<para>The following explains how to create a specific kind of task :</para>
		      	<itemizedlist>
		      		<listitem>
		      			<para>
		      			<emphasis>Create a native task</emphasis> is the simplest thing to do.
		      			Use the <emphasis>NativeTask</emphasis> class to create such a task.
		      			You just have then to specify a command line that have to be executed by the scheduler.
		      			Here's an example that describe how to create a native task with a <emphasis>static command</emphasis> :
		      			<programlisting lang="java">
	//create a new native task
	NativeTask task1 = new NativeTask();
	//set the command to execute as a string
	task1.setCommandLine("ls -al");
		      			</programlisting>
		      			</para>
		      			<para>
		      				Here's an example that describe how to create a native task with a <emphasis>dynamic command</emphasis>
		      				, i.e. generated by a script called a generation script, The generation script can only be associated to a <emphasis>native</emphasis> task: 
		      				the execution of a selection script must set the string variable <literal>command</literal>. The value of this variable is the command
		      					line that will be executed by the Scheduler as task execution.
		      				<programlisting lang="java">
	//create a new native task
	NativeTask task2 = new NativeTask();
	//create a generation script with a script as shown above
    GenerationScript gscript = new GenerationScript(script);
	//set the command to execute as a string
	task2.setGenerationScript(gscript);
		      				</programlisting>
		      			</para>
		      		</listitem>
		      		<listitem>
		      			<para>
		      			<emphasis>Create a java task</emphasis> is not much more difficult.
		      			Use the <emphasis>JavaTask</emphasis> class to create this type of task.
		      			In this type, you must specify the class you want to start with, by mentioning
		      			a Class or an instance of your executable. (To make your own executable see
		      			the proper section <xref linkend="define_executable" />). In addition, you can add
		      			arguments with which the task will be launched. These launching arguments will
		      			be given to the java executable as a Map.
		      			<programlisting lang="java">
	//create a new java task
	JavaTask task3 = new JavaTask();
	//add arguments (optional)
	task3.addArgument("foo",new Boolean(true));
	task3.addArgument("bar",new Integer(12));
	task3.addArgument("test","test1");
	//add executable class or instance
	task3.setTaskClass(WaitAndPrint.class);
	// or
	//task3.setTaskInstance(new WaitAndPrint());
		      			</programlisting>
		      			</para>
		      		</listitem>
		      	</itemizedlist>
		      </para>
		      <para>
		      	For both native and java task, you can specify dependences between each other 
		      	<emphasis role="bold">(but not for ProActive task)</emphasis>.
		      	To perform such a thing, and following the example shown in the dependencies explanation
		      	(<xref linkend="how_dependences" />), let's see an example illustrating how to make task 5
		      	depends of 2 and 3 in this order :
		      	<programlisting lang="java">
	//task 2 has been create just before as a native task
	//task 3 has been create just before as a java task
	//we have to create task 5.
	//create a new native or java task
	JavaTask task5 = new JavaTask();
	//... (fill task5 as describe above)
	//then specify dependencies by using the addDependence(Task) method
	task5.addDependence(task2);
	task5.addDependence(task3);
	//or use the addDependences(list&lt;Task&gt;) method as shown
	//task5.addDependences(new ArrayList&lt;Task&gt;(task2,task3));
		      	</programlisting>
		      </para>
		      
		      <para>
		      	<itemizedlist>
		      		<listitem>
		      			<para>
		      				<emphasis>Create a ProActive task</emphasis> is a bit different. Indeed, it is
		      				not possible to add dependences to this task. This task is design for the
		      				ProActive job. Like the java task, arguments can be set in order to be used
		      				at the start of the task. The corresponding executable is attach to the task
		      				using the same methods as java task. Finally, you must specify the number of needed
		      				nodes for the ProActive task. This is the list of nodes you will receive in the
		      				<emphasis>execute(nodeList)</emphasis> method in the ProActive executable.
		      				See <xref linkend="define_executable" /> to make your own ProActive executable.
		      				<programlisting lang="java">
	//create the ProActive task
	ProActiveTask task = new ProActiveTask();
	//add dependencies... (see java task)
	//add task instance or class... (see java task)
	//set number of needed nodes
	task.setNumberOfNodesNeeded(8);
		      				</programlisting>
		      			</para>
		      			In this example, 8 needed nodes means that you want to use 7 nodes in your executable.
		      			Indeed, one node will be used to start your executable, and the other are given to your
		      			application.
		      		</listitem>
		      	</itemizedlist>
		      </para>
		      <para>
		      	Now that you know how to define tasks, let's see how to make your job.
		      </para>
		    </sect3>
		
		    <sect3 id="job_creation">
		      <title>Create Job</title>
		      
		      <para>
		      	
		      </para>
		    </sect3>
		</sect2>
	
	    <sect2 id="user_interface">
	      <title>User Interface</title>
			
	      <sect3 id="User_Connection">
	        <title>User Connection</title>
	
	        <para>A user can connect to the Scheduler only if he/she is known.
	        That's the goal of the authentication interface which is able to
	        authenticate users. <xref linkend="userConnection">
	            The user connection
	          </xref> shows how the Scheduler connects a user. <figure
	            id="userConnection">
	            <title>A user connection</title>
	
	            <mediaobject>
	              <imageobject>
	                <imagedata align="center"
	                           fileref="scheduler/pics/core/userConnection.jpg"
	                           format="JPG" />
	              </imageobject>
	            </mediaobject>
	          </figure> <orderedlist>
	            <listitem>
	              <para>First of all, a user tries to join the authentication
	              interface using the <emphasis
	              role="bold">SchedulerConnection.join(...)</emphasis> static
	              method. </para>
	
	              <programlisting lang="java">SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/SCHEDULER_OBJECT_NAME");</programlisting>
	
	              <para> Then, with the <emphasis
	              role="bold">SchedulerAuthenticationInterface</emphasis>, users
	              can be connected as user or administrator roles using the
	              <emphasis role="bold">logAsUser</emphasis> or <emphasis
	              role="bold">logAsAdmin</emphasis> methods. </para>
	
	              <programlisting lang="java">UserSchedulerInterface scheduler = auth.logAsUser("username", "password");
	// OR
	AdminSchedulerInterface scheduler = auth.logAsAdmin("adminname", "password");</programlisting>
	            </listitem>
	
	            <listitem>
	              <para>Next, the authentication object checks the users rights
	              and wether the user is authorized to connect the scheduler. If
	              not, an exception will be thrown.</para>
	            </listitem>
	
	            <listitem>
	              <para>Once connected, the authentication object sends the right
	              and username/password to the scheduler front-end which will be
	              able to authenticate user on its own.</para>
	            </listitem>
	
	            <listitem>
	              <para>If nothing goes wrong, the authentication interface will
	              return a <emphasis
	              role="bold">AdminSchedulerInterface</emphasis> which is in fact
	              a direct link to the <emphasis
	              role="bold">Front-end</emphasis>.</para>
	            </listitem>
	
	            <listitem>
	              <para>The user is now able to interact with the Scheduler using
	              the returned interface.</para>
	            </listitem>
	          </orderedlist></para>
	      </sect3>
	
	      <sect3 id="Job_submission">
	        <title>Job Submission</title>
	
	        <para>After the connection, a user is ready to submit Jobs. The
	        <emphasis role="bold">Authentication interface is no longer
	        used</emphasis> for this connected user. <xref linkend="jobSubmission">
	            The job submission
	          </xref> shows what happens when the Scheduler received a new Job to
	        schedule. <figure id="jobSubmission">
	            <title>A job submission</title>
	
	            <mediaobject>
	              <imageobject>
	                <imagedata align="center"
	                           fileref="scheduler/pics/core/jobSubmission.jpg"
	                           format="JPG" />
	              </imageobject>
	            </mediaobject>
	          </figure> <orderedlist>
	            <listitem>
	              <para>First, the user submits a Job using his <emphasis
	              role="bold">UserSchedulerInterface</emphasis> retrieved by the
	              <emphasis role="bold">logAsUser</emphasis> method.
	              <programlisting lang="java">// connecting to the scheduler
	SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/SCHEDULER_OBJECT_NAME");
	// checking username and password
	UserSchedulerInterface scheduler = auth.logAsUser("username", "password");
	// submitting a new job
	scheduler.submit(job);</programlisting></para>
	            </listitem>
	
	            <listitem>
	              <para>The Scheduler Front-end verifies the integrity of the Job,
	              and builds it in order to be ready to be managed by the
	              Scheduler Core. If there is a problem, an exception is thrown
	              explaining what is the cause.</para>
	            </listitem>
	
	            <listitem>
	              <para>Finally, the Job is transmitted to the Core for
	              scheduling.</para>
	            </listitem>
	          </orderedlist></para>
	      </sect3>
	    </sect2>
	
	    <sect2 id="admin_interface">
	      <title>Administrator Interface</title>
	
	      <para></para>
	
	      <sect3 id="communicator">
	        <title>Communicator</title>
	
	        <para></para>
	      </sect3>
	    </sect2>
	</sect2>
	
    
  </sect1>

  <sect1 id="scheduler_extension">
    <title>Extend the Scheduler</title>

    <sect2 id="add_policy">
      <title>How to add a new policy</title>

      <para>Create and add a new scheduling policy remains a very simple work.
      You just have to implements the
      <emphasis>org.objectweb.proactive.extra.scheduler.policy.PolicyInterface</emphasis>
      and start a new Scheduler with this new policy, or dynamically change it
      if the scheduler is already running.</para>

      <para>Here's the interface which must be implemented. The default
      implementation <emphasis>PriorityPolicy</emphasis> in the same
      package:</para>

      <programlisting lang="java">public interface PolicyInterface extends Serializable {
    //method to implement
    Vector&lt;EligibleTaskDescriptor&gt; getOrderedTasks(List&lt;JobDescriptor&gt; jobs);  
}</programlisting>

      <para>This method returns all the Tasks that have to be scheduled. The
      Tasks must be in the desired scheduling order. The first task to be
      scheduled will be the first in the returned Vector.</para>

      <para>The parameters is a list of running and pendingJobs, which contain
      Tasks to be scheduled. The only thing to do is <emphasis>extract the
      task</emphasis>, <emphasis>re-order them</emphasis> and <emphasis>put
      them in a vector</emphasis>. Let's see the default implementation of the
      ProActive Scheduler policy to illustrate it:</para>

      <programlisting lang="java">public class PriorityPolicy implements PolicyInterface {

    /**
     * This method return the tasks using FIFO policy according to the jobs priorities.
     *
     * @see org.objectweb.proactive.extra.scheduler.policy.PolicyInterface#getReadyTasks(java.util.List)
     */
    @Override
    public Vector&lt;EligibleTaskDescriptor&gt; getOrderedTasks(
        List&lt;JobDescriptor&gt; jobs) {
        Vector&lt;EligibleTaskDescriptor&gt; toReturn = new Vector&lt;EligibleTaskDescriptor&gt;();
        //sort jobs by priority
        Collections.sort(jobs);

        for (JobDescriptor lj : jobs) {
            toReturn.addAll(lj.getEligibleTasks());
        }

        return toReturn;
    }
}</programlisting>

      <para>By default, the Jobs knows how to be sorted regarding their
      priority. But it is simple to create a Comparator and sort the Jobs with
      it.</para>
    </sect2>
  </sect1>
    </sect1>
<sect1 id="Resource_Manager">
    <title>Resource Manager</title>
    <sect2 id="Role">
	<title>Role</title>
	<para>As Scheduler manages pool of jobs to execute, Resource manager is in charge of supplying Scheduler 
	in resources : ProActive nodes. Resource Manager (RM) takes benefits of the ProActive library, 
	so it can handle resources from LAN, on cluster, on P2P desktop Grids, or on Internet Grids. 
	ResourceManager provides scheduler in nodes, according to criteria of the task to execute on it 
	(operating system, dynamic libraries, memory...).
	Its main functions are :</para>
	<itemizedlist>
	          <listitem>Creation, acquisition and removal of ProActive nodes.</listitem>
		      <listitem>Supplying nodes to scheduler for tasks executions, Scheduler can ask nodes that verify criteria, 
		      these criteria are defined in a selection script.</listitem>
		      <listitem>Maintaining and monitoring its list of node resources, and 
		      manage states of its handled nodes (free, busy, down...).</listitem>
	</itemizedlist>
	</sect2>
    <sect2 id="architecture">
	<title>Resource Manager architecture</title>
	<para>Resource Manager is made of five components :</para>
		<itemizedlist>
	          <listitem><emphasis>User</emphasis> Resource Manager's frontend for the Scheduler, 
	          this component provides for scheduler an entry to get and give back nodes.</listitem>
	          <listitem><emphasis>Admin</emphasis> Frontend for RM's administrator, provides administrator actions; add and remove nodes,
	          add and remove different node sources, shutting down the Resource manager.</listitem>
	          <listitem><emphasis>Core</emphasis> Main component, selects and gives nodes to scheduler,
	          maintains different nodes states for each node, and receive new available nodes acquired by Node Sources.</listitem>
	          <listitem><emphasis>Monitoring component</emphasis> Resource manager can have monitors connected to it.
	          Monitors are external programs (such as monitor GUI) that want to be informed about RM current activity;  
	          numbers of nodes and their availability for example.
	          The Monitoring component is in charge of throwing RM information to its monitors.</listitem>	          
	          <listitem><emphasis>Node Sources</emphasis> Resource manager can handle nodes coming from heterogeneous environments,
	          a Node source component is in charge of nodes acquisition, deployment and monitoring for a dedicated infrastructure. 
	          It means we can have a Node source which manages nodes deployed by a ProActive descriptor, 
	          one for nodes acquired from a Peer to peer infrastructure, and another for nodes acquired from a cluster.</listitem> 
		</itemizedlist>
	</sect2>
<sect2 id="nodes_sources">
	<title>Static Node Source and Dynamic Node Source</title>
		<para>Node Sources objects are aimed to acquire nodes for the RM, there are two kinds of Node Sources :</para>
		<itemizedlist>
	          <listitem><emphasis>Static Node Source</emphasis> defined for deploying and acquiring nodes by a ProActive descriptor. 
	          All nodes handled by the source are kept permanently by the Resource Manager, 
	          i.e until the termination of the RM or if Administrator ask to remove some of them.</listitem>
			<listitem><emphasis>Dynamic Node Source</emphasis> designed to acquire nodes 
			from an infrastructure which can provide nodes just for a limited time. So this Node Source get a node from a specific infrastructure, 
			keep it during a defined time. When this keeping time is elapsed, dynamic node source remove the node from the RM and give back node to its infrastructure. 
			A dynamic node source have three main parameters :
			<para>Max number of nodes : number of nodes that dynamic Node Source has to get from its corresponding infrastructure. 
			The dynamic node source tries to acquire this number of node source, but its infrastructure may not be able to provide as many nodes.
			So this is the number of acquired nodes that Dynamic Node Source tries to reach.</para>
			<para>Time to release(TTR) : keeping duration of an acquired node. when this keeping duration is reached by a node, dynamic node source releases it.</para>
			<para>Nice time : After a node release, time to wait for the dynamic node source before trying to get a new node from its infrastructure. 
			After each node release, dynamic node source waits "nice time", and after tries to acquire a new node.</para></listitem>
			</itemizedlist>
	</sect2>
 <sect2 id="nodes_states">
	<title>nodes states</title>
		<para>Resource Manager has to maintain states of its handled nodes, here the different nodes states : </para>
		<itemizedlist>
	          <listitem><emphasis>Free</emphasis> Node is available, and there is no task launched on it. 
	          Node can be supplied to a scheduler.</listitem>
	          <listitem><emphasis>Busy</emphasis> Node has been given to scheduler and a task is executed on it.</listitem>
			  <listitem><emphasis>To be released</emphasis> Node is busy, and administrator or its (dynamic) Node Source has asked to remove the node.
			  So the node will be removed from RM after task's end.</listitem>
			  <listitem><emphasis>Down</emphasis> Node has a problem (unreachable, fallen...) and can't execute tasks anymore.</listitem>
		</itemizedlist>			  	          
	</sect2>
 <sect2 id="RM_start">
	<title>Starting the Resource Manager</title>
	<para>To start Resource Manager, run the RMlauncher.sh script in scripts/scheduler directory. 
	Without arguments, Resource Manager will start and create four ProActive nodes on the local host.
	RMlauncher.sh can be started with 1 optional argument :</para>
	<itemizedlist> 
		<listitem>Path of a ProActive descriptor file (for example : ProActive/descriptors/Workers.xml).
		 Descriptor is deployed and nodes added to the RM by a static Node Source at the RM's startup.
		</listitem>
    </itemizedlist>
 	</sect2>
  </sect1>
</chapter>