<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="../viewDocbook.css"?>
<chapter id="ProActive_Scheduler">
  <title>ProActive Grid Scheduler</title>

  <sect1 id="overview">
    <title>Overview</title>

    <para>The execution of parallel tasks on a pool of distributed resources,
    such as network of desktop or clusters, requires a main system for
    managing resources and handling task execution: <emphasis role="bold">a
    batch scheduler</emphasis>. A batch scheduler provides an abstraction of
    resources to users. Users submit jobs containing tasks to the <emphasis
    role="bold">scheduler</emphasis>, who is in charge of executing these
    tasks on the resources. A <emphasis role="bold">scheduler</emphasis>
    allows several users to share a same pool of resources and also to manage
    all issues related to distributed environment, such as faulted
    resources.</para>

    <para>In this chapter we present a ProActive based Scheduler which offers:
    <emphasis role="bold">a JAVA programming API</emphasis>, <emphasis
    role="bold">a shell based command submitter</emphasis>, <emphasis
    role="bold">and a graphical user or admin interface</emphasis> (Eclipse
    Plugin, see <xref linkend="Scheduler_Eclipse_Plugin" />) which can be
    plugged on the scheduler main application.</para>

    <para>In the rest of this chapter, we will expose how the scheduler works,
    what policies govern the job management, how to create a job and how to
    get the jobs and the nodes state using either the shell communicator or
    the GUI.</para>
  </sect1>

  <sect1 id="scheduler_concept">
    <title>Scheduler Concept</title>

    <sect2 id="what_is_job">
      <title>What is a Job ?</title>

      <para>A <emphasis role="bold">Job</emphasis> is the entity to be given
      to the scheduler, and is composed of one or more <emphasis
      role="bold">Tasks</emphasis>. A Job can have one of the following types
      : <itemizedlist>
          <listitem>
            <para><emphasis role="bold">TASKSFLOW</emphasis>, represents a Job
            that contains a bag of Tasks, which can be execute in parallel or
            according to a dependence tree. The Tasks inside this Job type can
            be either Java or Native. </para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">PROACTIVE</emphasis>, represents a Job
            that contains a ProActive application (only one ProActive Task).
            Its execution will start with a given predefined number of nodes
            on which you can start the computation. This kind of Job requires
            the usage of the ProActive API, in order to use the given
            nodes.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">PARAMETER SWEEPING</emphasis>, is a
            Job that represents multiple executions of one type of Task with
            different given parameters. It is typically executed in parallel.
            The Tasks inside this job can also be Java or Native. </para>
          </listitem>
        </itemizedlist></para>

      <para>A finished Job contains a result, which in turn contains all of
      its tasks' results or only those marked as <emphasis
      role="bold">precious</emphasis>. In the event of a failure, the finished
      Job contains the responsible Exceptions. Further detailes on how to
      create a Job and the different options can be foun in: <xref
      linkend="job_creation" />.</para>
    </sect2>

    <sect2 id="what_is_task">
      <title>What is a Task ?</title>

      <para>The <emphasis role="bold">Task</emphasis> is the smallest
      schedulable entity. It is included in a <emphasis
      role="bold">Job</emphasis> (see <xref linkend="what_is_job" />) and will
      be executed in accordance with the scheduling policy (see <xref
      linkend="scheduling_policy" />), and with the available
      resources.</para>

      <para>There are three types of Tasks : <itemizedlist>
          <listitem>
            <para><emphasis role="bold">JAVA</emphasis>, its execution can be
            a java class extending the 'JavaExecutable' class. </para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">NATIVE</emphasis>, its execution can
            be any user program specified by a (shell) command line.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">PROACTIVE</emphasis>, its execution
            can be any java class extending the 'ProActiveExecutable' class.
            Coding this last one requires a knowledge base on the use of
            ProActive.</para>
          </listitem>
        </itemizedlist></para>

      <para>During its execution, a Task may crash due to host failure or user
      bugs. A Task can re-started a parameterizable number of time.</para>

      <para>A Task may optionally be accompanied by 3 kinds of scripts
      (preScript, postScript and selectionScript) whose explanations are
      provided in the documentation of resource manager (<xref
      linkend="resources_manager" />).</para>

      <para>Dependencies between Tasks is also possible, and is detailed in
      <xref linkend="how_dependences" />.</para>

      <para>The result of a Task can be marked as <emphasis
      role="bold">precious</emphasis>, to make it available in the Job
      Result.</para>
    </sect2>

    <sect2 id="how_dependences">
      <title>What can be done with dependencies ?</title>

      <para>Dependencies can be set between Tasks in a TaskFlow Job. It
      provides a way to execute your tasks in an ordered fashion, but also to
      forward the results of a task to another one. An example is better than
      a thousand words :</para>

      <figure id="scheduler_job_img">
        <title>Task flow job example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="scheduler/images/core/schedulerJob.jpg"
                       format="JPG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In this example we made an 8 Task Job (where the Job's type is
      TaskFlow). As you can see, Task 4 depends on Task 1, Task 5 depends on
      Tasks 2 and 3, etc... In other words, Task 4 will wait for Task 1 to
      finish before starting, Task 5 will wait for Task 2
      <emphasis>AND</emphasis> 3, etc... In addition, the order in which you
      specify that Task 5 depends of Task 2 and 3 is very important. Indeed,
      if you set the list of dependencies for Task 5 as : 2 then 3, the result
      of these two task will be given to Task 5 in this order. (TODO missing
      example comparing both cases )</para>

      <para>As shown in the following lines, the given array of TaskResults
      (<emphasis>results</emphasis>) will be an array of two results
      (TaskResult 2 and 3) in this order. Therefore you can use them to
      perform Task 5 process. <programlisting lang="java">@Override
public Object execute(TaskResult... results) throws Throwable {
    //user code for task 5...
}</programlisting></para>

      <para>We will see how to define the dependencies and the order when we
      create our first job in <xref linkend="job_creation" />. In this
      example, result of Task 7 and 8 could be <emphasis
      role="bold">precious</emphasis>, which means that you can retrieve
      easily this two results.</para>
    </sect2>

    <sect2 id="scheduling_policy">
      <title>Scheduling Policy</title>

      <para><emphasis role="bold">By default</emphasis>, the scheduler
      schedules tasks according to the default <emphasis role="bold">FIFO
      (First In First Out) with job priority</emphasis> policy. We'll see
      later that the policy can be changed by implementing an interface.
      (<xref linkend="add_policy" />)</para>
    </sect2>
  </sect1>

  <sect1 id="scheduler_architecture">
    <title>Scheduler Architecture</title>

    <sect2 id="Scheduler_Global_Architecture">
      <title>Scheduler Global Architecture</title>

      <para>The Scheduler Service is the result of a collaboration between 2
      entities (the Scheduler and the Resource Manager) each one of them has
      its own functionality.</para>

      <para>The Scheduler is the main entity and is a non GUI daemon which is
      connected to the Resources Manager. It is in charge of scheduling
      submitted Jobs, in accordance with the scheduling policy.</para>

      <para>In order to launch Jobs, the Scheduler must obtain nodes
      (resources) from the Resources Manager. As describe below (<xref
      linkend="scheduler2entities" />), the user interacts only with the
      Scheduler entity and the managed resources can be simple or complex
      (TODO dont understand "and the managed resources can be simpel or
      complex").</para>

      <figure id="scheduler2entities">
        <title>The Scheduler Entities</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="scheduler/images/core/scheduler2entities.jpg"
                       format="JPG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para><emphasis role="bold">In this section</emphasis> we will explain
      how the <emphasis role="bold">scheduler entity works and how it can be
      used.</emphasis></para>
    </sect2>

    <sect2 id="Scheduler_entity_Architecture">
      <title>Scheduler Entity Architecture</title>

      <para><xref linkend="schedulerEntity">
          The architecture of the scheduler
        </xref> is built around 3 Active Objects : <itemizedlist>
          <listitem>
            <para><emphasis role="bold">The Authentication
            interface</emphasis> which is the first object that the user may
            have to contact. It is in charge of authenticatubg the user and
            allowing him access (or not) to the Scheduler. The authentication
            security system can interact with files or LDAP.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">The Front-end</emphasis> which is the
            interface returned by the Authentication Interface and allows
            interaction with the scheduler. This interface allows users to
            submit jobs, get scheduling state, retrieves job result
            etc...</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">The Core</emphasis> which is the main
            entity of the Scheduler. It is in charge of scheduling Jobs
            according with the policy (which is FIFO by default), retrieve
            scheduling events to the user and make storages in data base (TODO
            link reference to details on data base).</para>
          </listitem>
        </itemizedlist></para>

      <para>Users cannot interact directly with the Scheduler Core and must
      use the Front-end gateway.</para>

      <figure id="schedulerEntity">
        <title>The Scheduler Entity</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="scheduler/images/core/schedulerEntity.jpg"
                       format="JPG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
  </sect1>

  <sect1 id="scheduler_API">
    <title>Scheduler API and Usecase</title>

    <sect2 id="start_scheduler">
      <title>Starting the scheduler</title>

      <para>To start a local scheduler, run the
      <emphasis>scheduler.sh</emphasis> script in scripts/scheduler directory.
      Without arguments, the scheduler will start on the local host and create
      its own Resources Manager.</para>

      <para><emphasis>scheduler.sh</emphasis> can be started with 1 optional
      argument : <itemizedlist>
          <listitem>
            <para>The URL of a resources manager already started. (ie:
            <emphasis role="bold">//hostname/</emphasis>) </para>
          </listitem>
        </itemizedlist></para>

      <para>You can also start the scheduler using the java API. Supposing
      that a Resources Manager is already started (see Resource Manager
      documentation <xref linkend="resources_manager" />), this can be done in
      the following way:</para>

      <programlisting lang="java">AdminScheduler.createScheduler(
    LocalSchedulerExample.class.getResource("login.cfg").getFile(),
                LocalSchedulerExample.class.getResource("groups.cfg").getFile(),
                rm,
                "org.objectweb.proactive.extra.scheduler.policy.PriorityPolicy");</programlisting>

      <para>Arguments are respectively : <orderedlist>
          <listitem>
            <para><emphasis>loginFile</emphasis> : A file describing the users
            and passwords authorized to connect to the scheduler.</para>
          </listitem>

          <listitem>
            <para><emphasis>groupFile</emphasis> : A file describing the group
            on which each user belongs. These groups will be used to identify
            admin or user rights. </para>
          </listitem>

          <listitem>
            <para><emphasis>rm</emphasis> : A reference on an already started
            Resources Manager instance. </para>
          </listitem>

          <listitem>
            <para><emphasis>policyFullClassName</emphasis> : The scheduling
            policy to use, as a string representing the complete name of the
            class. </para>
          </listitem>
        </orderedlist></para>

      <para>Another way is to start the scheduler AND connect an administrator
      at the same time :</para>

      <programlisting lang="java">AdminScheduler.createScheduler(
   LocalSchedulerExample.class.getResource("login.cfg").getFile(),
                LocalSchedulerExample.class.getResource("groups.cfg").getFile(),
                "login",
                "password",
                rm,
                "org.objectweb.proactive.extra.scheduler.policy.PriorityPolicy");</programlisting>

      <para>Where arguments are the same plus a <emphasis>login</emphasis> and
      a <emphasis>password</emphasis> as a string. The user must be in the
      login file and his group must be admin in the group file.</para>
    </sect2>

    <sect2 id="task_creation">
      <title>Task Creation</title>

      <para></para>
    </sect2>

    <sect2 id="job_creation">
      <title>Job Creation</title>
      
      <para></para>
    </sect2>

    <sect2 id="user_interface">
      <title>User Interface</title>
		
      <sect3 id="User_Connection">
        <title>User Connection</title>

        <para>A user can connect to the Scheduler only if he/she is known.
        That's the goal of the authentication interface which is able to
        authenticate users. <xref linkend="userConnection">
            The user connection
          </xref> shows how the Scheduler connects a user. <figure
            id="userConnection">
            <title>A user connection</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center"
                           fileref="scheduler/images/core/userConnection.jpg"
                           format="JPG" />
              </imageobject>
            </mediaobject>
          </figure> <orderedlist>
            <listitem>
              <para>First of all, a user tries to join the authentication
              interface using the <emphasis
              role="bold">SchedulerConnection.join(...)</emphasis> static
              method. </para>

              <programlisting>SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/SCHEDULER_OBJECT_NAME");</programlisting>

              <para> Then, with the <emphasis
              role="bold">SchedulerAuthenticationInterface</emphasis>, users
              can be connected as user or administrator roles using the
              <emphasis role="bold">logAsUser</emphasis> or <emphasis
              role="bold">logAsAdmin</emphasis> methods. </para>

              <programlisting>UserSchedulerInterface scheduler = auth.logAsUser("username", "password");
// OR
AdminSchedulerInterface scheduler = auth.logAsAdmin("adminname", "password");</programlisting>
            </listitem>

            <listitem>
              <para>Next, the authentication object checks the users rights
              and wether the user is authorized to connect the scheduler. If
              not, an exception will be thrown.</para>
            </listitem>

            <listitem>
              <para>Once connected, the authentication object sends the right
              and username/password to the scheduler front-end which will be
              able to authenticate user on its own.</para>
            </listitem>

            <listitem>
              <para>If nothing goes wrong, the authentication interface will
              return a <emphasis
              role="bold">AdminSchedulerInterface</emphasis> which is in fact
              a direct link to the <emphasis
              role="bold">Front-end</emphasis>.</para>
            </listitem>

            <listitem>
              <para>The user is now able to interact with the Scheduler using
              the returned interface.</para>
            </listitem>
          </orderedlist></para>
      </sect3>

      <sect3 id="Job_submission">
        <title>Job Submission</title>

        <para>After the connection, a user is ready to submit Jobs. The
        <emphasis role="bold">Authentication interface is no longer
        used</emphasis> for this connected user. <xref linkend="jobSubmission">
            The job submission
          </xref> shows what happens when the Scheduler received a new Job to
        schedule. <figure id="jobSubmission">
            <title>A job submission</title>

            <mediaobject>
              <imageobject>
                <imagedata align="center"
                           fileref="scheduler/images/core/jobSubmission.jpg"
                           format="JPG" />
              </imageobject>
            </mediaobject>
          </figure> <orderedlist>
            <listitem>
              <para>First, the user submits a Job using his <emphasis
              role="bold">UserSchedulerInterface</emphasis> retrieved by the
              <emphasis role="bold">logAsUser</emphasis> method.
              <programlisting lang="java">// connecting to the scheduler
SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/SCHEDULER_OBJECT_NAME");
// checking username and password
UserSchedulerInterface scheduler = auth.logAsUser("username", "password");
// submitting a new job
scheduler.submit(job);</programlisting></para>
            </listitem>

            <listitem>
              <para>The Scheduler Front-end verifies the integrity of the Job,
              and builds it in order to be ready to be managed by the
              Scheduler Core. If there is a problem, an exception is thrown
              explaining what is the cause.</para>
            </listitem>

            <listitem>
              <para>Finally, the Job is transmitted to the Core for
              scheduling.</para>
            </listitem>
          </orderedlist></para>
      </sect3>
    </sect2>

    <sect2 id="admin_interface">
      <title>Administrator Interface</title>

      <para></para>

      <sect3 id="communicator">
        <title>Communicator</title>

        <para></para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="scheduler_extension">
    <title>Extend the Scheduler</title>

    <sect2 id="add_policy">
      <title>How to add a new policy</title>

      <para>Create and add a new scheduling policy remains a very simple work.
      You just have to implements the
      <emphasis>org.objectweb.proactive.extra.scheduler.policy.PolicyInterface</emphasis>
      and start a new Scheduler with this new policy, or dynamically change it
      if the scheduler is already running.</para>

      <para>Here's the interface which must be implemented. The default
      implementation <emphasis>PriorityPolicy</emphasis> in the same
      package:</para>

      <programlisting lang="java">public interface PolicyInterface extends Serializable {
    //method to implement
    Vector&lt;EligibleTaskDescriptor&gt; getOrderedTasks(List&lt;JobDescriptor&gt; jobs);  
}</programlisting>

      <para>This method returns all the Tasks that have to be scheduled. The
      Tasks must be in the desired scheduling order. The first task to be
      scheduled will be the first in the returned Vector.</para>

      <para>The parameters is a list of running and pendingJobs, which contain
      Tasks to be scheduled. The only thing to do is <emphasis>extract the
      task</emphasis>, <emphasis>re-order them</emphasis> and <emphasis>put
      them in a vector</emphasis>. Let's see the default implementation of the
      ProActive Scheduler policy to illustrate it:</para>

      <programlisting lang="java">public class PriorityPolicy implements PolicyInterface {

    /**
     * This method return the tasks using FIFO policy according to the jobs priorities.
     *
     * @see org.objectweb.proactive.extra.scheduler.policy.PolicyInterface#getReadyTasks(java.util.List)
     */
    @Override
    public Vector&lt;EligibleTaskDescriptor&gt; getOrderedTasks(
        List&lt;JobDescriptor&gt; jobs) {
        Vector&lt;EligibleTaskDescriptor&gt; toReturn = new Vector&lt;EligibleTaskDescriptor&gt;();
        //sort jobs by priority
        Collections.sort(jobs);

        for (JobDescriptor lj : jobs) {
            toReturn.addAll(lj.getEligibleTasks());
        }

        return toReturn;
    }
}</programlisting>

      <para>By default, the Jobs knows how to be sorted regarding their
      priority. But it is simple to create a Comparator and sort the Jobs with
      it.</para>
    </sect2>
  </sect1>
</chapter>