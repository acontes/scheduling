	 </sect1>
			<title> GCM Components Tutorial </title>

	<sect2> 
		<title>Introduction</title>
		<para>
			This document introduces the ProActive/GCM implementation
			 and presents a short user guide which explains how to use it.
		</para>
	</sect2>
	<sect2>
		<title>	 Key features of ProActive GCM Implementation </title> 
			 <itemizedlist>
			 <listitem>	 <para>Creation/usage of primitive and composite components</para></listitem>
			 <listitem><para> Client, server and non-functional interfaces </para>
					<para>In addition to single/collection cardinalities,
				 the ProActive/GCM implementation also provides multicast and gathercast cardinalities.</para>
				 </listitem> 
			<listitem><para>ADL support </para></listitem> 
			<listitem><para>Deployment descriptor files describing components deployment</para>
						<para>
							Several	components in an assembly can be distributed on 
							different nodes on several computers using transparent remote communication.
							Such an arhitecture is presented in the figure below. 
						</para>
						
Figure 1 Component with inner component distributed


		</listitem>
 Primitive and composite components
As described in the GCM [1] specification, a component is a software module with a standardized description of what it needs and provides. 
The GCM component  model is hierarchical, so components can be either primitives or composites. A composite can contain one or many inner components (primitive or composite). Non functional and functional interfaces can be defined. 
ProActive/GCM provides the following defaults non functional interfaces thanks to the following controllers: binding-controller, name-controller, lifecycle-controller, super-controller, content-controller as specified by the GCM specification. In addition, there are other specific controllers in our implementation, namely migration-controller, multicast-controller, gathercast-controller and component-parameters-controller. In the current implementation, the non functional part of a component can also be customized and extended.
Furthermore, ProActive/GCM allows developer to define what a component needs and provides with, respectively, its client and server interfaces. These interfaces are defined by Java interfaces like non functional. 
In the following subsection, we will describe in more details collective interfaces.
 Collective Interfaces
By using collective interfaces, component systems designers are able to specify parallelism, synchronization and data distribution. Collective communications refer to multipoint interactions between software entities. Collective interfaces may have two kinds of cardinalities, so-called multicast and gathercast.
A collective interface gives the possibility to manage a group of interfaces as a single entity. This entity is itself an interface and viewed likewise. The role and usage of multicast and gathercast interfaces are complementary.
 Multicast Interfaces
Multicast interfaces are used for parallel invocations, parameters dispatching and results gathering. 
A multicast interface is an abstraction for 1-to-n communications. When a single invocation is transformed into a set of invocations, these invocations are forwarded to a set of connected server interfaces. Both the propagation of the invocation and the distribution of the invocation parameters are customizable (through Java annotations in the Java interfaces definitions). The result of an invocation, if it isn’t a void return type, on a multicast interface will be a list of results wherever applicable.
If some parameters in a given method of a multicast interface are lists of values, these values can be distributed in various ways through method invocations to the server interfaces connected to the multicast interface (see Figure 2). The default behaviour –namely broadcast – is to send the same parameters to each of the connected server interfaces (see Figure 2.a). In case some parameters are list of values, copies of the lists are sent to each receiver. However, similar to what SPMD programming model offers, it may be adequate to strip some of the parameters so that the bounded components will work on different data. In MPI, for instance, this can be explicitly specified by stripping a data buffer and using the scatter primitive. In this case, you will use scatter or one-to-one dispatch mode (see Figure 2.b).

Figure 2:    a) broadcast of parameters    b) scatter of parameters

GCM also specify result aggregation, but in the current state of the ProActive/GCM implementation the only available behaviour is the aggregation of results as list.
Gathercast interfaces
Gathercast interfaces are used for synchronization, parameter gathering and result dispatching.
A gathercast interface is an abstraction for n-to-1 communications. It handles data aggregation for invocation parameters, as well as process coordination. It gathers incoming data, and can also coordinate incoming invocations before continuing the invocation flow, by defining synchronization barriers.
Invocation parameters are simply gathered into lists of parameters as showed in the Figure 3.

Figure 3 Invocation parameter with a gathercast interface

The following table summarizes the possible distribution policies based on parameters and return type.

ADL file
The Architecture Description Language (ADL) is used to define component type, configure and deploy component systems. You can define component and interface types, describe component membrane, and declare on which Virtual Node and you want deploy each component. The architecture of the system is described in one or many XML file.
Components are defined in files ending with the .fractal extension. The syntax of the document is validated against a DTD retrieved from the classpath  classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd . This DTD extends the Fractal ADL DTD and the implementation reuses and extends the FractalADL project [2].  You can find tutorial and document on ADL in this project1. The GCM specification [1] adds some keywords in the ADL definition which are supported by ProActive/GCM. The following section illustrates how you can use these files to describe a component assembly, and how you can use it with the Fractal/GCM API.
Components User Guide
Along this short user guide, we will show how to use concretely the features described previously: how to create primitive and composite components, how to assemble them using Fractal/GCM API and Fractal API files, how to interoperate with component, and then how to describe the deployment of components using deployment descriptor file.
Creating and using components in a programmatic way
The first step of this user guide explains how to create a single primitive component. Next, we will use an assembly of two primitive components in a composite one.
 The fist component
We want to create a primitive component, called PrimitiveComputer. It exposes one server interface called computer-itf which provides the two following methods: compute and doNothing. To do that, we need to write the two following classes.
Interface ComputeItf
package org.objectweb.proactive.examples.components.userguide.primitive;

public interface ComputeItf {
    int compute(int a);
    void doNothing ();
}
Class PrimitiveComputer
package org.objectweb.proactive.examples.components.userguide.primitive;

import java.io.Serializable;


public class PrimitiveComputer implements ComputeItf, Serializable {
    public PrimitiveComputer() {
    }

    public int compute(int a) {
        int result = a * 2;
        System.err.println(" PrimitiveComputer-->compute(" +a +"):"+
            result);
        return result;
    }

    public void doNothing() {
        System.err.println(" PrimitiveComputer-->doNothing()");
    }
}


Now, we will discuss on the different ways to use this component.
First, we must create the component with the ProActive/GCM framework. Two kinds of component instantiation are shown. In the first case, we can do all these steps in the application. However, in the second case, we will show how we can use the ADL files to simplify the application and create it in a simpler way.
In order to illustrate these different ways, a new class, Main, containing the possible main method of our application (see the source code below), is written. In this main method, four different methods are called and will be described in the following parts of this document, launchFirstPrimitive, launchWithoutADL, launchWithADL, and finally the last launchAndDeployWithADL. To launch this class, you must put in your classpath all the libraries contained in the lib directory and subdirectories and the ProActive jar. And finally, you must set the three Java properties (fractal.provider, java.security.policy, log4j.configuration) as shown in the command line:
java 
  -Dfractal.provider=org.objectweb.proactive.core.component.Fractive 
  -Djava.security.policy=file:<change_this_part>/
                              ProActive/scripts/proactive.java.policy 
  -Dlog4j.configuration=file:<change_this_part>/
                             ProActive/scripts/proactive-log4j 
  org.objectweb.proactive.examples.components.userguide.Main
Class Main
package org.objectweb.proactive.examples.components.userguide;

import java.util.HashMap;
import java.util.Map;

import org.objectweb.fractal.adl.Factory;
import org.objectweb.fractal.api.Component;
import org.objectweb.fractal.api.factory.GenericFactory;
import org.objectweb.fractal.api.type.ComponentType;
import org.objectweb.fractal.api.type.InterfaceType;
import org.objectweb.fractal.api.type.TypeFactory;
import org.objectweb.fractal.util.Fractal;
import org.objectweb.proactive.ProActive;
import org.objectweb.proactive.core.component.Constants;
import org.objectweb.proactive.core.component.ContentDescription;
import org.objectweb.proactive.core.component.ControllerDescription;
import org.objectweb.proactive.core.descriptor.data.ProActiveDescriptor;
import org.objectweb.proactive.examples.components.userguide.primitive.ComputeItf;
import org.objectweb.proactive.examples.components.userguide.primitive.PrimitiveComputer;
import org.objectweb.proactive.examples.components.userguide.primitive.PrimitiveMaster;

public class Main {
    public static void main(String[] args) {
        System.out.println("Launch primitive component example");
        //Main.launchFirstPrimitive();
        System.out.println("Launch component assembly example");
        //Main.launchWithoutADL();
        System.out.println("Launch component assembly example with ADL");
        //Main.launchWithADL();
        System.out.println(
            "Launch and deploy component assembly example with ADL");
        //Main.launchAndDeployWithADL();
    }
}

If we want to create and call components in a standard Java application, we need to use the GCM API [1]. The method launchFirstPrimitive shows all the steps to create and use our first primitive component. Firstly, define the type of the component. Secondly, create component using a factory. Thirdly, start the component. And finally, retrieve the component’s interface and use it as a standard Java object to access our component.
launchFirstPrimitive Method
private static void launchFirstPrimitive() {
    try {
        Component boot = Fractal.getBootstrapComponent();
        TypeFactory typeFact = Fractal.getTypeFactory(boot);
        GenericFactory genericFact = Fractal.getGenericFactory(boot);
        Component primitiveComputer = null;

        // type of PrimitiveComputer component
        ComponentType computerType = typeFact.createFcType(new InterfaceType[]{
                    typeFact.createFcItfType("compute-itf",
                        ComputeItf.class.getName(), false, false, false)
                });

        // component creation
        primitiveComputer = genericFact.newFcInstance(computerType,
                new ControllerDescription("root", Constants.PRIMITIVE),
                new ContentDescription(PrimitiveComputer.class.getName()));

        // start PrimitiveComputer component
        Fractal.getLifeCycleController(primitiveComputer).startFc();

        // get the compute-itf interface
        ComputeItf itf = ((ComputeItf) primitiveComputer.getFcInterface(
                "compute-itf"));

        // call component
        itf.doNothing();
        int result = itf.compute(5);
        System.out.println("Result of computation whith 5 is: " + result); //display 10
    } catch (Exception e) {
        e.printStackTrace();
    }
}

Uncomment the line calling the launchFirstPrimitive method in the main method, launch it and see below the expected output. The first lines are ProActive log, and at the end, information printed in the component and in the Main class is visible.
launchPrimitive Output
Launch primitive component example
 --> This ClassFileServer is reading resources from classpath 2026 
Created a new registry on port 1099 
rmi://crusoe.inria.fr:1099/Node1177054138 successfully bound in registry at rmi://crusoe.inria.fr:1099/Node1177054138 
Generating class : pa.stub.org.objectweb.proactive.examples.components.userguide.primitive._StubPrimitiveComputer 
 PrimitiveComputer-->doNothing()
 PrimitiveComputer-->compute(5): 10
Result of computation whith 5 is: 10
Define an assembly
Now that we succeeded to create and use a primitive component, we will learn how to use it in a component assembly. First of all, we want use the previous shown primitive component with another primitive component to explain how to define, implement and use client interfaces. Moreover, in order to use composite component, we put the two primitive components in a composite. The Figure 4 shows this assembly. 

Figure 4 Example assembly
To implement this assembly we need one more class, PrimitiveMaster. This class implements the following Java interfaces: java.lang.Runnable and moreover the BindindController to allow binding on the compute-itf client interface. In the run method we put the call to the PrimitiveComputer component, we don’t need to retrieve the compute-itf interface since the assembling it’s done in the launchWithoutADL method or in the following part using ADL. 
Class PrimitiveMaster
package org.objectweb.proactive.examples.components.userguide.primitive;

import java.io.Serializable;

import org.objectweb.fractal.api.NoSuchInterfaceException;
import org.objectweb.fractal.api.control.BindingController;
import org.objectweb.fractal.api.control.IllegalBindingException;
import org.objectweb.fractal.api.control.IllegalLifeCycleException;


public class PrimitiveMaster implements Runnable, Serializable,
    BindingController {
    private static final String COMPUTER_CLIENT_ITF = "compute-itf";
    private ComputeItf computer;

    public PrimitiveMaster() {
    }

    public void run() {
        computer.doNothing();
        int result = computer.compute(5);
        System.out.println(" PrimitiveMaster-->run(): " +
            "Result of computation whith 5 is: " + result); //display 10
    }

    //BINDING CONTROLLER implementation
    public void bindFc(String myClientItf, Object serverItf)
        throws NoSuchInterfaceException, IllegalBindingException,
            IllegalLifeCycleException {
        if (myClientItf.equals(COMPUTER_CLIENT_ITF)) {
            computer = (ComputeItf) serverItf;
        }
    }

    public String[] listFc() {
        return new String[] { COMPUTER_CLIENT_ITF };
    }

    public Object lookupFc(String itf) throws NoSuchInterfaceException {
        if (itf.equals(COMPUTER_CLIENT_ITF)) {
            return computer;
        }
        return null;
    }

    public void unbindFc(String itf)
        throws NoSuchInterfaceException, IllegalBindingException,
            IllegalLifeCycleException {
        if (itf.equals(COMPUTER_CLIENT_ITF)) {
            computer = null;
        }
    }
}
In the launchWithoutADL method, we extend component type definition and component creation parts. And we add one more part, the component assembling. In this part, at first we put the two primitives, PrimitiveComputer and PrimitiveMaster in the composite component. Next, we make the binding between each component interfaces.
launchWithoutADL Method
private static void launchWithoutADL() {
    try {
        Component boot = Fractal.getBootstrapComponent();
        TypeFactory typeFact = Fractal.getTypeFactory(boot);
        GenericFactory genericFact = Fractal.getGenericFactory(boot);

        // types: PrimitiveComputer,PrimitiveMaster,CompositeWrapper
        ComponentType computerType = typeFact.createFcType(new InterfaceType[]{
                    typeFact.createFcItfType("compute-itf",
                        ComputeItf.class.getName(), false, false, false)
                });
        ComponentType masterType = typeFact.createFcType(new InterfaceType[] {
                    typeFact.createFcItfType("run",
                        Runnable.class.getName(), false, false, false),
                    typeFact.createFcItfType("compute-itf",
                        ComputeItf.class.getName(), true, false, false)
                });
        ComponentType wrapperType = typeFact.createFcType(new InterfaceType[] {
                    typeFact.createFcItfType("run",
                        Runnable.class.getName(), false, false, false)
                });

        // components creation
        Component primitiveComputer = genericFact.newFcInstance(computerType,
                new ControllerDescription("PrimitiveComputer",
                    Constants.PRIMITIVE),
                new ContentDescription(PrimitiveComputer.class.getName()));
        Component primitiveMaster = genericFact.newFcInstance(masterType,
                new ControllerDescription("PrimitiveMaster",
                    Constants.PRIMITIVE),
                new ContentDescription(PrimitiveMaster.class.getName()));
        Component compositeWrapper = genericFact.newFcInstance(wrapperType,
                new ControllerDescription("CompositeWrapper",
                    Constants.COMPOSITE), null);

        // component assembling
        Fractal.getContentController(compositeWrapper)
               .addFcSubComponent(primitiveComputer);
        Fractal.getContentController(compositeWrapper)
               .addFcSubComponent(primitiveMaster);
        primitiveMaster.getFcInterface("run");
        Fractal.getBindingController(compositeWrapper)
               .bindFc("run", primitiveMaster.getFcInterface("run"));
        Fractal.getBindingController(primitiveMaster)
               .bindFc("compute-itf",
            primitiveComputer.getFcInterface("compute-itf"));

        // start CompositeWrapper component
        Fractal.getLifeCycleController(compositeWrapper).startFc();

        // get the run interface
        Runnable itf = ((Runnable) compositeWrapper.getFcInterface("run"));
        
        // call component
        itf.run();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
This way isn’t the simplest one to create and use component. There is a lot of code to write, that could introduce mistakes or errors in an assembly. We will show an easier one next. 
Create and use components using ADL
We want create the same component directly using ADL capabilities. The source code of the method launchWithADL shows how to use it. Another factory is used, and we can create directly the component without defining at first its type. Utilization of the created component is still the same. You can see that we don’t need to define and assemble parts any more. Moreover, we need to create only one component, the other ones are automatically created.
launchWithADL Method
private static void launchWithADL() {
    try {
        Factory f = org.objectweb.proactive.core.component.adl.FactoryFactory.getFactory();
        Map<String, Object> context = new HashMap<String, Object>();

        // component creation
        Component compositeWrapper = (Component) f.newComponent("org.objectweb.proactive.examples.components.userguide.adl.CompositeWrapper",
                context);

        // start PrimitiveComputer component
        Fractal.getLifeCycleController(compositeWrapper).startFc();

        // get the run interface
        Runnable itf = ((Runnable) compositeWrapper.getFcInterface("run"));

        // call component
        itf.run();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
ADL allows describing a component assembly through a text file. In our case, we have defined fives files. These files need to be in the classpath of the application, for instance the PrimitiveComputer.fractal file needs to be in the org/objectweb/proactive/examples/components/userguide/adl directory in the classpath. The first one, PrimitiveComputerType.fractal, describes the component type, in particular the interface and the membrane with the tags interface and controller. The second one, PrimitiveComputer.fractal, adds two necessary information: the implementation class with the content tag and a virtual node with the virtual-node tag. These tags are explained in the following section.
PrimitiveComputerType.fractal
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN" "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd">

<definition
	name="org.objectweb.proactive.examples.components.userguide.adl.PrimitiveComputerType">
	<interface
	signature="org.objectweb.proactive.examples.components.userguide.primitive.ComputeItf"
		role="server" name="compute-itf" />
	<controller desc="primitive" />
</definition>

PrimitiveComputer.fractal
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN" "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd">

<definition
	extends="org.objectweb.proactive.examples.components.userguide.adl.PrimitiveComputerType"
	name="org.objectweb.proactive.examples.components.userguide.adl.PrimitiveComputer">
	<content
	class="org.objectweb.proactive.examples.components.userguide.primitive.PrimitiveComputer" />
	<virtual-node name="primitive-node" cardinality="single" />
</definition>
It is quite the same for the PrimitiveMaster component; just the name and definition class change, and there is one more interface, a client one.
PrimitiveMasterType.fractal
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN" "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd">

<definition
	name="org.objectweb.proactive.examples.components.userguide.adl.PrimitiveMasterType">
	<interface
		signature="org.objectweb.proactive.examples.components.userguide.primitive.ComputeItf"
		role="client" name="compute-itf" />
	<interface signature="java.lang.Runnable" role="server" name="run" />
	<controller desc="primitive" />
</definition>
PrimitiveMaster.fractal
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN" "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd">

<definition
	extends="org.objectweb.proactive.examples.components.userguide.adl.PrimitiveMasterType"
	name="org.objectweb.proactive.examples.components.userguide.adl.PrimitiveMaster">
	<content
		class="org.objectweb.proactive.examples.components.userguide.primitive.PrimitiveMaster" />
	<virtual-node name="primitive-node" cardinality="single" />
</definition>
And finally, there is the composite one. It defines one interface, and include the two primitive described previously. The binding tag is new; it describes the binding between the interface from composite and inner components.
CompositeWrapper.fractal
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN" "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd">

<definition
	name="org.objectweb.proactive.examples.components.userguide.adl.CompositeWrapper">
	<interface name="run" role="server" signature="java.lang.Runnable" />
	<component name="PrimitiveMaster"
		definition="org.objectweb.proactive.examples.components.userguide.adl.PrimitiveMaster" />
	<component name="PrimitiveComputer"
		definition="org.objectweb.proactive.examples.components.userguide.adl.PrimitiveComputer" />
	<binding client="this.run" server="PrimitiveMaster.run" />
	<binding client="PrimitiveMaster.compute-itf"
		server="PrimitiveComputer.compute-itf" />
	<virtual-node name="composite-node" cardinality="single" />
</definition>
Now, we can run the example; uncomment the line calling the launchWithADL method in the main and then you can see the same output as in the previous section.
Creating, using and deploying components using ADL 
To deploy components on a specific virtual node, we need to use ADL files. Just before we saw that the tag virtual-node allows to specify which virtual node to use for a component. The virtual node is defined in a separate file: a deployment descriptor. You can find more information on how to write a deployment descriptor file in the ProActive documentation, chapter 21, XML Deployment Descriptors. The deployment descriptor file used in this example is in the Appendix: deploymentDescriptor.xml.
Furthermore, we need to inform the factory how to use this deployment descriptor; we do this in the launchPrimitiveADLAndDeployment method : 
We create a ProActiveDescriptor object.
We put this object in the context HashMap.
We give this HashMap to the factory. 
Thus, the factory can retrieve the virtual node defined, and use it as described in the ADL files. 
There is another specific point in the end of this method with the deploymentDescriptor.killall(false); call. This method kills all the JVM deployed using the original deployment descriptor file. Before this call, we need to suspend the program since the method calls in GCM are asynchronous, in order to not kill JVM before the end of the component execution.
launchAndDeployWithADL method
private static void launchAndDeployWithADL() {
    try {
        // get the component Factory allowing component creation from ADL
        Factory f = org.objectweb.proactive.core.component.adl.FactoryFactory.getFactory();
        Map<String, Object> context = new HashMap<String, Object>();

        // retrieve the deployment descriptor
        ProActiveDescriptor deploymentDescriptor = PADeployment.getProactiveDescriptor(Main.class.getResource(
                    "deploymentDescriptor.xml").getPath());
        context.put("deployment-descriptor", deploymentDescriptor);
        deploymentDescriptor.activateMappings();

        // component creation
        Component compositeWrapper = (Component) f.newComponent("org.objectweb.proactive.examples.components.userguide.adl.CompositeWrapper",
                context);

        // start PrimitiveComputer component
        Fractal.getLifeCycleController(compositeWrapper).startFc();

        // get the compute-itf interface
        Runnable itf = ((Runnable) compositeWrapper.getFcInterface("run"));

        // call component
        itf.run();

        Thread.sleep(1000);
        // wait for the end of execution 
        // and kill JVM created with the deployement descriptor
        deploymentDescriptor.killall(false);
    } catch (Exception e) {
        e.printStackTrace();
    }
} 
Now we can run this example; uncomment the line calling the launchPrimitiveADLAndDeployment method, launch it and see below the expected output. The first lines are ProActive log; it’s more verbose than during previous execution because we deploy the two JVMs defined in the deployment descriptor file. After that, you can see information printed from the component and the Main class. And finally, the ProActive log again when the created JVMs are killed.
launchPrimitiveADLAndDeployment Output
Launch primitive component example
Launch component assembly example
Launch component assembly example with ADL
Launch and deploy component assembly example with ADL
 --> This ClassFileServer is reading resources from classpath 2026 
Created a new registry on port 1099 
************* Reading deployment descriptor: file:/home/cdalmass/workspace/ProActiveToJUnit/bin/org/objectweb/proactive/examples/components/userguide/deploymentDescriptor.xml ******************** 
created VirtualNode name=primitive-node 
created VirtualNode name=composite-node 
**** Starting jvm on crusoe.inria.fr  
**** Starting jvm on crusoe.inria.fr  
 --> This ClassFileServer is reading resources from classpath 2032  
 --> This ClassFileServer is reading resources from classpath 2033  
Detected an existing RMI Registry on port 1099  
Detected an existing RMI Registry on port 1099  
rmi://crusoe.inria.fr:1099/primitive-node-1000342669 successfully bound in registry at rmi://crusoe.inria.fr:1099/primitive-node-1000342669  
**** Mapping VirtualNode primitive-node with Node: rmi://crusoe.inria.fr:1099/primitive-node-1000342669 done 
rmi://crusoe.inria.fr:1099/composite-node-1898307992 successfully bound in registry at rmi://crusoe.inria.fr:1099/composite-node-1898307992  
**** Mapping VirtualNode composite-node with Node: rmi://crusoe.inria.fr:1099/composite-node-1898307992 done 
Generating class : pa.stub.org.objectweb.proactive.examples.components.userguide.primitive._StubPrimitiveMaster 
Generating class : pa.stub.org.objectweb.proactive.examples.components.userguide.primitive._StubPrimitiveComputer 
Generating class : pa.stub.org.objectweb.proactive.core.component.type._StubComposite 
Generating class : pa.stub.org.objectweb.proactive.core.component.type._StubComposite  
 PrimitiveComputer-->doNothing() 
 PrimitiveComputer-->compute(5): 10 
 PrimitiveMaster-->run(): Result of computation whith 5 is: 10 
rmi://crusoe.inria.fr:1099/primitive-node-1000342669 unbound in registry  
node primitive-node-1000342669 is being killed, terminating body -6ead4bed:1120592d6e4:-7ff1 23ff98726968d0be:-6ead4bed:1120592d6e4:-8000  
node primitive-node-1000342669 is being killed, terminating body -6ead4bed:1120592d6e4:-7fee 23ff98726968d0be:-6ead4bed:1120592d6e4:-8000  
Process finished Thread=ERR -> /home/cdalmass/pub/l 
Process finished Thread=IN -> /home/cdalmass/pub/l 
 Virtual Machine 23ff98726968d0be:-6ead4bed:1120592d6e4:-8000 on host crusoe.inria.fr terminated!!! 
rmi://crusoe.inria.fr:1099/composite-node-1898307992 unbound in registry  
node composite-node-1898307992 is being killed, terminating body -29f09c48:1120592d74e:-7ff1 23ff98726968d0be:-29f09c48:1120592d74e:-8000  
Process finished Thread=IN -> /home/cdalmass/pub/l 
Process finished Thread=ERR -> /home/cdalmass/pub/l 
 Virtual Machine 23ff98726968d0be:-29f09c48:1120592d74e:-8000 on host crusoe.inria.fr terminated!!!
Component interface Cardinality
Client and server also support multicast and gathercast interface cardinality. The GCM [1] explains which constraints the server and client interfaces must respect and we discuss previously in the section 2.2 on their principles.
For multicast interfaces you can specify the parameter dispatching mode thanks to Java annotations available in the org.objectweb.proactive.core.component.type.annotations.multicast package.
Additional examples
Two component applications are included in ProActive the HelloWorld and C3D example.
A Hello World example is provided. It shows the different ways of creating a component system programmatically and using ADL. You can find the code for this example in the package org.objectweb.proactive.examples.components.helloworld of the CFI prototype distribution. 
The example code can either be compiled and run manually or using scripts (hello-world_fractal.sh (or .bat) in the scripts/unix/components directory) can be used to launch it. If you choose the first solution, do not forget to set the fractal.provider system property.
The other example, C3D application — a parallel, distributed and collaborative 3D renderer, is in the org.objectweb.proactive.examples.components.c3d package.
Conclusion
We have demonstrated that the main features of the GCM are implemented in ProActive and can be used to design and implement grid applications. Also the short user guide shows how we can start using it.
Bibliography
[1] GCM, D.CFI.01 - Component model presentation and specification (XML schema or DTD), GridCOMP deliverable
[2] FractalADL, The Architecture Description Language of the Fractal component model, http://fractal.objectweb.org/fractaladl/index.html
[3] ProActive, Professional Open Source Middleware for Parallel, Distributed, Multi-threaded Programming,  http://www-sop.inria.fr/oasis/ProActive/
Appendix: deploymentDescriptor.xml
<?xml version="1.0" encoding="UTF-8"?>
<ProActiveDescriptor schemaVersion="3.3"
	xmlns="http://www-sop.inria.fr/oasis/ProActive/schemas/DescriptorSchema.xsd"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www-sop.inria.fr/oasis/ProActive/schemas/DescriptorSchema.xsd DescriptorSchema.xsd">
	<componentDefinition>
		<virtualNodesDefinition>
			<virtualNode name="primitive-node" />
			<virtualNode name="composite-node" />
		</virtualNodesDefinition>
	</componentDefinition>
	<deployment>
		<mapping>
			<map virtualNode="primitive-node">
				<jvmSet>
					<vmName value="jvm1" />
				</jvmSet>
			</map>
			<map virtualNode="composite-node">
				<jvmSet>
					<vmName value="jvm2" />
				</jvmSet>
			</map>
		</mapping>
		<jvms>
			<jvm name="jvm1">
				<creation>
					<processReference refid="jvmProcess" />
				</creation>
			</jvm>
			<jvm name="jvm2">
				<creation>
					<processReference refid="jvmProcess" />
				</creation>
			</jvm>
		</jvms>
	</deployment>
	<infrastructure>
		<processes>
			<processDefinition id="jvmProcess">
				<jvmProcess
					class="org.objectweb.proactive.core.process.JVMNodeProcess">
				</jvmProcess>
			</processDefinition>
		</processes>
	</infrastructure>
</ProActiveDescriptor
	
  	<sect1>
  </sect1>
  