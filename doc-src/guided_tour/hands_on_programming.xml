<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="../viewDocbook.css"?>
<chapter id="hands_on_programming">
  <title>Hands-on programming</title>
<para>You've already seen quite sophisticated examples in the section <xref
  linkend="Introduction_Proactive_Features" />. Here is an introduction to
  programming with ProActive.</para>

  <para>The program that we will develop is a classic 'HelloWorld' example. We
  will increase the complexity of the example, so you get more familiar with
  different features of ProActive.</para>

    <para>This example implements a very simple client-server application. It
    has an in-depth explanation in <xref linkend="HelloWorld" />; you might
    wish to skim through it. Summarized, it is a client object displaying a
    <literal>StringWrapper</literal> received from a remote server.</para>


  <itemizedlist>
    <listitem>
      <para>First, we will code a 'client-server' application, the server
      being an active object.</para>
    </listitem>

    <listitem>
      <para>Second, we will see how we can control the activity of an active
      object.</para>
    </listitem>

    <listitem>
      <para>Third, we will add mobility to this active object.</para>
    </listitem>

    <listitem>
      <para>Eventually, we will attach a graphical interface to the active
      object, and will show how to move the widget between virtual machines
      (like in the penguin example).</para>
    </listitem>
  </itemizedlist>


	<sect1>
		<title> First Active Object class</title>
	<para>
		Welcome to your first ProActive program! This is the simplest application that can be
		written. It is composed of two classes with a master-worker structure. 
	</para>
	<figure> <title>Diagram of simple master-worker structure</title>
		  <mediaobject>
          <imageobject>
            <imagedata contentwidth="100"
                       fileref="guided_tour/pics/hello/clientserver.png"
                       format="PNG" width="6in" />
          </imageobject>
        </mediaobject>
      </figure>
	<para>	
		The example illustrates the creation of a active object from the HelloWorld class that will be
		used by the Main class to retrieve a string and print it to the standard output.		
		The Main class corresponds to the client, and is only a container for the main() method, while 
		the HelloWorld class corresponds to the server and its instance is an active object which provides a sayHello
		method as a remote service.
	</para>		
	<para>
		To safely use the HelloWorld class as an active object we have to meet three requirements.
	</para>
		<itemizedlist>
			<listitem><para><emphasis role="bold">no direct access to field variables</emphasis> - If
							<literal>public</literal> variables are used then the stub class generated from
							the original class may become decoupled from the original class. If a change is
							affected on the public field variable in the stub instance, the change will not be 
							 propagated to the the class instance from which the stub was generated. The safe
							 way to change variables is to set them as <literal>private</literal> and access
							 them through <literal>public get/set</literal> methods.   </para></listitem>
			
			<listitem><para><emphasis role="bold">provide a no-argument and preferably an empty constructor</emphasis> - A 
							no-argument constructor is necessary to create the stub class needed for communication.
							A stub cannot be created if there are only constructors with arguments since the 
							stub is only meant to abstract the communication from the active objects. 
							
							If there is no constructor defined, the Java compiler
							will automatically create a no-argument constructor that initializes all instance variables
							to the default value. However, if there is an already defined constructor with arguments 
							then no default no-argument constructor will be created by the compiler. In this case (overloaded constructor)
							the definition of a no-argument constructor is mandatory for stub creation. The safest way is
							to always define a no-argument constructor.
							Also, the constructor should be empty so that on stub creation no 
							initialization is done on the stub.    
							 
						
						</para>	</listitem>
			<listitem><para><emphasis role="bold">provide remote functionalities as public methods with reifiable type</emphasis> - Since
			the stub is created through inheritance, the only methods it can use for communication are
			the inherited public methods from the superclass. The return types of the methods have to be 
			 reifiable (?) and therefore not final. ProActive provides several wrappers for Java types
			 that are final.The example uses the <literal>StringWrapper</literal> class in order to provide a wrapper for the 
			final String class.  Since ProActive uses a proxy mechanism and the String class is final, it’s not
			possible to subclass a String and to perform asynchronous calls.	
			ProActive provides several wrappers for final classes: StringWrapper, BooleanWrapper, 
		IntegerWrapper, DoubleWrapper and FloatWrapper. These have to be used in
		replacement of String, Boolean, Integer, Double and Float
		in classes which will be active objects. Since ProActive uses a proxy
		mechanism and theses classes are final, it’s not
		possible to subclass them and to perform asynchronous calls. The
		subclasses is necessary in order to create the stub class uses in 
		communication. 
		If you don’t use wrappers, method calls will be synchronous.
			<programlisting lang="java"><textobject><textdata fileref="code_snippets/helloworld_example/public_method.txt"></textdata></textobject></programlisting>
			</para>	
			</listitem>
		</itemizedlist>	
		
	<para>
		The following class meets all of the requirements above.
	</para>	
	 <programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/SimpleHelloWorld/src/active/HelloWorld.java" /></textobject></programlisting>
	
<para>We will now show how to create the server object. For now, we want the HelloWorld active object 
 to be created on the current Node (we will see later how to distribute the program). To create an instance of
  a remotely accessible object we must use the <literal>ProActive.newActive</literal> primitive.
  <programlisting lang="java"><textobject><textdata fileref="code_snippets/helloworld_example/ao_creation.txt"></textdata></textobject></programlisting>
</para>
	<para>
		<emphasis role="bold"> [[EXPLAIN WAIT BY NECESSITY BETTER]]</emphasis>
		Invoking a method on a remote active object is transparent and is similar to  invoking a method on
		a local object of the same type. The user does not have to deal with catching exceptions
		related to the remote communication. The only modification brought to the code by ProActive
		is during the active objects creation. All the rest of the code can remain unmodified, 
		fostering software reuse.
		To invoke the sayHello method we execute:	
	<programlisting lang="java"><textobject><textdata fileref="code_snippets/helloworld_example/ao_invocation.txt" /></textobject></programlisting>

	</para>
	<para> The full code of the <literal>Main</literal> class is the following. </para>
	<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/SimpleHelloWorld/src/active/Main.java" /></textobject></programlisting>
	<sect2>
		<title>Running the HelloWorld application</title>
		<para>
		For now the application will be deployed on the local Node. To compile and run the application you need the 
		<literal> Main </literal>class, the <literal> HelloWorld </literal>class,  to
		include the following jar files: 
		  	<literal>ProActive/ProActive.jar</literal>,
          	<literal>ProActive/lib/javassist.jar</literal>,
          		<literal>ProActive/lib/log4j.jar</literal>, 
          		<literal>ProActive/lib/xercesImpl.jar</literal>, 
          		<literal>ProActive/lib/fractal.jar</literal>,  
          		and <literal>ProActive/lib/bouncycastle.jar</literal>
           and explicitly set the Java security policy with the  <literal>-Djava.security.policy=pathToFile</literal>
           and the logging policy with  <literal>-Dlog4j.configuration=file:proactive-log4j</literal>.
            The steps necessary are explained in <xref linkend="Installation"/>.
           Also, the full code for the example is available in [[[FOLDER NAME]]] as a ready to run Eclipse project.
		</para>	
		<para>
			The command line for running the application is: 
			<screen>
java -Djava.security.policy=proactive.java.policy -Dlog4j.configuration=file:proactive-log4j Main 
			</screen>
		</para>
	</sect2>
	</sect1>

  <sect1>
    <title>Initialization of the active object activity</title>

    <para>Active objects, as their name indicates, have an activity of their
    own (an internal thread).By default the active object steps through
    the constructor, the <literal>initActivity</literal>, the <literal>runActivity</literal>,
     and when the <literal>terminate</literal> method is called on
    the <literal>Body</literal> of the active object through the <literal>endActivity</literal> method.
    It is possible to control the initialization, running, and ending phase of this
    thread by implementing three interfaces:<literal>InitActive</literal>,<literal>
    RunActive</literal>, and <literal>EndActive</literal>.These interfaces define the
    <literal>initActivity</literal>, <literal>runActivity</literal> and <literal>endActivity</literal>
    methods. One of the reasons for using <literal>initActivity</literal>
    method is the presence of the empty constructor in an active object. The <literal>initActivity</literal>
    method is automatically called on the creation of an active object in order to set up the 
    object without using the constructor. The <literal>runActivity</literal> method allows the user
    to control the active object request queue. By implementing the <literal>EndActive</literal> interface is also possible to 
    do clean up before the active object thread is stopped. </para>


    <para>The following example will help you to understand how and when you
    can initialize and clean the activity. The example will implement the <literal>InitActive</literal> and
    <literal>EndActive</literal> interfaces. To understand how to use the more complex
    <literal>RunActive</literal> interface read <xref linkend="AOCreation"/> </para>


    <sect2>
      <title>Design of the application with Init activity</title>

      <para>The InitializedHelloWorld class extends the Hello class in the previous example, and implements
      the interfaces InitActive and EndActive.It acts as a server for the
      Main class.</para>

      <para><figure>
      		<title> Diagram of the master-worker structure with a worker that does initialization</title> 
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="guided_tour/pics/hello/initializedhello.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    
    
    <para>
    	To implement the application we will create a class that inherits from the 
    	<literal>HelloWorld</literal> class and implements the EndActive and InitActive
    	interfaces. 
    	<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/InitializedSimpleHello/src/active/InitializedHelloWorld.java"></textdata></textobject></programlisting>
    </para>
    <para>
    	By default an active object has a never ending thread that should be stopped when the object is 
    	not needed anymore. The method <literal>terminate</literal> serves the purpose of destroying the 
    	object. However, if an explicit call to terminate the object is not made, ProActive has its own
    	distributed garbage collection system that is able to decide when an active object can be destroyed. 
    </para>
    <para>
    	In the <literal>Main</literal> class we will change the object created from <literal>HelloWorld</literal> to 
    	<literal>InitializedHelloWorld</literal> and also we will call the <literal>terminate </literal> method to 
    	destroy the object.
    	<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/InitializedSimpleHello/src/active/Main.java"></textdata></textobject></programlisting>
    	 
    </para>
    </sect2>

        
    
    <sect2>
      <title>Running the InitializedHelloWorld application</title>

      <para>To compile and run the application you need the
      	 HelloWorld class from the previous example, the new Main class, and the InitializedHelloWorld class.
      	You also have to include the following jar files: ProActive/ProActive.jar, ProActive/lib/javassist.jar,
       	ProActive/lib/log4j.jar, ProActive/lib/xercesImpl.jar, ProActive/lib/fractal.jar, and 
       	ProActive/lib/bouncycastle.jar  and explicitly set the Java security policy with the
       	 <literal>-Djava.security.policy=pathToFile </literal> 
       	and the logging policy with  <literal>-Dlog4j.configuration=file:proactive-log4j</literal>.
            The steps necessary are explained in 
       	<xref linkend="Installation"/>. Also, the full code for the example is available in
       	  [[[FOLDER NAME]]] as a ready to run Eclipse project.</para>
 		<para>	The command line for running the application is: </para> 
	<para>
			<screen>
java -Djava.security.policy=proactive.java.policy -Dlog4j.configuration=file:proactive-log4j Main 
			</screen>
 	</para>
    </sect2>
  </sect1>
	<sect1>
		<title>Application Deployment</title>
		<para>
			In the previous example the applications were deployed inside the same JVM.
			This section will focus on showing how to deploy the application on different nodes
			using deployment descriptors. 
		</para>
		<sect2>
			<title>Deployment Related Concepts</title>
			<para>
				A first principle is to fully eliminate from the source code the following elements:
				<itemizedlist>
					<listitem>machine names</listitem>
					<listitem>creation protocols</listitem>
					<listitem>registry lookup protocols</listitem>
				</itemizedlist>
			</para>
			<para>
				The goal is to deploy any application anywhere without changing the source code. 
				For instance, we must be able to use various protocols, rsh, ssh, Globus, LSF,
				etc., for the creation of the JVMs needed by the application. In the same 
				manner, the discovery of existing resources or the registration of the
				ones created by the application can be done with various protocols such as 
				RMIregistry, Globus etc. Therefore, we see that the creation, registration and 
				discovery of resources have to be done externally to the application.
			</para>
			<para>
				A second key principle is the capability to abstractly describe an
			 	application, or part of it, in terms of its conceptual activities. The description
			 	should indicate the various parallel or distributed entities in the program. For
			 	instance, an application that is designed to use three interactive 
			 	visualization nodes, a node to capture input from a physics experiment, and a
			 	simulation engine designed to run on a cluster of machines should somewhere clearly
			 	advertise this information.
			</para>
			<para>
				Now, one should note that the abstract description of an application and the way to 
				deploy it are not independent piece of information. In the example just above, if 
				there is a simulation engine, it might register in a specific registry protocol, and if 
				so, the other entities of the computation might have to use that lookup protocol to bind to 
				the engine. Moreover, one part of the program can just lookup for the engine (assuming it is 
				started independently), or explicitly create the engine itself.	To summarize, in order to abstract away 
				the underlying execution platform, and to allow a source-independent deployment, a framework has 
				to provide the following elements:
				<itemizedlist>
					<listitem>an abstract description of the distributed entities of a parallel program or component,
					</listitem>
					<listitem>an external mapping of those entities to real machines, using actual creation, registry, and lookup protocols.
					</listitem>
				</itemizedlist>
			</para>
			<para>
				To reach that goal, the programming model relies on the specific notion of Virtual Nodes (VNs):
				<itemizedlist>
					<listitem>a VN is identified as a name (a simple string)
					</listitem>
					<listitem>a VN is used in a program source
					</listitem>
					<listitem>a VN is defined and configured in a deployment descriptor (XML)
					</listitem>
					<listitem>a VN, after activation, is mapped to one or to a set of actual ProActive Nodes
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Of course, distributed entities (Active Objects), are created on Nodes, not on Virtual Nodes.
 			 	There is a strong need for both Nodes and Virtual Nodes. Virtual Nodes are a much richer abstraction,
 			 	as they provide mechanisms such as set or cyclic mapping. Another key aspect is the capability to
 			 	describe and trigger the mapping of a single VN that generates the allocation of several JVMs.
 			 	This is critical if we want to get at once machines from a cluster of PCs managed through Globus or
 			 	LSF. It is even more critical in a Grid application, when trying to achieve the co-allocation of
 			 	machines from several clusters across several continents.
			</para>
			<para>
				Moreover, a Virtual Node is a concept of a distributed program or component, while a Node is actually
				a deployment concept: it is an object that lives in a JVM, hosting Active Objects. There is of 
				course a correspondence between Virtual Nodes and Nodes: the function created by the deployment, 
				the mapping. This mapping can be specified in an XML descriptor. By definition, the following 
				operations can be configured in such a deployment descriptor:
				<itemizedlist>
					<listitem>the mapping of VNs to Nodes and to JVMs</listitem>
					<listitem>the way to create or to acquire JVMs</listitem>
					<listitem>the way to register or to lookup VNs</listitem>
				</itemizedlist>
				
			</para>
		</sect2>
		<sect2>
			<title>Deployment Descriptor File</title>
			<para>	
				The deployment descriptor is an XML file containing information on the properties listed above.
				We will use a simple XML file to deploy the Hello World application on a remote 
				The deployment XML file is composed of several parts, each with different options. For our
				example we will use a simple version. To find out more about deployment and deployment 
				descriptors reader <xref linkend="Descriptor"/>.
			</para>
			<para>
				The document uses the XML Schema present at the
				<xref ulink="http://www-sop.inria.fr/oasis/ProActive/schemas/deployment/3.3/deployment.xsd">INRIA</xref> site.
			</para>
			<para>	
				To avoid mistake when building XML descriptors, ProActive provides an XML Schema called
				DescriptorSchema.xsd. To validate your file against this schema,
				the following line must be put at the top of the XML document.
			</para>

				<programlisting lang="xml"><textobject><textdata fileref="code_snippets/deployment_descriptor/schema_location.txt"></textdata></textobject></programlisting>
			<para>
				The XML file has a section for defining variables needed later in the document.
				For our case, we define the location of the ProActive and Java installations on the local
				and remote machine. To start the JVM and use ProActive on the remote machine, we need to define the  
				location of the Java and ProActive files. This can be done by specifying the paths in the 
				infrastructure section of the deployment descriptor or by setting the CLASSPATH and JAVA_HOME 
				variables as described in	<xref linkend="Installation"/>.
				<programlisting lang="xml"><textobject><textdata fileref="code_snippets/deployment_descriptor/variable_definition.txt"></textdata></textobject></programlisting>
			</para>
			<para>
				Next, we define the virtual nodes that will be used. In our case we define a node that
				can contain several JVMs by setting the multiple property. 
				<programlisting lang="xml"><textobject><textdata fileref="code_snippets/deployment_descriptor/component_definition.txt"></textdata></textobject></programlisting>
			</para>
			<para>
				The deployment part of the XML file specifies how the JVMs are started and 
				mapped on the Virtual Nodes
				It has two parts one dealing with the mapping of the JVMs to the Virtual Nodes and another
				related to how the JVMs are created. In our case we map one JVM to the remote node and
				define a process reference that will be used later in the file (infrastructure section)
				to describe how the JVM is started. 
				<programlisting lang="xml"><textobject><textdata fileref="code_snippets/deployment_descriptor/jvms.txt"></textdata></textobject></programlisting>
			</para>
			<para>
				Next is the infrastructure part that defines the paths to the files needed, the hosts on which the 
				JVMs are deployed and which protocols are used for communication. 
				
				The process definition with the id <literal> genericRemoteJVM </literal> is 
				necessary to tell the JVM machine how to start a node on the machine
				that has a reference to it (<literal>processReference</literal>). It will use
				the paths provided to locate the Java and ProActive files on the remote machine. 
				Here we are using rsh to start the JVM but several other protocols can be used
				as described in <xref linkend="Descriptor"/>. 
				<programlisting lang="xml"><textobject><textdata fileref="code_snippets/deployment_descriptor/infrastructure.txt"></textdata></textobject></programlisting>
			</para>
			<para>
				To deploy on a remote machine you will need to change the <literal>
				hostname </literal> tag to fit your machine name. In our case the remote machine
				needs to have the <literal> rsh </literal> service running.
				 
				The full deployment descriptor file:
				<programlisting lang="xml"><textobject><textdata fileref="guided_tour/examples/DeployedHelloWorld/src/active/deployment.xml"></textdata></textobject></programlisting>
			</para>
			</sect2>	
			<sect2>
				<title> Application changes </title>
				
			<para>
				To be able to deploy on remote machines we just have to use the deployment file
				and add a method that tells ProActive to active the nodes used. 
				<figure>
					<title>Deployed HelloWorld architecture</title>
					<mediaobject>
						<imageobject> <imagedata contentwidth="100"
                         fileref="guided_tour/pics/hello/DeployedHelloWorld.png"
                         format="PNG" width="6in" /></imageobject>
					</mediaobject>
				</figure>
			</para>
				<para>
				We will change the <literal>Main</literal> class to declare 
				and load the deployment descriptors	to be used. For this we will use 
				a <literal>static deploy</literal> method that returns the Node on 
				which we deploy the active object. First, the method creates an
				object representation of the deployment file, then activates all the nodes,
				and then returns the first available node.  
				</para>
				<programlisting lang="java"><textobject><textdata fileref="code_snippets/deployed_hello_example/deploy_method.txt"></textdata></textobject></programlisting>
				
				
				<para>The <literal>Main</literal> class:</para>
				<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/DeployedHelloWorld/src/active/Main.java"></textdata></textobject></programlisting>

			
		</sect2>



    <sect2>
      <title>Running the DeployedHelloWorld application</title>

      <para>To compile and run the application you need the
      	 HelloWorld class from the previous example, the new Main class, and the InitializedHelloWorld class.
      	You also have to include the following jar files: ProActive/ProActive.jar, ProActive/lib/javassist.jar,
       	ProActive/lib/log4j.jar, ProActive/lib/xercesImpl.jar, ProActive/lib/fractal.jar, and 
       	ProActive/lib/bouncycastle.jar  and explicitly set the Java security policy with the
       	 <literal>-Djava.security.policy=pathToFile </literal> 
       	and the logging policy with  <literal>-Dlog4j.configuration=file:proactive-log4j</literal>.
            The steps necessary are explained in 
       	<xref linkend="Installation"/>. Also, the full code for the example is available in
       	  [[[FOLDER NAME]]] as a ready to run Eclipse project.</para>
 			<para>
 			The command line for running the application is:
 			</para> 
	<para>
		<screen>java -Djava.security.policy=proactive.java.policy -Dlog4j.configuration=file:proactive-log4j Main deployment.xml</screen>
 	</para>
    </sect2>

	</sect1>

  <sect1>
    <title>A simple migration example</title>

    <indexterm>
      <primary>Migration</primary>
    </indexterm>

    <para>Our next example deals with migrating the active objects between 
    remote nodes. We will start the active object on one machine and then move it 
    to another one. We will need to change the descriptor file to specify the
    second virtual node and machine and add a method that enables us to 
    tell the active object to migrate. </para>

    <sect2>
      <title>Required conditions</title>

      <para>An active object must implement the Serializable interface (as it will be transferred
      through the network) in order to be able to migrate.</para>

      <para> For more information on the topic of object migration, check <xref
      linkend="Migration" /> .</para>
    </sect2>

    <sect2>
      <title>Design</title>

      
      <para>We create a MigrateableHello class, that derives from
      InitializedHello. This class will implement all the non-functionnal
      behavior concerning the migration, for which this example is created.
      The Hello and InitializedHello classes are left unmodified.</para>

      <para>The migration has to be initiated
      by the active object itself. We will have to write the migrate method in the code of MigrateableHello -
      i.e. a method that contains an explicit call to the migration primitive.
      </para>
    
      <para>The class diagram for the application is the following:</para>

      <para><figure>
      	<title>The Migrateable HelloWorld architecture</title>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="guided_tour/pics/hello/MigrateableHelloWorld.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Deployment descriptor change</title>
      <para>
      	In the deployment descriptor file we will define a new virtual node,
      </para>
      <para>	
      	<programlisting lang="xml"><textobject><textdata fileref="code_snippets/migrateable_hello/component_definition.txt"></textdata></textobject></programlisting>
      </para>
      <para>	
      	another JVM to be started in the virtual node,
      </para>
      <para>
      	<programlisting lang="xml"><textobject><textdata fileref="code_snippets/migrateable_hello/jvms.txt"></textdata></textobject></programlisting>
      </para>	
      <para>
      	 and a host on which the new virtual node will be located. 
	 
      </para>	 
      		<programlisting lang="xml"><textobject><textdata fileref="code_snippets/migrateable_hello/infrastructure.txt"></textdata></textobject></programlisting>
      <para>
    	The full deployment descriptor file is:
		</para>
	<programlisting lang="xml"><textobject><textdata fileref="guided_tour/examples/MigratableHelloWorld/src/active/deployment.xml"></textdata></textobject></programlisting>
	</sect2>
	
<sect2>
	<title> Architecture change </title>
	<para> We will extend the <literal>InitializedHelloWorld</literal> class and add a method that
	makes the active object instantiated from the new class able to migrate. The new class also
	has to implement the <literal>Serializable</literal> interface in order to be sent over
	the network.</para>
	<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/MigratableHelloWorld/src/active/MigrateableHello.java"></textdata></textobject></programlisting>
	
	<para>
		We also have to change the <literal>Main</literal>class to retrieve the node
		to which the active object will migrate. For this we will add a method that
		returns the node contained in the virtual node on the second remote machine. 
	</para>
      	<programlisting lang="java"><textobject><textdata fileref="code_snippets/migrateable_hello/node_retrieving_method.txt"></textdata></textobject></programlisting>
	<para>
		The full new <literal> Main </literal> class is: 
	</para>	
		<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/MigratableHelloWorld/src/active/Main.java"></textdata></textobject></programlisting>
	

        <para>Note that the call to the ProActive primitive
        <literal>migrateTo</literal> is the last one of the method moveTo. See
        <xref linkend="Migration" /> for more information.</para>
    </sect2>

   
   <sect2>
      <para><informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata fileref="guided_tour/pics/hello/agent_execution.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </informalfigure></para>

      <para>During the execution, a default node is first created. It then
      hosts the created active object. Then the active object is migrated from
      node to node, each time returning 'hello' and telling the client program
      where it is located.</para>
    </sect2>
    
    
       <sect2>
      <title>Running the InitializedHelloWorld application</title>

      <para>To compile and run the application you need the
      	 HelloWorld class from the previous example, the InitializedHelloWorld class, the 
      	 MigrateableHello class,and the new Main class,.
      	You also have to include the following jar files: ProActive/ProActive.jar, ProActive/lib/javassist.jar,
       	ProActive/lib/log4j.jar, ProActive/lib/xercesImpl.jar, ProActive/lib/fractal.jar, and 
       	ProActive/lib/bouncycastle.jar  and explicitly set the Java security policy with the
       	 <literal>-Djava.security.policy=pathToFile </literal> 
       	and the logging policy with  <literal>-Dlog4j.configuration=file:proactive-log4j</literal>.
            The steps necessary are explained in 
       	<xref linkend="Installation"/>. Also, the full code for the example is available in
       	  [[[FOLDER NAME]]] as a ready to run Eclipse project.</para>
 		<para>	The command line for running the application is: </para> 
	<para>
			<screen>
java -Djava.security.policy=proactive.java.policy -Dlog4j.configuration=file:proactive-log4j Main deployment.xml
			</screen>
 	</para>
    </sect2>
    
  </sect1>

  <sect1>
    <title>migration of graphical interfaces</title>

    <para>Graphical interfaces are not serializable, yet it is possible to
    migrate them with ProActive.</para>

    <para>The idea is to associate the graphical object to an active object.
    The active object will control the activation and desactivation of this
    graphical entity during migrations.</para>

    <para>Of course, this is a very basic example, but you can later build
    more sophisticated frames.</para>

    <sect2>
      <title>Design of the migrateable application</title>

      <para>We will write a new active object class, that extends
      MigrateableHello. The sayHello method will create a window containing the
      hello message. This window is defined in the class HelloFrame</para>

      <para><informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="guided_tour/pics/hello/hellogui.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </informalfigure></para>
    </sect2>

    <sect2>
      <title>Programming</title>

      <sect3>
        <title>HelloFrameController</title>

        <para>The code of the HelloFrameController is in <xref
        linkend="tutorialCodeSrc.HelloFrameController.java" />.</para>

        <para>This class extends MigrateableHello, and adds an activity and a
        migration strategy manager to the object .</para>

        <para>It creates a graphical frame upon call of the sayHello
        method.</para>

        <para>Here we have a more complex migration process than with the
        previous example. We need to make the graphical window disappear
        before and reappear in a new location after the migration (in this
        example though, we wait for a call to sayHello). The migration of the
        frame is actually controlled by a MigrationStrategyManager, that will
        be attached to the body of the active object.. An ideal location for
        this operation is the initActivity method (from InitActive interface),
        that we override:</para>

        <programlisting lang="java">/**
 * This method attaches a migration strategy manager to the current active object.
 * The migration strategy manager will help to define which actions to take before
 * and after migrating
 */
public void initActivity(Body body) {
        // add a migration strategy manager on the current active object
        migrationStrategyManager = new MigrationStrategyManagerImpl((Migrateable) ProActive.getBodyOnThis());
        // specify what to do when the active object is about to migrate
        // the specified method is then invoked by reflection
        migrationStrategyManager.onDeparture('clean');
}          </programlisting>

        <para>The MigrationStrategyManager defines methods such as
        'onDeparture', that can be configured in the application. For example
        here, the method 'clean' will be called before the migration,
        conveniently killing the frame:</para>

        <programlisting lang="java">public void clean() {
        System.out.println("killing frame");
        helloFrame.dispose();
        helloFrame = null;
        System.out.println("frame is killed");
}          </programlisting>
      </sect3>

      <sect3>
        <title>HelloFrame</title>

        <para>This is an example of a graphical class that could be associated
        with the active object (see code in <xref
        linkend="tutorialCodeSrc.HelloFrame.java" /> ).</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Execution</title>

      <itemizedlist>
        <listitem>
          <para>Create a new class HelloFrameControllerClient: take the code
          of MigrateableHelloClient used in the previous part, change the class
          declaration to HelloFrameControllerClient and replace the
          line</para>
        </listitem>
      </itemizedlist>

      <para><literal>MigrateableHello migrateable_hello =
      MigrateableHello.createMigrateableHello("agent1");</literal></para>

      <para>with</para>

      <para><literal>MigrateableHello migrateable_hello =
      HelloFrameController.createHelloFrameController("agent1");</literal></para>

      <itemizedlist>
        <listitem>
          <para>Similarly to the simple migration example (use the
          HelloFrameControllerClient class), you will start remote nodes and
          specify a migration path.</para>
        </listitem>

        <listitem>
          <para>you have 2 ways for handling the display of the graphical
          objects:</para>
        </listitem>
      </itemizedlist>

      <para><itemizedlist>
          <listitem>
            <para>look on the display screens of the machines</para>
          </listitem>
        </itemizedlist></para>

      <para><itemizedlist>
          <listitem>
            <para>export the displays: in startNode.sh, you should add the
            following lines before the java command:</para>

            <para><literal>DISPLAY=myhost:0 export DISPLAY</literal></para>
          </listitem>
        </itemizedlist></para>

      <para><informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata fileref="guided_tour/pics/hello/hellogui-snapshot.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </informalfigure></para>

      <para>The displayed window: it just contains a text label with the
      location of the active object.</para>
    </sect2>
  </sect1>
</chapter>