<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="../viewDocbook.css"?>
<chapter id="hands_on_programming">
  <title>Hands-on programming</title>
<para>You've already seen quite sophisticated examples in the section <xref
  linkend="Introduction_Proactive_Features" />. Here is an introduction to
  programming with ProActive.</para>

  <para>The program that we will develop is a classic 'HelloWorld' example. We
  will increase the complexity of the example, so you get more familiar with
  different features of ProActive.</para>

    <para>This example implements a very simple client-server application. It
    has an in-depth explanation in <xref linkend="HelloWorld" />; you might
    wish to skim through it. Summarized, it is a client object displaying a
    <literal>StringWrapper</literal> received from a remote server.</para>


  <itemizedlist>
    <listitem>
      <para>First, we will code a 'client-server' application, the server
      being an active object.</para>
    </listitem>

    <listitem>
      <para>Second, we will see how we can control the activity of an active
      object.</para>
    </listitem>

    <listitem>
      <para>Third, we will add mobility to this active object.</para>
    </listitem>

    <listitem>
      <para>Eventually, we will attach a graphical interface to the active
      object, and will show how to move the widget between virtual machines
      (like in the penguin example).</para>
    </listitem>
  </itemizedlist>


	<sect1>
		<title> First Active Object class</title>
	<para>
		Welcome to your first ProActive program! This is the simplest application that can be
		written. It is composed of two classes with a master-worker structure. 
	</para>
	<figure> <title>Diagram of simple master-worker structure</title>
		  <mediaobject>
          <imageobject>
            <imagedata contentwidth="100"
                       fileref="guided_tour/pics/hello/clientserver.png"
                       format="PNG" width="6in" />
          </imageobject>
        </mediaobject>
      </figure>
	<para>	
		The example illustrates the creation of a active object from the HelloWorld class that will be
		used by the Main class to retrieve a string and print it to the standard output.		
		The Main class corresponds to the client, and is only a container for the main() method, while 
		the HelloWorld class corresponds to the server and its instance is an active object which provides a sayHello
		method as a remote service.
	</para>		
	<para>
		To safely use the HelloWorld class as an active object we have to meet three requirements.
	</para>
		<itemizedlist>
			<listitem><para><emphasis role="bold">no direct access to field variables</emphasis> - If
							<literal>public</literal> variables are used then the stub class generated from
							the original class may become decoupled from the original class. If a change is
							affected on the public field variable in the stub instance, the change will not be 
							 propagated to the the class instance from which the stub was generated. The safe
							 way to change variables is to set them as <literal>private</literal> and access
							 them through <literal>public get/set</literal> methods.   </para></listitem>
			
			<listitem><para><emphasis role="bold">provide a no-argument and preferably an empty constructor</emphasis> - A 
							no-argument constructor is necessary to create the stub class needed for communication.
							A stub cannot be created if there are only constructors with arguments since the 
							stub is only meant to abstract the communication from the active objects. 
							
							If there is no constructor defined, the Java compiler
							will automatically create a no-argument constructor that initializes all instance variables
							to the default value. However, if there is an already defined constructor with arguments 
							then no default no-argument constructor will be created by the compiler. In this case (overloaded constructor)
							the definition of a no-argument constructor is mandatory for stub creation. The safest way is
							to always define a no-argument constructor.
							Also, the constructor should be empty so that on stub creation no 
							initialization is done on the stub.    
							 
						
						</para>	</listitem>
			<listitem><para><emphasis role="bold">provide remote functionalities as public methods with reifiable type</emphasis> - Since
			the stub is created through inheritance, the only methods it can use for communication are
			the inherited public methods from the superclass. The return types of the methods have to be 
			 reifiable (?) and therefore not final. ProActive provides several wrappers for Java types
			 that are final.The example uses the <literal>StringWrapper</literal> class in order to provide a wrapper for the 
			final String class.  Since ProActive uses a proxy mechanism and the String class is final, it’s not
			possible to subclass a String and to perform asynchronous calls.	
			ProActive provides several wrappers for final classes: StringWrapper, BooleanWrapper, 
		IntegerWrapper, DoubleWrapper and FloatWrapper. These have to be used in
		replacement of String, Boolean, Integer, Double and Float
		in classes which will be active objects. Since ProActive uses a proxy
		mechanism and theses classes are final, it’s not
		possible to subclass them and to perform asynchronous calls. The
		subclasses is necessary in order to create the stub class uses in 
		communication. 
		If you don’t use wrappers, method calls will be synchronous.
			<programlisting lang="java"><textobject><textdata fileref="code_snippets/helloworld_example/public_method.txt"></textdata></textobject></programlisting>
			</para>	
			</listitem>
		</itemizedlist>	
		
	<para>
		The following class meets all of the requirements above.
	</para>	
	 <programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/SimpleHelloWorld/src/active/HelloWorld.java" /></textobject></programlisting>
	
<para>We will now show how to create the server object. For now, we want the HelloWorld active object 
 to be created on the current Node (we will see later how to distribute the program). To create an instance of
  a remotely accessible object we must use the <literal>ProActive.newActive</literal> primitive.
  <programlisting lang="java"><textobject><textdata fileref="code_snippets/helloworld_example/ao_creation.txt"></textdata></textobject></programlisting>
</para>
	<para>
		<emphasis role="bold"> [[EXPLAIN WAIT BY NECESSITY BETTER]]</emphasis>
		Invoking a method on a remote active object is transparent and is similar to  invoking a method on
		a local object of the same type. The user does not have to deal with catching exceptions
		related to the remote communication. The only modification brought to the code by ProActive
		is during the active objects creation. All the rest of the code can remain unmodified, 
		fostering software reuse.
		To invoke the sayHello method we execute:	
	<programlisting lang="java"><textobject><textdata fileref="code_snippets/helloworld_example/ao_invocation.txt" /></textobject></programlisting>

	</para>
	<para> The full code of the <literal>Main</literal> class is the following. </para>
	<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/SimpleHelloWorld/src/active/Main.java" /></textobject></programlisting>
	<sect2>
		<title>Running the HelloWorld application</title>
		<para>
		For now the application will be deployed on the local Node. To compile and run the application you need the 
		<literal> Main </literal>class, the <literal> HelloWorld </literal>class,  to
		include the following jar files: 
		  	<literal>ProActive/ProActive.jar</literal>,
          	<literal>ProActive/lib/javassist.jar</literal>,
          		<literal>ProActive/lib/log4j.jar</literal>, 
          		<literal>ProActive/lib/xercesImpl.jar</literal>, 
          		<literal>ProActive/lib/fractal.jar</literal>,  
          		and <literal>ProActive/lib/bouncycastle.jar</literal>
           and explicitly set the Java security policy with the  <literal>-Djava.security.policy=pathToFile</literal>
           JVM option. The steps necessary are explained in <xref linkend="Installation"/>.
           Also, the full code for the example is available in [[[FOLDER NAME]]] as a ready to run Eclipse project.
		</para>	
	</sect2>
	</sect1>

  <sect1>
    <title>Initialization of the active object activity</title>

    <para>Active objects, as their name indicates, have an activity of their
    own (an internal thread).By default the active object steps through
    the constructor, the <literal>initActivity</literal>, the <literal>runActivity</literal>,
     and when the <literal>terminate</literal> method is called on
    the <literal>Body</literal> of the active object through the <literal>endActivity</literal> method.
    It is possible to control the initialization, running, and ending phase of this
    thread by implementing three interfaces:<literal>InitActive</literal>,<literal>
    RunActive</literal>, and <literal>EndActive</literal>.These interfaces define the
    <literal>initActivity</literal>, <literal>runActivity</literal> and <literal>endActivity</literal>
    methods. One of the reasons for using <literal>initActivity</literal>
    method is the presence of the empty constructor in an active object. The <literal>initActivity</literal>
    method is automatically called on the creation of an active object allowing for setting up the 
    object without using the constructor. The <literal>runActivity</literal> method allows the user
    to control By implementing the <literal>EndActive</literal> interface is also possible to 
    do clean up before the active object thread is stopped. </para>


    <para>The following example will help you to understand how and when you
    can initialize and clean the activity. The example will implement the <literal>InitActive</literal> and
    <literal>EndActive</literal> interfaces. To understand how to use the more complex
    <literal>RunActive</literal> interface read <xref linkend="AOCreation"/> </para>


    <sect2>
      <title>Design of the application with Init activity</title>

      <para>The InitializedHelloWorld class extends the Hello class in the previous example, and implements
      the interfaces InitActive and EndActive.It acts as a server for the
      Main class.</para>

      <para><figure>
      		<title> Diagram of the master-worker structure with a worker that does initialization</title> 
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="guided_tour/pics/hello/initializedhello.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    
    
    <para>
    	To implement the application we will create a class that inherits from the 
    	<literal>HelloWorld</literal> class and implements the EndActive and InitActive
    	interfaces. 
    	<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/InitializedSimpleHello/src/active/InitializedHelloWorld.java"></textdata></textobject></programlisting>
    </para>
    <para>
    	By default an active object has a never ending thread that should be stopped when the object is 
    	not needed anymore. The method <literal>terminate</literal> serves the purpose of destroying the 
    	object. However, if an explicit call to terminate the object is not made, ProActive has its own
    	distributed garbage collection system that is able to decide when an active object can be destroyed. 
    </para>
    <para>
    	In the <literal>Main</literal> class we will change the object created from <literal>HelloWorld</literal> to 
    	<literal>InitializedHelloWorld</literal> and also we will call the <literal>terminate </literal> method to 
    	destroy the object.
    	<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/InitializedSimpleHello/src/active/Main.java"></textdata></textobject></programlisting>
    	 
    </para>
    </sect2>

        
    
    <sect2>
      <title>Running the InitializedHelloWorld application</title>

      <para>To compile and run the application you need the
      	 HelloWorld class from the previous example, the new Main class, and the InitializedHelloWorld class.
      	You also have to include the following jar files: ProActive/ProActive.jar, ProActive/lib/javassist.jar,
       	ProActive/lib/log4j.jar, ProActive/lib/xercesImpl.jar, ProActive/lib/fractal.jar, and 
       	ProActive/lib/bouncycastle.jar  and explicitly set the Java security policy with the
       	 <literal>-Djava.security.policy=pathToFile </literal> JVM option. The steps necessary are explained in 
       	<xref linkend="Installation"/>. Also, the full code for the example is available in
       	  [[[FOLDER NAME]]] as a ready to run Eclipse project.</para>
 
    </sect2>
  </sect1>
	<sect1>
		<title>Application Deployment</title>
		<para>
			In the previous example the applications were deployed inside the same JVM.
			This section will focus on showing how to deploy the application on different nodes
			using deployment descriptors. 
		</para>
		<sect2>
			<title>Deployment Related Concepts</title>
			<para>
				A first principle is to fully eliminate from the source code the following elements:
				<itemizedlist>
					<listitem>machine names</listitem>
					<listitem>creation protocols</listitem>
					<listitem>registry lookup protocols</listitem>
				</itemizedlist>
			</para>
			<para>
				The goal is to deploy any application anywhere without changing the source code. 
				For instance, we must be able to use various protocols, rsh, ssh, Globus, LSF,
				etc., for the creation of the JVMs needed by the application. In the same 
				manner, the discovery of existing resources or the registration of the
				ones created by the application can be done with various protocols such as 
				RMIregistry, Globus etc. Therefore, we see that the creation, registration and 
				discovery of resources have to be done externally to the application.
			</para>
			<para>
				A second key principle is the capability to abstractly describe an
			 	application, or part of it, in terms of its conceptual activities. The description
			 	should indicate the various parallel or distributed entities in the program. For
			 	instance, an application that is designed to use three interactive 
			 	visualization nodes, a node to capture input from a physic experiment, and a
			 	simulation engine designed to run on a cluster of machines should somewhere clearly
			 	advertise this information.
			</para>
			<para>
				Now, one should note that the abstract description of an application and the way to 
				deploy it are not independent piece of information. In the example just above, if 
				there is a simulation engine, it might register in a specific registry protocol, and if 
				so, the other entities of the computation might have to use that lookup protocol to bind to 
				the engine. Moreover, one part of the program can just lookup for the engine (assuming it is 
				started independently), or explicitly create the engine itself.	To summarize, in order to abstract away 
				the underlying execution platform, and to allow a source-independent deployment, a framework has 
				to provide the following elements:
				<itemizedlist>
					<listitem>an abstract description of the distributed entities of a parallel program or component,
					</listitem>
					<listitem>an external mapping of those entities to real machines, using actual creation, registry, and lookup protocols.
					</listitem>
				</itemizedlist>
			</para>
			<para>
				To reach that goal, the programming model relies on the specific notion of Virtual Nodes (VNs):
				<itemizedlist>
					<listitem>a VN is identified as a name (a simple string)
					</listitem>
					<listitem>a VN is used in a program source
					</listitem>
					<listitem>a VN is defined and configured in a deployment descriptor (XML)
					</listitem>
					<listitem>a VN, after activation, is mapped to one or to a set of actual ProActive Nodes
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Of course, distributed entities (Active Objects), are created on Nodes, not on Virtual Nodes.
 			 	There is a strong need for both Nodes and Virtual Nodes. Virtual Nodes are a much richer abstraction,
 			 	as they provide mechanisms such as set or cyclic mapping. Another key aspect is the capability to
 			 	describe and trigger the mapping of a single VN that generates the allocation of several JVMs.
 			 	This is critical if we want to get at once machines from a cluster of PCs managed through Globus or
 			 	LSF. It is even more critical in a Grid application, when trying to achieve the co-allocation of
 			 	machines from several clusters across several continents.
			</para>
			<para>
				Moreover, a Virtual Node is a concept of a distributed program or component, while a Node is actually
				a deployment concept: it is an object that lives in a JVM, hosting Active Objects. There is of 
				course a correspondence between Virtual Nodes and Nodes: the function created by the deployment, 
				the mapping. This mapping can be specified in an XML descriptor. By definition, the following 
				operations can be configured in such a deployment descriptor:
				<itemizedlist>
					<listitem>the mapping of VNs to Nodes and to JVMs</listitem>
					<listitem>the way to create or to acquire JVMs</listitem>
					<listitem>the way to register or to lookup VNs</listitem>
				</itemizedlist>
				
			</para>
		</sect2>
	</sect1>

  <sect1>
    <title>A simple migration example</title>

    <indexterm>
      <primary>Migration</primary>
    </indexterm>

    <para>This program is a very simple one: it creates an active object that
    migrates between virtual machines. It is a extension of the previous
    client-server example, the server now being mobile.</para>

    <sect2>
      <title>Required conditions</title>

      <para>The conditions for MigratableHello to be a migratable active
      object are:</para>

      <para>- it must have a constructor without parameters: this is a result
      of a ProActive restriction : the active object having to implement a
      no-arg constructor. &lt;/ p&gt;</para>

      <para>- implement the Serializable interface (as it will be transferred
      through the network).&lt;/&gt;</para>

      <para>Hello, the superclass, must be able to be serialized, in order to
      be transferred remotely. It does not have to implement directly
      java.io.Serializable, but its attributes should be serializable - or
      transient. For more information on this topic, check <xref
      linkend="Migration" /> .</para>
    </sect2>

    <sect2>
      <title>Design</title>

      <para>We want to further enhance InitializedHello it by making
      migratable: we'd like to be able to move it across virtual
      machines.</para>

      <para>Thus, we create a MigratableHello class, that derives from
      InitializedHello. This class will implement all the non-functionnal
      behavior concerning the migration, for which this example is created.
      The Hello class (and InitializedHello) is left unmodified.</para>

      <para><emphasis>Note that the migration has to be initiated <emphasis
      role="underline">by the active object itself</emphasis>. This explains
      why we have to write the moveTo method in the code of MigratableHello -
      i.e. a method that contains an explicit call to the migration primitive.
      (cf <xref linkend="Migration" /> for migration documentation
      )</emphasis></para>

      <para>MigratableHello also implements a factory method for instanciating
      itself as an active object : <literal>static MigratableHello
      createMigratableHello(String: name)</literal></para>

      <para>The class diagram for the application is the following:</para>

      <para><informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="guided_tour/pics/hello/migratablehello.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </informalfigure></para>
    </sect2>

    <sect2>
      <title>Programming</title>

      <sect3>
        <title>a) the MigratableHello class</title>

        <para>The code of the MigratableHello class is in <xref
        linkend="tutorialCodeSrc.MigratableHello.java" />.</para>

        <para>MigratableHello derives from the Hello class from the previous
        example</para>

        <para>MigratableHello being the active object itself, it has
        to:</para>

        <para>- implement the Serializable interface</para>

        <para>- provide a no-arg constructor</para>

        <para>- provide an implementation for using ProActive's migration
        mechanism.</para>

        <para>A new method getCurrentNodeLocation is added for the object to
        tell the node where it resides..</para>

        <para>A factory static method is added for ease of creation.</para>

        <para>The migration is initiated by the moveTo method:</para>

        <programlisting lang="java">/** method for migrating
* @param destination_node destination node
*/
public void moveTo(String destination_node) {
        System.out.println("\n-----------------------------");
        System.out.println("starting migration to node: " + destination_node);
        System.out.println("...");
        try {
                // THIS MUST BE THE LAST CALL OF THE METHOD
                ProActive.migrateTo(destination_node);
        } catch (MigrationException me) {
                System.out.println("migration failed: " + me.toString());
        }
}          </programlisting>

        <para>Note that the call to the ProActive primitive
        <literal>migrateTo</literal> is the last one of the method moveTo. See
        <xref linkend="Migration" /> for more information.</para>
      </sect3>

      <sect3>
        <title>c) the client class</title>

        <para>The entry point of the program is written in a separate class:
        MigratableHelloClient (see <xref
        linkend="tutorialCodeSrc.MigratableHelloClient.java" />).</para>

        <para>It takes as arguments the locations of the nodes the object will
        be migrated to.</para>

        <para>The program calls the factory method of MigratableHello to
        create an instance of an active object. It then moves it from node to
        node, pausing for a while between the transfers.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Execution</title>

      <para>- start several nodes using the <literal>startnode</literal>
      script.</para>

      <screen>windows&gt;cd scripts/windows
                                startNode.bat //localhost/n1
                                startNode.bat //localhost/n2
linux&gt;cd scripts/linux
                ./startNode.sh //localhost/n1
                ./startNode.sh //localhost/n2       </screen>

      <para>- compile and run the program (run MigratableHelloClient), passing
      in parameter the urls of the nodes you'd like the agent to migrate
      to.</para>

      <screen>cd compile
windows&gt;build.bat examples
linux&gt;build examples
cd ..       </screen>

      <para><literal>linux&gt;java
      -Djava.security.policy=scripts/proactive.java.policy
      -Dlog4j.configuration=file:scripts/proactive-log4j
      org.objectweb.proactive.examples.hello.MigratableHelloClient
      //localhost/n1 //localhost/n2</literal></para>

      <para><literal>windows&gt;java
      -Djava.security.policy=scripts\proactive.java.policy
      -Dlog4j.configuration=file:scripts\proactive-log4j
      org.objectweb.proactive.examples.hello.MigratableHelloClient
      //localhost/n1 //localhost/n2</literal></para>

      <para>- observe the instance of MigratableHello migrating:</para>

      <para><informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata fileref="guided_tour/pics/hello/agent_execution.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </informalfigure></para>

      <para>During the execution, a default node is first created. It then
      hosts the created active object. Then the active object is migrated from
      node to node, each time returning 'hello' and telling the client program
      where it is located.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>migration of graphical interfaces</title>

    <para>Graphical interfaces are not serializable, yet it is possible to
    migrate them with ProActive.</para>

    <para>The idea is to associate the graphical object to an active object.
    The active object will control the activation and desactivation of this
    graphical entity during migrations.</para>

    <para>Of course, this is a very basic example, but you can later build
    more sophisticated frames.</para>

    <sect2>
      <title>Design of the migratable application</title>

      <para>We will write a new active object class, that extends
      MigratableHello. The sayHello method will create a window containing the
      hello message. This window is defined in the class HelloFrame</para>

      <para><informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="guided_tour/pics/hello/hellogui.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </informalfigure></para>
    </sect2>

    <sect2>
      <title>Programming</title>

      <sect3>
        <title>HelloFrameController</title>

        <para>The code of the HelloFrameController is in <xref
        linkend="tutorialCodeSrc.HelloFrameController.java" />.</para>

        <para>This class extends MigratableHello, and adds an activity and a
        migration strategy manager to the object .</para>

        <para>It creates a graphical frame upon call of the sayHello
        method.</para>

        <para>Here we have a more complex migration process than with the
        previous example. We need to make the graphical window disappear
        before and reappear in a new location after the migration (in this
        example though, we wait for a call to sayHello). The migration of the
        frame is actually controlled by a MigrationStrategyManager, that will
        be attached to the body of the active object.. An ideal location for
        this operation is the initActivity method (from InitActive interface),
        that we override:</para>

        <programlisting lang="java">/**
 * This method attaches a migration strategy manager to the current active object.
 * The migration strategy manager will help to define which actions to take before
 * and after migrating
 */
public void initActivity(Body body) {
        // add a migration strategy manager on the current active object
        migrationStrategyManager = new MigrationStrategyManagerImpl((Migratable) ProActive.getBodyOnThis());
        // specify what to do when the active object is about to migrate
        // the specified method is then invoked by reflection
        migrationStrategyManager.onDeparture('clean');
}          </programlisting>

        <para>The MigrationStrategyManager defines methods such as
        'onDeparture', that can be configured in the application. For example
        here, the method 'clean' will be called before the migration,
        conveniently killing the frame:</para>

        <programlisting lang="java">public void clean() {
        System.out.println("killing frame");
        helloFrame.dispose();
        helloFrame = null;
        System.out.println("frame is killed");
}          </programlisting>
      </sect3>

      <sect3>
        <title>HelloFrame</title>

        <para>This is an example of a graphical class that could be associated
        with the active object (see code in <xref
        linkend="tutorialCodeSrc.HelloFrame.java" /> ).</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Execution</title>

      <itemizedlist>
        <listitem>
          <para>Create a new class HelloFrameControllerClient: take the code
          of MigratableHelloClient used in the previous part, change the class
          declaration to HelloFrameControllerClient and replace the
          line</para>
        </listitem>
      </itemizedlist>

      <para><literal>MigratableHello migratable_hello =
      MigratableHello.createMigratableHello("agent1");</literal></para>

      <para>with</para>

      <para><literal>MigratableHello migratable_hello =
      HelloFrameController.createHelloFrameController("agent1");</literal></para>

      <itemizedlist>
        <listitem>
          <para>Similarly to the simple migration example (use the
          HelloFrameControllerClient class), you will start remote nodes and
          specify a migration path.</para>
        </listitem>

        <listitem>
          <para>you have 2 ways for handling the display of the graphical
          objects:</para>
        </listitem>
      </itemizedlist>

      <para><itemizedlist>
          <listitem>
            <para>look on the display screens of the machines</para>
          </listitem>
        </itemizedlist></para>

      <para><itemizedlist>
          <listitem>
            <para>export the displays: in startNode.sh, you should add the
            following lines before the java command:</para>

            <para><literal>DISPLAY=myhost:0 export DISPLAY</literal></para>
          </listitem>
        </itemizedlist></para>

      <para><informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata fileref="guided_tour/pics/hello/hellogui-snapshot.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </informalfigure></para>

      <para>The displayed window: it just contains a text label with the
      location of the active object.</para>
    </sect2>
  </sect1>
</chapter>