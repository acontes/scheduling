<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="../viewDocbook.css"?>
<chapter id="hands_on_programming">
  <title>Step by step tutorial</title>
<para>In this chapter we present a step by step introduction to
  programming with ProActive.</para>

  <para>The program that we will develop is a classic 'HelloWorld' example.As we
  progress through the example we 
  will increase the complexity of the example, so you get more familiar with
  different features of ProActive.</para>

  <itemizedlist>
    <listitem>
      <para>First, we will code a 'client-server' application, the server
      being an active object.</para>
    </listitem>

    <listitem>
      <para>Second, we will see how we can control the activity of an active
      object.</para>
    </listitem>

    <listitem>
      <para>Third, we will add mobility to this active object and have it migrate
      to another computer and say hello.</para>
    </listitem>

    <listitem>
      <para>In the last example we show how to compute the first N primes using several
      computers and the master-worker architecture.</para>
    </listitem>
  </itemizedlist>
		<para>
			We will also show the IC2D  view of the examples in this chapter. 
		</para>
	
	<para>
		Throughout the tutorial the classes from which we will instantiate active objects
		are represented in red in the UML diagrams.
	</para>

	<sect1 id="HelloWorld">
		<title> First Active Object Class</title>
	<para>
		Welcome to your first ProActive program! This is the simplest application that can be
		written. It is composed of two classes with a client-server structure. 
	</para>
	<figure> <title> Client-Server architecture</title>
		  <mediaobject>
          <imageobject>
            <imagedata contentwidth="100"
                       fileref="guided_tour/pics/hello/clientserver.png"
                       format="PNG" width="6in" />
          </imageobject>
        </mediaobject>
      </figure>
	<para>	
		The example illustrates the creation of an active object from the 
		<literal>HelloWorld</literal> class that will be
		used by the <literal>Main</literal> class to retrieve a string
		 and print it to the standard output.		
		The <literal>Main</literal> class corresponds to the client, and is
		 only a container for the <literal>main()</literal> method, while 
		the <literal>HelloWorld</literal> class corresponds to the server and its instance is an active object which provides a sayHello
		method as a remote service.
	</para>		
	<para>
		To safely use the <literal>HelloWorld</literal> class as an active object
		we have to meet three requirements.
	</para>
		<itemizedlist>
			<listitem><para><emphasis role="bold">no direct access to field variables</emphasis> - If
							<literal>public</literal> variables are used then the stub class generated from
							the original class may become decoupled from the original class. If a change is
							affected on the public field variable in the stub instance, the change will not be 
							 propagated to the the class instance from which the stub was generated. The safe
							 way to change variables is to set them as <literal>private</literal> and access
							 them through <literal>public get/set</literal> methods.   </para></listitem>
			
			<listitem><para><emphasis role="bold">provide a no-argument and preferably an empty constructor</emphasis> - A 
							no-argument constructor is necessary to create the stub class needed for communication.
							A stub cannot be created if there are only constructors with arguments since the 
							stub is only meant to abstract the communication from the active objects. 
							
							If there is no constructor defined, the Java compiler
							will automatically create a no-argument constructor that initializes all instance variables
							to the default value. However, if there is an already defined constructor with arguments 
							then no default no-argument constructor will be created by the compiler. In this case 							the definition of a no-argument constructor is mandatory for stub creation. The safest way is
							to always define a no-argument constructor.
							Also, the constructor should be empty so that on stub creation no 
							initialization is done on the stub.    
							 
						
						</para>	</listitem>
			<listitem><para><emphasis role="bold">provide remote functionalities as public methods with reifiable type</emphasis> - Since
			the stub is created through inheritance, the only methods it can use for communication are
			the inherited public methods from the superclass. The return types of the methods have to be 
			 reifiable  and therefore not final. ProActive provides several wrappers for Java types
			 that are final.The example uses the <literal>StringWrapper</literal> class in order to provide a wrapper for the 
			final <literal>String</literal> class.  Since ProActive uses a proxy mechanism and
			 the <literal>String</literal> class is final, it’s not
			possible to subclass a String and to perform asynchronous calls.	
			ProActive provides several wrappers for final classes: <literal>StringWrapper, BooleanWrapper, 
			IntegerWrapper, DoubleWrapper</literal> and <literal>FloatWrapper</literal>.
			 These have to be used in
			replacement of <literal>String, Boolean, Integer, Double</literal> and <literal>Float</literal>
			in classes which will be active objects. Since ProActive uses a proxy
			mechanism and theses classes are final, it’s not
			possible to subclass them and to perform asynchronous calls. The
			subclasses is necessary in order to create the stub class uses in 
			communication. 
			If you don’t use wrappers, method calls will be synchronous.
			</para>	
			<programlisting lang="java"><textobject><textdata fileref="code_snippets/helloworld_example/public_method.txt"></textdata></textobject></programlisting>
			
			</listitem>
		</itemizedlist>	
		
	<para>
		The following class meets all of the requirements above.
	</para>	
	 <programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/SimpleHelloWorld/src/active/HelloWorld.java" /></textobject></programlisting>
	
<para>We will now show how to create the server object. For now, we want the
<literal> HelloWorld</literal> active object 
 to be created on the current Node (we will see later how to distribute the program). To create an instance of
  a remotely accessible object we must use the <literal>ProActive.newActive</literal> primitive.
  <programlisting lang="java"><textobject><textdata fileref="code_snippets/helloworld_example/ao_creation.txt"></textdata></textobject></programlisting>
</para>
	<para>
		Invoking a method on a remote active object is transparent and is similar 
		for the user to  invoking a method on
		a local object of the same type. The user does not have to deal with catching exceptions
		related to the remote communication. The only modification brought to the code by ProActive
		is during the active objects creation. All the rest of the code can remain unmodified, 
		fostering software reuse.
		To invoke the sayHello method we execute:	
	<programlisting lang="java"><textobject><textdata fileref="code_snippets/helloworld_example/ao_invocation.txt" /></textobject></programlisting>

	</para>
	<para> The full code of the <literal>Main</literal> class is the following. </para>
	<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/SimpleHelloWorld/src/active/Main.java" /></textobject></programlisting>
	<sect2>
		<title>Running the HelloWorld application</title>
		<para>
		For now the application will be deployed on the local Node. To compile and run the application you need the 
		<literal> Main </literal>class, the <literal> HelloWorld </literal>class,  to
		include the following jar files: 
		  	<literal>ProActive/dist/lib/ProActive.jar</literal>,
          	<literal>ProActive/lib/javassist.jar</literal>,
          		<literal>ProActive/lib/log4j.jar</literal>, 
          		<literal>ProActive/lib/xercesImpl.jar</literal>, 
          		<literal>ProActive/lib/fractal.jar</literal>,  
          		and <literal>ProActive/lib/bouncycastle.jar</literal>
           and explicitly set the Java security policy with the  <literal>-Djava.security.policy=pathToFile</literal>
           and the logging policy with  <literal>-Dlog4j.configuration=file:proactive-log4j</literal>.
            The steps necessary are explained in <xref linkend="Installation"/>.
           
		</para>	
		<para>
			The command line for running the application is: 
			<screen>
java -Djava.security.policy=proactive.java.policy -Dlog4j.configuration=file:proactive-log4j Main 
			</screen>
		</para>
	</sect2>
	<sect2>
		<title>Monitoring The HelloWorld Application</title>
		<para>
			To see the the active object running start  IC2D and start 
			monitoring the local machine. To prevent the active object from stopping its
			thread remove from the 
			code above the line <literal>ProActive.exitSuccess();</literal>. IC2D will
			show the hostname, the node names, and the active objects running. 
		</para>
		<para>
			
			<figure>
      		<title> IC2D view of the SimpleHello example</title> 
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="guided_tour/pics/screenshots/ic2d_simplehello.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure>
		</para>
	</sect2>
	</sect1>

  <sect1>
    <title>Initialization of the active object activity</title>

    <para>Active objects, as their name indicates, have an activity of their
    own (an internal thread).By default the active object steps through
    the constructor, the <literal>initActivity</literal>, the <literal>runActivity</literal>,
     and when the <literal>terminate</literal> method is called on
    the <literal>Body</literal> of the active object through the <literal>endActivity</literal> method.
    It is possible to control the initialization, running, and ending phase of this
    thread by implementing three interfaces:<literal>InitActive</literal>,<literal>
    RunActive</literal>, and <literal>EndActive</literal>.These interfaces define the
    <literal>initActivity</literal>, <literal>runActivity</literal> and <literal>endActivity</literal>
    methods. One of the reasons for using <literal>initActivity</literal>
    method is the presence of the empty constructor in an active object. The <literal>initActivity</literal>
    method is automatically called on the creation of an active object in order to set up the 
    object without using the constructor. The <literal>runActivity</literal> method allows the user
    to control the active object request queue. By implementing the <literal>EndActive</literal> interface is also possible to 
    do clean up before the active object thread is stopped. </para>


    <para>The following example will help you to understand how and when you
    can initialize and clean the activity. The example will implement the <literal>InitActive</literal> and
    <literal>EndActive</literal> interfaces. To understand how to use the more complex
    <literal>RunActive</literal> interface read <xref linkend="ActiveObjectCreation"/> </para>


    <sect2>
      <title>Design of the application with Init activity</title>

      <para>The InitializedHelloWorld class extends the Hello class in the previous example, and implements
      the interfaces InitActive and EndActive.It acts as a server for the
      Main class.</para>

      <para><figure>
      		<title> Client-Server architecture with initialization</title> 
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="guided_tour/pics/hello/initializedhello.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    
    
    <para>
    	To implement the application we will create a class that inherits from the 
    	<literal>HelloWorld</literal> class and implements the EndActive and InitActive
    	interfaces. 
    	<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/InitializedSimpleHello/src/active/InitializedHelloWorld.java"></textdata></textobject></programlisting>
    </para>
    <para>
    	By default an active object has a never ending thread that should be stopped when the object is 
    	not needed anymore. The method <literal>terminate</literal> serves the purpose of destroying the 
    	object. However, if an explicit call to terminate the object is not made, ProActive has its own
    	distributed garbage collection system that is able to decide when an active object can be destroyed. 
    </para>
    <para>
    	In the <literal>Main</literal> class we will change the object created from <literal>HelloWorld</literal> to 
    	<literal>InitializedHelloWorld</literal> and also we will call the <literal>terminate </literal> method to 
    	destroy the object.
    	<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/InitializedSimpleHello/src/active/Main.java"></textdata></textobject></programlisting>
    	 
    </para>
    </sect2>

        
    
    <sect2>
      <title>Running the InitializedHelloWorld application</title>

      <para>To compile and run the application you need the
      	 HelloWorld class from the previous example, the new Main class, and the InitializedHelloWorld class.
      	To compile and run the application you need the 
		<literal> Main </literal>class, the <literal> HelloWorld </literal>class,  to
		include the following jar files: 
		  	<literal>ProActive/dist/lib/ProActive.jar</literal>,
          	<literal>ProActive/lib/javassist.jar</literal>,
          		<literal>ProActive/lib/log4j.jar</literal>, 
          		<literal>ProActive/lib/xercesImpl.jar</literal>, 
          		<literal>ProActive/lib/fractal.jar</literal>,  
          		and <literal>ProActive/lib/bouncycastle.jar</literal>
           and explicitly set the Java security policy with the  <literal>-Djava.security.policy=pathToFile</literal>
           and the logging policy with  <literal>-Dlog4j.configuration=file:proactive-log4j</literal>.
            The steps necessary are explained in <xref linkend="Installation"/>.
            </para>
 		<para>	The command line for running the application is: </para> 
	<para>
			<screen>
java -Djava.security.policy=proactive.java.policy -Dlog4j.configuration=file:proactive-log4j Main 
			</screen>
 	</para>
    </sect2>
  
  	<sect2>
		<title>Monitoring The InitializedHello Application</title>
		<para>
			To see the the active object running start  IC2D and start 
			monitoring the local machine. To prevent the active object from stopping its
			thread remove from the 
			code above the line <literal>ProActive.exitSuccess();</literal> and
			<literal>ao.terminate();</literal>. IC2D will
			show the hostname, the node names, and the active objects running - in
			this case InitializedHello. 
		</para>
		<para>
			<figure>
      		<title> IC2D view of the InitializedHello example</title> 
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="guided_tour/pics/screenshots/ic2d_initialized_hello.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure>
		</para>
	</sect2>
  
  
  </sect1>
  <sect1 id="deployment_guide">
  	<title>Application Deployment</title>
  	<para>
  		In the previous example the applications were deployed inside
  		the same JVM. This section will focus on showing how to deploy
  		the application on different nodes using deployment
  		descriptors.
  	</para>
  	<sect2>
  		<title>Deployment Related Concepts</title>
  		<para>
  			A first principle is to fully eliminate from the source
  			code the following elements:
  			<itemizedlist>
  				<listitem>
  					<para>machine names</para>
  				</listitem>
  				<listitem>
  					<para>creation protocols</para>
  				</listitem>
  				<listitem>
  					<para>registry lookup protocols</para>
  				</listitem>
  			</itemizedlist>
  		</para>
  		<para>
  			The goal is to deploy any application anywhere without
  			changing the source code. For instance, we must be able to
  			use various protocols, rsh, ssh, Globus, LSF, etc., for
  			the creation of the JVMs needed by the application. In the
  			same manner, the discovery of existing resources or the
  			registration of the ones created by the application can be
  			done with various protocols such as RMIregistry, Globus
  			etc. Therefore, we see that the creation, registration and
  			discovery of resources have to be done externally to the
  			application.
  		</para>
  		<para>
  			A second key principle is the capability to abstractly
  			describe an application, or part of it, in terms of its
  			conceptual activities. The description should indicate the
  			various parallel or distributed entities in the program.
  			For instance, an application that is designed to use three
  			interactive visualization nodes, a node to capture input
  			from a physics experiment, and a simulation engine
  			designed to run on a cluster of machines should somewhere
  			clearly advertise this information.
  		</para>
  		<para>
  			Now, one should note that the abstract description of an
  			application and the way to deploy it are not independent
  			piece of information. In the example just above, if there
  			is a simulation engine, it might register in a specific
  			registry protocol, and if so, the other entities of the
  			computation might have to use that lookup protocol to bind
  			to the engine. Moreover, one part of the program can just
  			lookup for the engine (assuming it is started
  			independently), or explicitly create the engine itself. To
  			summarize, in order to abstract away the underlying
  			execution platform, and to allow a source-independent
  			deployment, a framework has to provide the following
  			elements:
  			<itemizedlist>
  				<listitem>
  					<para>
  						an abstract description of the distributed
  						entities of a parallel program or component,
  					</para>
  				</listitem>
  				<listitem>
  					<para>
  						an external mapping of those entities to real
  						machines, using actual creation, registry, and
  						lookup protocols.
  					</para>
  				</listitem>
  			</itemizedlist>
  		</para>
  		<para>
  			To reach that goal, the programming model relies on the
  			specific notion of Virtual Nodes (VNs):
  			<itemizedlist>
  				<listitem>
  					<para>
  						a VN is identified as a name (a simple string)
  					</para>
  				</listitem>
  				<listitem>
  					<para>a VN is used in a program source</para>
  				</listitem>
  				<listitem>
  					<para>
  						a VN is defined and configured in a deployment
  						descriptor (XML)
  					</para>
  				</listitem>
  				<listitem>
  					<para>
  						a VN, after activation, is mapped to one or to
  						a set of actual ProActive Nodes
  					</para>
  				</listitem>
  			</itemizedlist>
  		</para>
  		<para>
  			Of course, distributed entities (Active Objects), are
  			created on Nodes, not on Virtual Nodes. There is a strong
  			need for both Nodes and Virtual Nodes. Virtual Nodes are a
  			much richer abstraction, as they provide mechanisms such
  			as set or cyclic mapping. Another key aspect is the
  			capability to describe and trigger the mapping of a single
  			VN that generates the allocation of several JVMs. This is
  			critical if we want to get at once machines from a cluster
  			of PCs managed through Globus or LSF. It is even more
  			critical in a Grid application, when trying to achieve the
  			co-allocation of machines from several clusters across
  			several continents.
  		</para>
  		<para>
  			Moreover, a Virtual Node is a concept of a distributed
  			program or component, while a Node is actually a
  			deployment concept: it is an object that lives in a JVM,
  			hosting Active Objects. There is of course a
  			correspondence between Virtual Nodes and Nodes: the
  			function created by the deployment, the mapping. This
  			mapping can be specified in an XML descriptor. By
  			definition, the following operations can be configured in
  			such a deployment descriptor:
  			<itemizedlist>
  				<listitem>
  					<para>
  						the mapping of VNs to Nodes and to JVMs
  					</para>
  				</listitem>
  				<listitem>
  					<para>the way to create or to acquire JVMs</para>
  				</listitem>
  				<listitem>
  					<para>the way to register or to lookup VNs</para>
  				</listitem>
  			</itemizedlist>

  		</para>
  	</sect2>

  	<sect2>
  		<title>Deployment Descriptor File</title>
  		<para>
  			The deployment descriptor is an XML file containing
  			information on the properties listed above. We will use a
  			simple XML file to deploy the Hello World application on a
  			remote The deployment XML file is composed of several
  			parts, each with different options. For our example we
  			will use a simple version. To find out more about
  			deployment and deployment descriptors reader
  			<xref linkend="XML_Descriptors" />
  			.
  		</para>
  		<para>
  			The document uses the
  			<ulink
  				url="http://www-sop.inria.fr/oasis/ProActive/schemas/deployment/3.3/deployment.xsd">
  				XML Schema
  			</ulink>
  			present at the site.
  		</para>
  		<para>
  			To avoid mistakes when building XML descriptors, ProActive
  			provides an XML Schema called DescriptorSchema.xsd. To
  			validate your file against this schema, the following line
  			must be put at the top of the XML document.
  		</para>

  		<programlisting lang="xml">
  			<textobject>
  				<textdata
  					fileref="code_snippets/deployment_descriptor/schema_location.txt">
  				</textdata>
  			</textobject>
  		</programlisting>
  		<para>
  			The XML file has a section for defining variables needed
  			later in the document. For our case, we define the
  			location of the ProActive and Java installations on the
  			local and remote machine. To start the JVM and use
  			ProActive on the remote machine, we need to define the
  			location of the Java and ProActive files. This can be done
  			by specifying the paths in the infrastructure section of
  			the deployment descriptor or by setting the CLASSPATH and
  			JAVA_HOME variables as described in
  			<xref linkend="Installation" />
  			.
  			<programlisting lang="xml">
  				<textobject>
  					<textdata
  						fileref="code_snippets/deployment_descriptor/variable_definition.txt">
  					</textdata>
  				</textobject>
  			</programlisting>
  		</para>
  		<para>
  			Next, we define the virtual nodes that will be used. In
  			our case we define a node that can contain several JVMs by
  			setting the multiple property.
  			<programlisting lang="xml">
  				<textobject>
  					<textdata
  						fileref="code_snippets/deployment_descriptor/component_definition.txt">
  					</textdata>
  				</textobject>
  			</programlisting>
  		</para>
  		<para>
  			The deployment part of the XML file specifies how the JVMs
  			are started and mapped on the Virtual Nodes It has two
  			parts one dealing with the mapping of the JVMs to the
  			Virtual Nodes and another related to how the JVMs are
  			created. In our case we map one JVM to the remote node and
  			define a process reference that will be used later in the
  			file (infrastructure section) to describe how the JVM is
  			started.
  			<programlisting lang="xml">
  				<textobject>
  					<textdata
  						fileref="code_snippets/deployment_descriptor/jvms.txt">
  					</textdata>
  				</textobject>
  			</programlisting>
  		</para>
  		<para>
  			Next is the infrastructure part that defines the paths to
  			the files needed, the hosts on which the JVMs are deployed
  			and which protocols are used for communication.

  			The process definition with the id
  			<literal>genericRemoteJVM</literal>
  			is necessary to tell the JVM machine how to start a node
  			on the machine that has a reference to it (
  			<literal>processReference</literal>
  			). It will use the paths provided to locate the Java and
  			ProActive files on the remote machine. Here we are using
  			rsh to start the JVM but several other protocols can be
  			used as described in
  			<xref linkend="XML_Descriptors" />
  			.
  			<programlisting lang="xml">
  				<textobject>
  					<textdata
  						fileref="code_snippets/deployment_descriptor/infrastructure.txt">
  					</textdata>
  				</textobject>
  			</programlisting>
  		</para>
  		<para>
  			To deploy on a remote machine you will need to change the
  			<literal>hostname</literal>
  			tag to fit your machine name. In our case the remote
  			machine needs to have the
  			<literal>rsh</literal>
  			service running.

  			The full deployment descriptor file:
  			<programlisting lang="xml">
  				<textobject>
  					<textdata
  						fileref="guided_tour/examples/DeployedHelloWorld/src/active/deployment.xml">
  					</textdata>
  				</textobject>
  			</programlisting>
  		</para>
  	</sect2>
  	<sect2>
  		<title>Application changes</title>

  		<para>
  			To be able to deploy on remote machines we just have to
  			use the deployment file and add a method that tells
  			ProActive to active the nodes used.
  			<figure>
  				<title>Deployed HelloWorld architecture</title>
  				<mediaobject>
  					<imageobject>
  						<imagedata contentwidth="100"
  							fileref="guided_tour/pics/hello/DeployedHelloWorld.png"
  							format="PNG" width="6in" />
  					</imageobject>
  				</mediaobject>
  			</figure>
  		</para>
  		<para>
  			We will change the
  			<literal>Main</literal>
  			class to declare and load the deployment descriptors to be
  			used. For this we will use a
  			<literal>static deploy</literal>
  			method that returns the Node on which we deploy the active
  			object. First, the method creates an object representation
  			of the deployment file, then activates all the nodes, and
  			then returns the first available node.
  		</para>
  		<programlisting lang="java">
  			<textobject>
  				<textdata
  					fileref="code_snippets/deployed_hello_example/deploy_method.txt">
  				</textdata>
  			</textobject>
  		</programlisting>


  		<para>
  			The
  			<literal>Main</literal>
  			class:
  		</para>
  		<programlisting lang="java">
  			<textobject>
  				<textdata
  					fileref="guided_tour/examples/DeployedHelloWorld/src/active/Main.java">
  				</textdata>
  			</textobject>
  		</programlisting>


  	</sect2>



  	<sect2>
  		<title>Running the DeployedHelloWorld application</title>

  		<para>
  			To compile and run the application you need the HelloWorld
  			class from the previous example, the new Main class, and
  			the InitializedHelloWorld class. To compile and run the
  			application you need the
  			<literal>Main</literal>
  			class, the
  			<literal>HelloWorld</literal>
  			class, to include the following jar files:
  			<literal>ProActive/dist/lib/ProActive.jar</literal>
  			,
  			<literal>ProActive/lib/javassist.jar</literal>
  			,
  			<literal>ProActive/lib/log4j.jar</literal>
  			,
  			<literal>ProActive/lib/xercesImpl.jar</literal>
  			,
  			<literal>ProActive/lib/fractal.jar</literal>
  			, and
  			<literal>ProActive/lib/bouncycastle.jar</literal>
  			and explicitly set the Java security policy with the
  			<literal>-Djava.security.policy=pathToFile</literal>
  			and the logging policy with
  			<literal>
  				-Dlog4j.configuration=file:proactive-log4j
  			</literal>
  			. The steps necessary are explained in
  			<xref linkend="Installation" />
  			.
  		</para>
  		<para>The command line for running the application is:</para>
  		<para>
  			<screen>
  				java -Djava.security.policy=proactive.java.policy
  				-Dlog4j.configuration=file:proactive-log4j Main
  				deployment.xml
  			</screen>
  		</para>
  	</sect2>

  	<sect2>
  		<title>Monitoring The DeployedHello Application</title>
  		<para>
  			To see the the active object running, start IC2D and start
  			monitoring the remote machine on which you deployed. To
  			prevent the active object from stopping its thread remove
  			from the code above the line
  			<literal>ProActive.exitSuccess();</literal>
  			and
  			<literal>ao.terminate();</literal>
  			. IC2D will show the hostname, the node names, and the
  			active objects running on the remote host - in this case
  			InitializedHello.
  		</para>
  		<para>
  			<figure>
  				<title>
  					IC2D view of the InitializedHello example
  				</title>
  				<mediaobject>
  					<imageobject>
  						<imagedata contentwidth="100"
  							fileref="guided_tour/pics/screenshots/ic2d_deployed_hello.png"
  							format="PNG" width="6in" />
  					</imageobject>
  				</mediaobject>
  			</figure>
  		</para>
  	</sect2>
  </sect1>

  <sect1>
    <title>A Simple Migration Example</title>

       <para>Our next example deals with migrating the active objects between 
    remote nodes. We will start the active object on one machine and then move it 
    to another one. We will need to change the descriptor file to specify the
    second virtual node and machine and add a method that enables us to 
    tell the active object to migrate. </para>
    
    <para>An active object must implement the Serializable interface (as it will be transferred
      through the network) in order to be able to migrate.
       For more information on the topic of object migration, check <xref linkend="Migration" /> .</para>
    


    <sect2>
      <title>Design of Migratable Hello</title>

      
      <para>We create a MigratableHello class, that derives from
      InitializedHello. This class will implement all the non-functional
      behavior concerning the migration, for which this example is created.
      The Hello and InitializedHello classes are left unmodified.</para>

      <para>The migration has to be initiated
      by the active object itself. We will have to write the migrate method in the code of MigratableHello -
      i.e. a method that contains an explicit call to the migration primitive.
      </para>
    
      <para>The class diagram for the application is the following:</para>

      <para><figure>
      	<title>Migratable HelloWorld architecture</title>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="guided_tour/pics/hello/MigratableHelloWorld.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Deployment descriptor change</title>
      <para>
      	In the deployment descriptor file we will define a new virtual node,
      </para>
      <para>	
      	<programlisting lang="xml"><textobject><textdata fileref="code_snippets/migratable_hello/component_definition.txt"></textdata></textobject></programlisting>
      </para>
      <para>	
      	another JVM to be started in the virtual node,
      </para>
      <para>
      	<programlisting lang="xml"><textobject><textdata fileref="code_snippets/migratable_hello/jvms.txt"></textdata></textobject></programlisting>
      </para>	
      <para>
      	 and a host on which the new virtual node will be located. 
	 
      </para>	 
      		<programlisting lang="xml"><textobject><textdata fileref="code_snippets/migratable_hello/infrastructure.txt"></textdata></textobject></programlisting>
      <para>
    	The full deployment descriptor file is:
		</para>
	<programlisting lang="xml"><textobject><textdata fileref="guided_tour/examples/MigratableHelloWorld/src/active/deployment.xml"></textdata></textobject></programlisting>
	</sect2>
	
<sect2>
	<title> Application changes </title>
	<para> We will extend the <literal>InitializedHelloWorld</literal> class and add a method that
	makes the active object instantiated from the new class able to migrate. The new class also
	has to implement the <literal>Serializable</literal> interface in order to be sent over
	the network.</para>
	<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/MigratableHelloWorld/src/active/MigratableHello.java"></textdata></textobject></programlisting>
	
	<para>
		We also have to change the <literal>Main</literal>class to retrieve the node
		to which the active object will migrate. For this we will add a method that
		returns the node contained in the virtual node on the second remote machine. 
	</para>
      	<programlisting lang="java"><textobject><textdata fileref="code_snippets/migratable_hello/node_retrieving_method.txt"></textdata></textobject></programlisting>
	<para>
		The full new <literal> Main </literal> class is: 
	</para>	
		<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/MigratableHelloWorld/src/active/Main.java"></textdata></textobject></programlisting>
	

        <para>Note that the call to the ProActive primitive
        <literal>migrateTo</literal> is the last one of the method <literal>packUpMyVariablesAndHitTheRoad </literal>.
        See   <xref linkend="Migration" /> for more information.</para>

      <para>During the execution the JVMs are started according to the descriptor and one active
      object is started on the first JVM. The active object is then migrated to the first node on each virtual node
      created, each time returning Hello and the computer on wich is located. 
    </para>
    </sect2>
    
    
       <sect2>
      <title>Running the MigratableHello application</title>

      <para>To compile and run the application you need the
      	 HelloWorld class from the previous example, the InitializedHelloWorld class, the 
      	 MigratableHello class,and the new Main class,.
      	To compile and run the application you need the 
		<literal> Main </literal>class, the <literal> HelloWorld </literal>class,  to
		include the following jar files: 
		  	<literal>ProActive/dist/lib/ProActive.jar</literal>,
          	<literal>ProActive/lib/javassist.jar</literal>,
          		<literal>ProActive/lib/log4j.jar</literal>, 
          		<literal>ProActive/lib/xercesImpl.jar</literal>, 
          		<literal>ProActive/lib/fractal.jar</literal>,  
          		and <literal>ProActive/lib/bouncycastle.jar</literal>
           and explicitly set the Java security policy with the  <literal>-Djava.security.policy=pathToFile</literal>
           and the logging policy with  <literal>-Dlog4j.configuration=file:proactive-log4j</literal>.
            The steps necessary are explained in <xref linkend="Installation"/>.</para>
 		<para>	The command line for running the application is: </para> 
	<para>
			<screen>
java -Djava.security.policy=proactive.java.policy -Dlog4j.configuration=file:proactive-log4j Main deployment.xml
			</screen>
 	</para>
    </sect2>
    
    <sect2>
		<title>Monitoring The MigratableHello Application</title>
		<para>
			To monitor the movement of the active object between hosts,
			we will add a small change to the  <literal>Main</literal> class
			in the <literal>for</literal> loop. Just add <literal> System.in.read()</literal>
			before <literal>ao.packUpMyVariablesAndHitTheRoad(node);</literal>.
			Now on each Enter press the object will migrate to the next node. 
		</para>
		<para>
			To see the the active object migrating start  IC2D and start 
			monitoring the remote machines on which the JVMs were started. On pressing Enter
			the active object will migrate from machine to machine
		</para>

		<para>
			<figure>
      		<title> IC2D view of the MigratableHello example</title> 
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="guided_tour/pics/screenshots/ic2d_migratable_hello_started.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure>
		</para>
		<para>
			With this example it is also possible to migrate the active object using IC2D.
			All you have to do is drag the active object from its node to a node on another
			JVM. The active object will migrate and then continue running.  
		</para>
		<para>
			<figure>
      		<title> IC2D view of the MigratableHello example after migration</title> 
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100"
                         fileref="guided_tour/pics/screenshots/ic2d_migratable_hello_final.png"
                         format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure>
		</para>
		
	</sect2>
	    
    </sect1><sect1>
      		<title>An Application To Find The First N Primes</title>
  		<para>In the next section we will write a  Master-Worker application to find the first N primes. </para>
	  	<sect2>
	  		<title>Application architecture </title>
			<para>
			In the application each worker knows a set of prime numbers, with zero
			numbers on creation, and learns
			new ones gradually. To determine if a number is prime or not, the master asks to each worker if
			the number can be prime according to the worker's memory. If all workers say this number
			can be prime then it is. If a number is prime is then sent randomly to one of the workers.
			The same process is used for the next number. 
	 	</para>
	 	<para><figure>
      	<title>DistributedPrimes architecture</title>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100" fileref="guided_tour/pics/hello/DistributedPrimes.png" format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>
        
	 	<para> 
			When trying to decide if 2 is prime or not, the question is asked to each worker.
			Since their local memory is empty, all will respond it can be a prime. Receiving all yes,
			the master concludes that 2 is prime and adds randomly it to the memory of one worker.
		</para>
		<figure>
			<title>Bootstrap process</title>
		  <mediaobject>
            <imageobject>
              <imagedata contentwidth="100" fileref="guided_tour/pics/hello/distributed_primes_bootstrap.png" format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure>

		<para>
			When trying to determine if 15 is prime or not the master asks all of the workers and at least one
			of them answers that it is not. The master discards the number and repeats the process with 16 
			which will also be discarded and then with 17 which will be prime. 17 will be sent randomly to one
			of the workers.  
		</para>
		<figure>
			<title>Prime checking process</title>
		  <mediaobject>
            <imageobject>
              <imagedata contentwidth="100" fileref="guided_tour/pics/hello/distributed_primes_regular.png" format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure>
        
		<para>
			This architecture is efficient at computing big sieves. If it computes only 200 primes, communication overhead
			will be big compared to computation time, but if it computes the first 10 000 000 primes,
			then this approach is effective. Distribution allows you to compute more numbers because memory
			consumption is balanced between workers and it also allows you to compute faster since solution space is explored in parallel.
		</para>
		
		
		<para>
		The worker and master classes have several methods implementing the mechanism described above. The
		master class has a method for adding workers to its list - <literal> addWorker</literal>,
		one for randomly sending primes to 	one of the workers in the list - <literal> sendPrime</literal>,
		 and a method that sends messages to the workers and prints out the primes - <literal> startComputation</literal>.
		 The worker class has a method that checks if a number is prime <literal>isPrime</literal> and a method
		 that adds a prime to its list of numbers <literal>addPrime</literal>.
		
		For this example the master and worker classes without code look like this. Try to 
		fill in the code for the methods. An example implementation is also provided below.  
		</para>
		<programlisting lang="java"><textobject><textdata fileref="code_snippets/distributed_primes/code_stub_master.txt"></textdata></textobject></programlisting>
		
		<programlisting lang="java"><textobject><textdata fileref="code_snippets/distributed_primes/code_stub_worker.txt"></textdata></textobject></programlisting>
		
		</sect2>
		<sect2> <title>DistributedPrimes Implementation </title>
		<para>
		This is one of the possible implementations. We use a simple algorithm for the <literal> isPrime </literal> method in 
		the workers, however more efficient implementations can be used. 
		In the main class we will create a master active object and several workers active objects deployed one on each machine specified in the 
		deployment descriptor. 
		</para>
		<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/DistributedPrimes/src/active/Main.java"></textdata></textobject></programlisting>
		
		<para>
		In the <literal>startComputation</literal> methode in the <literal>PrimeManager</literal> class we use a special way of calling
		the <literal>isPrime </literal> method on the workers so the answers to the requests can be received in any  order. First
		we create a Vector <literal> answers</literal>  which contains the futures from the workers. We use the static method
		 <literal> ProFuture.waitForAny(Vector)</literal> method which blocks the call until one of the futures
		stored in the Vector is updated. When one of the futures is updated we check if it is true or not and then remove it from the Vector.
		When the Vector is empty all the workers have sent their response. 
		</para>
		<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/DistributedPrimes/src/active/PrimeManager.java"></textdata></textobject></programlisting>
		<para>
		PrimeWorker class:
		</para>
		<programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/DistributedPrimes/src/active/PrimeWorker.java"></textdata></textobject></programlisting>
		</sect2> 
 		<sect2><title>Deployment Descriptor</title>
 			<para> The deployment descriptor for the DistrbutedPrimes application is similar to the
 			one from the previous examples. If you want to deploy on more machines the only change necessary
 			is adding the needed definitions for JVMs, protocols, and host in the deployment descriptor.
 			</para>  
 		</sect2>
 		    <sect2>
      <title>Running the DistributedPrimes application</title>

      <para>To compile and run the application you need the
      	 HelloWorld class from the previous example, the InitializedHelloWorld class, the 
      	 MigratableHello class,and the new Main class,.
      	To compile and run the application you need the 
		<literal> Main </literal>class, the <literal> HelloWorld </literal>class,  to
		include the following jar files: 
		  	<literal>ProActive/dist/lib/ProActive.jar</literal>,
          	<literal>ProActive/lib/javassist.jar</literal>,
          		<literal>ProActive/lib/log4j.jar</literal>, 
          		<literal>ProActive/lib/xercesImpl.jar</literal>, 
          		<literal>ProActive/lib/fractal.jar</literal>,  
          		and <literal>ProActive/lib/bouncycastle.jar</literal>
           and explicitly set the Java security policy with the  <literal>-Djava.security.policy=pathToFile</literal>
           and the logging policy with  <literal>-Dlog4j.configuration=file:proactive-log4j</literal>.
            The steps necessary are explained in <xref linkend="Installation" />.</para>
 		<para>	The command line for running the application is the following the second
 		 parameter being the number of primes compute: </para> 
	<para>
			<screen>
java -Djava.security.policy=proactive.java.policy -Dlog4j.configuration=file:proactive-log4j Main deployment.xml  10000
			</screen>
 	</para>
    </sect2>

    <sect2>
		<title>Monitoring The Distributed Primes</title>
        <para>
			To see the the DistributePrimes example running  start IC2D and start 
			monitoring the remote machines on which the JVMs were started. IC2D will show the
			active objects and the communication between them. You will see that the communication
			only takes place between the PrimeManager and the PrimeWorkers. 
		</para>
		
		<para>
			<figure>
      		<title> IC2D view of the DistributedPrimes example</title> 
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100" fileref="guided_tour/pics/screenshots/ic2d_primes.png" format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure>
		</para>
		<para>
			It is possible to migrate workers to other machines while the example is running.
			Bellow is an example of how all of the workers were moved on the same machine. 
			Because of the way the PrimeManager is designed it is impossible to move it to another machine.
			Migration happens after the current task of the active object is finished.
			Since the task of the PrimeManager is  continously running until the end of the computation,
			it is impossible to 
			move the PrimeManager to another machine.
		</para>	
	<para>
			<figure>
      		<title> IC2D view of the DistributedPrimes example after migration</title> 
          
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100" fileref="guided_tour/pics/screenshots/ic2d_primes_migrated.png" format="PNG" width="6in" />
            </imageobject>
          </mediaobject>
        </figure>
		</para>
	</sect2>
	
  </sect1>
  
  	<sect1 id="MWPI">
		<title>Master-Worker DistributedPrimes Application</title>
	<para>
		In the previous Distributed Primes example, we have used 
		a basic master-worker architecture in order to distribute the
		computation. However, the algorithm used is very inefficient as
		the master has to wait for all the workers to finish the computation
		before sending a new number to be computed. In this chapter we will rewrite the 
		algorithm to take advantage of the Master-Worker API already included
		in ProActive. 
		</para>
		<para>
		The Master-Worker API aims to simplify the distribution of computations 
		which are embarrassingly parallel. The Master-Worker API hides the active object details from
		the user allowing the distribution of computation without explicitly specifying 
		the creation and deployment of active objects.  
		
	</para>
	<para>
		We will rewrite the Primes example to take advantage of the Master-Worker 
		API. Each Worker will check if a number is prime by using the simple Euclid's 
		sieve algorithm. We are not aiming for a efficient algorithm, as there are much
		faster and more complex methods of checking for primes, but for an illustration
		of how the Master-Worker API works.   
	</para>

      <para> The Master-Worker API use a logical partition of computations and resources: </para>
      <itemizedlist>
      	<listitem> <para><emphasis> task </emphasis> - a task is logical partition of the 
	      	computation. The computation will be split into several tasks that will
	      	be assigned to workers. </para></listitem>
      	<listitem> <para> <emphasis>worker</emphasis> - a worker is logical partition of the 
	      	resources available. The workers retrieve tasks, compute them and send
	      	the results back to the master.</para>
      	</listitem>
      </itemizedlist>
      
      	<figure> <title> Architecture of Distributed Primes  Using Master-Worker API </title>
		  <mediaobject>
          <imageobject>
            <imagedata contentwidth="100"
                       fileref="guided_tour/pics/masterworker/DistributedPrimesMW.png"
                       format="PNG" width="6in" />
          </imageobject>
        </mediaobject>
      </figure>
     <sect2>
      	<title>Application components</title>
      	<para>
      		The general simple algorithm for using the Master-Worker API is the following:
      	</para>
      		<orderedlist>
	      		<listitem>Define the resources</listitem>
      			<listitem>Define the master</listitem>
      			<listitem>Define the tasks</listitem>
      			<listitem>Tell the master to solve the tasks</listitem>
      			<listitem>Retrieve the results from the workers</listitem>
      		</orderedlist>
      <para>
      	While this is the basic structure possible with the Master-Worker API, 
     	more complex algorithms are of course possible. 
      </para>
    <para>
		We follow this algorithm in our simple example.
	</para>	
	<para>
		First we define the resources to be used by specifying a deployment  descriptor:
	</para>
	
	 <programlisting lang="java"><textobject><textdata 
	 fileref="guided_tour/code_snippets/masterworker/acquire_resources.txt" /></textobject></programlisting>
	
	
	<para>To learn how deployment descriptors work read <xref linkend="deployment_guide"/>
	and <xref linkend="XML_Descriptors"/>. </para>
	
	<para>After specifying the resources we need to create a master to coordinate the
	computation: </para>
	
	<programlisting lang="java"><textobject><textdata 
	 fileref="guided_tour/code_snippets/masterworker/master.txt" /></textobject></programlisting>
	
	<para>The master has as a type <literal>ComputePrime</literal> which is a
	inner class that extends the <literal>Task</literal> interface. To create
	the master we need to specify a task the master will control and the return
	type of the method <literal>run()</literal> in the task (in our case <literal>
	Long</literal>).</para>
	
	 <programlisting lang="java"><textobject><textdata 
	 fileref="guided_tour/examples/DistributedPrimesMW/src/active/DistributedPrimesMW.java" /></textobject></programlisting>
	<para>some more info and code</para>	
		<title>Running My Great Application</title>
		<para>
			Information on running
		</para>	
		<para>
			The command line for running the application is: 
		</para>
	</sect2>
	<sect2>
		<title>Monitoring Of My Great Application</title>
		<para>
			Info on monitoring
		</para>
		<para>
			Screenshot of monitored app
		</para>
	</sect2>
	
	 </sect1>
	
  <sect1>
  </sect1>
  
  
  
  <!-- Guided tour section template 
	 
	<sect1 id="MyGreatApp">
		<title> My Great Project Title</title>
	<para>
		Overview
	</para>
	<figure> <title> Architecture title</title>
		  <mediaobject>
          <imageobject>
            <imagedata contentwidth="100"
                       fileref="guided_tour/pics/hello/clientserver.png"
                       format="PNG" width="6in" />
          </imageobject>
        </mediaobject>
      </figure>
      <para> Some description</para>
	<para>
		Class code following:
	</para>	
	 <programlisting lang="java"><textobject><textdata fileref="guided_tour/examples/SimpleHelloWorld/src/active/HelloWorld.java" /></textobject></programlisting>
	<para>some more info and code</para>	
	<sect2>
		<title>Running My Great Application</title>
		<para>
			Information on running
		</para>	
		<para>
			The command line for running the application is: 
		</para>
	</sect2>
	<sect2>
		<title>Monitoring Of My Great Application</title>
		<para>
			Info on monitoring
		</para>
		<para>
			Screenshot of monitored app
		</para>
	</sect2>
	</sect1>	 
	 -->
    
    
    
    
  
  </chapter>