<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="../viewDocbook.css"?>
<chapter id="OOSPMDJacobiexample">
    <title>SPMD PROGRAMMING</title>

    <sect1>
        <title>OO SPMD on a Jacobi example</title>

        <sect2>
            <title>Execution and first glance at the Jacobi code</title>

            <sect3>
                <title>
                    Source files:
                    ProActive/src/Examples/org/objectweb/proactive/examples/jacobi
                </title>

                <para>
                    The Jacobi example is made of two Java classes:
                </para>

                <itemizedlist>
                    <listitem>
                        <para>Jacobi.java: the main class</para>
                    </listitem>

                    <listitem>
                        <para>
                            SubMatrix.java: the class implementing the
                            SPMD code
                        </para>
                    </listitem>
                </itemizedlist>

                <para>
                    Have a first quick look at the code, especially the
                    Jacobi class, looking for the strings "ProActive",
                    "Nodes", "newSPMDGroup". The last instruction of the
                    class:
                    <literal>matrix.compute();</literal>
                    is an asynchronous group call. It sends a request to
                    all active objects in the SPMD group, triggering
                    computations in all the SubMatrix. We will get to
                    the class SubMatrix.java later on.
                </para>
            </sect3>

            <sect3>
                <title>Execution</title>

                <para>
                    ProActive examples come with scripts to easily
                    launch the execution under both Unix and Windows.For
                    Jacobi, launch:
                </para>

                <screen>ProActive/scripts/[unix|windows]/group/jacobi.[sh|bat]</screen>



                <para>
                    The computation stops after minimal difference is
                    reached between two iterations (constant MINDIFF in
                    class Jacobi.java), or after a fixed number of
                    iteration (constant ITERATIONS in class
                    Jacobi.java).
                </para>

                <para>
                    The provided script, using an XML descriptor,
                    creates 4 JVMs on the current machine. The Jacobi
                    class creates an SPMD group of 9 Active Objects; 2
                    or 3 AOs per JVM.
                </para>

                <para>
                    Look at the traces on the console upon starting the
                    script; in the current case, remember that all JVMs
                    and AOs send output to the same console. More
                    specifically, understand the following:
                </para>

                <itemizedlist>
                    <listitem>
                        <para>
                            Created a new registry on port 1099"
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            "Reading deployment descriptor ...
                            Matrix.xml "
                        </para>
                    </listitem>

                    <listitem>
                        <para>"created VirtualNode"</para>
                    </listitem>

                    <listitem>
                        <para>"**** Starting jvm on"</para>
                    </listitem>

                    <listitem>
                        <para>
                            "ClassFileServer is reading resources from
                            classpath"
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            "Detected an existing RMI Registry on port
                            1099""
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            "Generating class: ... jacobi.Stub_SubMatrix
                            "
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            "ClassServer sent class ...
                            jacobi.Stub_SubMatrix successfully"
                        </para>
                    </listitem>
                </itemizedlist>

                <para>
                    You can start IC2D (script ic2d.sh or ic2d.bat) in
                    order to visualize the JVMs and the Active Objects.
                    Just activate the "Monitoring a new host" in the
                    "Monitoring" menu at the top left. To stop the
                    Jacobi computation and all the associated AOs, and
                    JVMs, just ^C in the window where you started the
                    Jacobi script.
                </para>
            </sect3>
        </sect2>

        <sect2>
            <title>Modification and compilation</title>

            <sect3>
                <title>Source modification</title>

                <para>
                    Do a simple source modification, for instance
                    changing the values of the constants MINDIFF
                    (0.00000001 for ex) and ITERATIONS in class
                    Jacobi.java.
                </para>

                <para>
                    Caveat: Be careful, due to a shortcoming of the Java
                    make system (ant), make sure to also touch the class
                    SubMatrix.java that uses the constants.
                </para>
            </sect3>

            <sect3>
                <title>Compilation</title>

                <para>
                    ProActive distribution comes with scripts to easily
                    recompile the provided examples:
                </para>

                <screen>linux>ProActive/compile/build</screen>

                <para>or</para>

                <screen>windows>ProActive/compile/build.bat</screen>

                <para>
                    Several targets are provided (start build without
                    arguments to obtain them). In order to recompile the
                    Jacobi, just start the target that recompile all the
                    examples:
                </para>

                <screen>build examples</screen>

                <para>
                    2 source files must appear as being recompiled.
                </para>

                <para>
                    Following the recompilation, rerun the examples as
                    explained in section 1.2 above, and observe the
                    differences.
                </para>
            </sect3>
        </sect2>

        <sect2>
            <title>Detailed understanding of the OO SPMD Jacobi</title>

            <sect3>
                <title>Structure of the code</title>

                <para>
                    Within the class SubMatrix.java the following
                    methods correspond to a standard Jacobi
                    implementation, and are not specific to ProActive:
                </para>

                <itemizedlist>
                    <listitem>
                        <para>
                            <literal>internalCompute ()</literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>borderCompute ()</literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>exchange ()</literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>
                                buildFakeBorder (int size)
                            </literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>buildNorthBorder ()</literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>buildSouthBorder ()</literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>buildWestBorder ()</literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>buildEastBorder ()</literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>stop ()</literal>
                        </para>
                    </listitem>
                </itemizedlist>

                <para>
                    The methods on which asynchronous remote method
                    invocations take place are:
                </para>

                <itemizedlist>
                    <listitem>
                        <para>
                            <literal>sendBordersToNeighbors ()</literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>
                                setNorthBorder (double[] border)
                            </literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>
                                setSouthBorder (double[] border)
                            </literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>
                                setWestBorder (double[] border)
                            </literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>
                                setEastBorder (double[] border)
                            </literal>
                        </para>
                    </listitem>
                </itemizedlist>

                <para>
                    The first one sends to the appropriate neighbors the
                    appropriate values, calling set*Border() methods
                    asynchronously. Upon execution by the AO, the
                    methods set*Border() memorize locally the values
                    being received.
                </para>

                <para>
                    Notice that all those communication methods are made
                    of purely functional Java code, without any code to
                    the ProActive API.
                </para>

                <para>
                    On the contrary, the followings are ProActive
                    related aspects:
                </para>

                <itemizedlist>
                    <listitem>
                        <para>
                            <literal>buildNeighborhood ()</literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>compute ()</literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>loop ()</literal>
                        </para>
                    </listitem>
                </itemizedlist>

                <para>We will detail them in the next section.</para>

                <para>
                    Note: the classes managing topologies are still
                    under development. In the next release, the
                    repetitive and tedious topology related instructions
                    (e.g. methods buildNeighborhood) won't have to be
                    written explicitly by the user, whatever the
                    topology (2D, 3D).
                </para>
            </sect3>

            <sect3>
                <title>OO SPMD behavior</title>

                <para>
                    Let us describe the OO SPMD techniques which are
                    used and the related ProActive methods.
                </para>

                <para>
                    First of all, look for the definition and use of the
                    attribute "asyncRefToMe". Using the primitive
                    "getStubOnThis()", it provides a reference to the
                    current active object
                    <emphasis>
                        on which method calls are asynchronous
                    </emphasis>
                    . It permits the AO to send requests to itself.
                </para>

                <para>For instance in</para>

                <para>
                    <literal>this.asyncRefToMe.loop();</literal>
                </para>

                <para>
                    Notice the absence of a classical loop. The method
                    "loop()" is indeed asynchronously called from
                    itself; it is not really recursive since it does not
                    have the drawback of the stack growing. It features
                    an important advantage: the AO will remain reactive
                    to other calls being sent to it. Moreover, it eases
                    reuse since it is not necessary to explicitly encode
                    within the main SPMD loop all the messages that have
                    to be taken into account. It also facilitates
                    composition since services can be called by
                    activities outside the SPMD group, they will be
                    automatically executed by the FIFO service of the
                    Active Object.
                </para>

                <para>
                    The method "buildNeighborhood ()" is called only
                    once for initialization. Using a 2D topology (Plan),
                    it constructs references to north, south, west, east
                    neighbors -- attributes with respective names. It
                    also construct dynamically the group of neighbors.
                    Starting from an empty group of type SubMatrix
                </para>

                <para>
                    <literal>
                        this.neighbors = (SubMatrix)
                        ProActiveGroup.newGroup
                    </literal>
                </para>

                <para>
                    <literal>(SubMatrix.class.getName());</literal>
                </para>

                <para>
                    such typed view of the group is used to get the
                    group view: Group neighborsGroup =
                    ProActiveGroup.getGroup(this.neighbors); Then, the
                    appropriate neighbors are added dynamically in the
                    group, e.g.:
                </para>

                <para>
                    <literal>neighborsGroup.add(this.north);</literal>
                </para>

                <para>
                    Again, the topology management classes in a future
                    release of ProActive will simplify this process.
                </para>
            </sect3>

            <sect3>
                <title>
                    Adding a method barrier for a step by step execution
                </title>

                <para>
                    Let's say we would like to control step by step the
                    execution of the SPMD code. We will add a barrier in
                    the SubMatrix.java, and control the barrier from
                    input in the Jacobi.java class.
                </para>

                <para>
                    In class SubMatrix.java, add a method
                    <literal>barrier()</literal>
                    of the form:
                </para>

                <programlisting lang="java"><![CDATA[String[] st= new String[1];
st[0]="keepOnGoing";
PASPMD.barrier(st);]]></programlisting>

                <para>
                    Do not forget to define the
                    <literal>keepOnGoing()</literal>
                    method that indeed can return void, and just be
                    empty. Find the appropriate place to call the
                    <literal>barrier()</literal>
                    method in the
                    <literal>loop()</literal>
                    method.
                </para>

                <para>
                    In class Jacobi.java, just after the
                    <literal>compute()</literal>
                    method, add an infinite loop that, upon a user's
                    return key pressed, calls the method
                    <literal>keepOnGoing()</literal>
                    on the SPMD group "matrix". Here are samples of the
                    code:
                </para>

                <programlisting lang="java"><![CDATA[while (true) {
  printMessageAndWait();
  matrix.keepOnGoing();
}
...
private static void printMessageAndWait() {

    java.io.BufferedReader d = new java.io.BufferedReader(
                                     new java.io.InputStreamReader(System.in));
    System.out.println(" --> Press return key to continue");
    System.out.println(" or Ctrl c to stop.");
    try {
        d.readLine();
        } catch (Exception e) {
        		e.printStackTrace();
        }]]></programlisting>

                <para>
                    Recompile, and execute the code. Each iteration
                    needs to be activated by hitting the return key in
                    the shell window where Jacobi was launched. Start
                    IC2D (./ic2d.sh or ic2d.bat), and visualize the
                    communications as you control them. Use the "Reset
                    Topology" button to clear communication arcs. The
                    green and red dots indicate the pending requests.
                </para>

                <para>
                    You can try and test other modifications to the
                    Jacobi code.
                </para>

                <figure>
                    <title>
                        Running the Jacobi application, and viewing with
                        IC2D
                    </title>

                    <indexterm>
                        <primary>IC2D</primary>

                        <secondary>example usage</secondary>
                    </indexterm>

                    <mediaobject>
                        <imageobject>
                            <imagedata contentwidth="100"
                                fileref="guided_tour/pics/screenshots/jacobiic2d.png"
                                format="PNG" width="6in" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </sect3>

            <sect3>
                <title>
                    Understanding various different kind of barriers
                </title>

                <para>
                    The group of neighbors built above is important wrt
                    synchronization. Below in method "loop()", an
                    efficient barrier is achieved only using the direct
                    neighbors:
                </para>

                <para>
                    <literal>
                        PASPMD.barrier("SynchronizationWithNeighbors"+
                        this.iterationsToStop, this.neighbors);
                    </literal>
                </para>

                <para>
                    This barrier takes as a parameter the group to
                    synchronize with: it will be passed only when the 4
                    neighbors in the current 2D example have reached the
                    same point. Adding the rank of the current iteration
                    allows to have a unique identifier for each instance
                    of the barrier.
                </para>

                <para>
                    Try to change the barrier instruction to a total
                    barrier:
                </para>

                <para>
                    <literal>
                        PASPMD.barrier("SynchronizationWithNeighbors"+
                        this.iterationsToStop);
                    </literal>
                </para>

                <para>
                    Then recompile and execute again. Using IC2D observe
                    that many more communications are necessary.
                </para>

                <figure>
                    <title>With all communications</title>

                    <mediaobject>
                        <imageobject>
                            <imagedata contentwidth="100"
                                fileref="guided_tour/pics/screenshots/jacobi9-allcoms.png"
                                format="PNG" width="6in" />
                        </imageobject>
                    </mediaobject>
                </figure>

                <figure>
                    <title>
                        With a barrier, there are many less
                        communications
                    </title>

                    <mediaobject>
                        <imageobject>
                            <imagedata contentwidth="100"
                                fileref="guided_tour/pics/screenshots/jacobi9-ratio-ligne.png"
                                format="PNG" width="6in" />
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    In order to get details and documentation on Groups
                    and OO SPMD, have a look at
                    <xref linkend="TypedGroupCommunication" />
                    and
                    <xref linkend="OOSPMD" />
                    .
                </para>
            </sect3>
        </sect2>

        <sect2>
            <title>Virtual Nodes and Deployment descriptors</title>

            <sect3>
                <title>Virtual Nodes</title>

                <para>
                    Now, we will return to the source code of
                    Jacobi.java to understand where and how the Virtual
                    Nodes and Nodes are being used.
                </para>
            </sect3>

            <sect3>
                <title>XML Descriptors</title>

                <para>The XML descriptor being used is:</para>

                <para>
                    <literal>ProActive/descriptors/Matrix.xml</literal>
                </para>

                <para>
                    Look for and understand the following definitions:
                </para>

                <itemizedlist>
                    <listitem>
                        <para>
                            <literal>- Virtual Node Definition</literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>
                                - Mapping of Virtual Nodes to JVM
                            </literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>- JVM Definition</literal>
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <literal>- Process Definition</literal>
                        </para>
                    </listitem>
                </itemizedlist>

                <para>
                    A detailed presentation of XML descriptors is
                    available in
                    <xref linkend="Descriptor_html_objectives" />
                    .
                </para>
            </sect3>

            <sect3>
                <title>Changing the descriptor</title>

                <para>
                    Edit the file Matrix.xml in order to change the
                    number of JVMs being used. For instance, if your
                    machine is powerful enough, start 9 JVMs, in order
                    to have a single SubMatrix per JVM.
                </para>

                <figure>
                    <title>
                        IC2D viewing the Jacobi application with 9 JVMS
                        on the same machine
                    </title>

                    <mediaobject>
                        <imageobject>
                            <imagedata contentwidth="100"
                                fileref="guided_tour/pics/screenshots/jacobiic2d9vm.png"
                                format="PNG" width="6in" />
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    You do not need to recompile, just restart the
                    execution. Use IC2D to visualize the differences in
                    the configuration.
                </para>
            </sect3>
        </sect2>

        <sect2>
            <title>Execution on several machines and Clusters</title>

            <sect3>
                <title>Execution on several machines in the room</title>

                <para>
                    <emphasis role="bold">
                        Explicit machine names
                    </emphasis>
                    <literal>
                        ProActive/examples/descriptors/Matrix.xml
                    </literal>
                    is the XML deployment file used in this tutorial to
                    start 4 jvms on the local machine. This behavior is
                    achieved by referencing in the creation tag of
                    <emphasis role="bold">
                        Jvm1, Jvm2, Jvm3, Jvm4
                    </emphasis>
                    a
                    <emphasis role="bold">jvmProcess</emphasis>
                    named with the id
                    <emphasis role="bold">localProcess</emphasis>
                    . To summarize briefly at least one
                    <emphasis role="bold">jvmProcess</emphasis>
                    must be defined in an xml deployment file. When this
                    process is referenced directly in the creation part
                    of the jvm definition (like the example below), the
                    jvm will be created locally. On the other hand, if
                    this process is referenced by another process(
                    <emphasis role="bold">rshProcess</emphasis>
                    for instance, this is the case in the next example),
                    the jvm will be created remotely using the related
                    protocol (rsh in the next example).
                </para>

                <para>
                    Note that several
                    <emphasis role="bold">jvmProcesses</emphasis>
                    can be defined, for instance in order to specify
                    different jvm configurations (e.g classpath, java
                    path,...).
                </para>

                <programlisting lang="xml"><![CDATA[<ProActiveDescriptor
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation=
 "http://www-sop.inria.fr/oasis/proactive/schema/3.2/DescriptorSchema.xsd">  
  <componentDefinition>
   <virtualNodesDefinition>
    <virtualNode name="matrixNode"
 property="multiple"/>
   </virtualNodesDefinition>
  </componentDefinition>
  <deployment>
   <mapping>
    <map virtualNode="matrixNode">
     <jvmSet>
      <vmName value="Jvm1"/>
      <vmName value="Jvm2"/>
      <vmName value="Jvm3"/>
      <vmName value="Jvm4"/>
     </jvmSet>
    </map>
   </mapping>
   <jvms>
    <jvm name="Jvm1">
     <creation>
      <processReference refid="localProcess"/>
     </creation>
    </jvm>
    <jvm name="Jvm2">
     <creation>
      <processReference refid="localProcess"/>
     </creation>
    </jvm>
    <jvm name="Jvm3">
     <creation>
      <processReference refid="localProcess"/>
     </creation>
    </jvm>
    <jvm name="Jvm4">
     <creation>
      <processReference refid="localProcess"/>
     </creation>
    </jvm>
   </jvms>
  </deployment>
  <infrastructure>
   <processes>
    <processDefinition id="localProcess">
     <jvmProcess
      class="org.objectweb.proactive.core.process.JVMNodeProcess"/>
    </processDefinition>
   </processes>
  </infrastructure>
  </ProActiveDescriptor>]]></programlisting>

                <para>
                    Modify your XML deployment file to use the current
                    JVM (i.e the JVM reading the descriptor) and also to
                    start 4 JVMs on remote machines using
                    <emphasis role="bold">rsh protocol</emphasis>
                    .
                </para>

                <para>
                    Use IC2D to visualize the machines ("titi", "toto",
                    "tata" and "tutu" in this example) and the JVMs
                    being launched on them.
                </para>

                <programlisting lang="xml"><![CDATA[<ProActiveDescriptor
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation=
 "http://www-sop.inria.fr/oasis/proactive/schema/3.2/DescriptorSchema.xsd">  
  <componentDefinition>
   <virtualNodesDefinition>
    <virtualNode name="matrixNode"
 property="multiple"/>
   </virtualNodesDefinition>
  </componentDefinition>
  <deployment>
   <mapping>
    </map>
    <map virtualNode="matrixNode">
     <jvmSet>
      <currentJvm />
      <vmName value="Jvm1"/>
      <vmName value="Jvm2"/>
      <vmName value="Jvm3"/>
      <vmName value="Jvm4"/>
     </jvmSet>
    </map>
   </mapping>
   <jvms>
    <jvm name="Jvm1">
     <creation>
      <processReference  refid="rsh_titi"/>
     </creation>
    </jvm>
    <jvm name="Jvm2">
     <creation>
      <processReference refid="rsh_toto"/>
     </creation>
    </jvm>
    <jvm name="Jvm3">
     <creation>
      <processReference
 refid="rsh_tata"/>
     </creation>
    </jvm>
    <jvm name="Jvm4">
     <creation>
      <processReference
 refid="rsh_tutu"/>
     </creation>
    </jvm>
   </jvms>
  </deployment>
  <infrastructure>
   <processes>
    <processDefinition id="localProcess">
     <jvmProcess
 class="org.objectweb.proactive.core.process.JVMNodeProcess"/>
    </processDefinition>
    <processDefinition id="rsh_titi">
     <rshProcess
 class="org.objectweb.proactive.core.process.rsh.RSHProcess"
 hostname="titi">
      <processReference
 refid="localProcess"/>
     /rshProcess>
    </processDefinition>
    <processDefinition id="rsh_toto">
     <rshProcess
 class="org.objectweb.proactive.core.process.rsh.RSHProcess"
 hostname="toto">
      <processReference
 refid="localProcess"/>
     /rshProcess>
    </processDefinition>
    <processDefinition id="rsh_tata">
     <rshProcess
 class="org.objectweb.proactive.core.process.rsh.RSHProcess"
 hostname="tata">
      <processReference
 refid="localProcess"/>
     /rshProcess>
    </processDefinition>
    <processDefinition id="rsh_tutu">
     <rshProcess
 class="org.objectweb.proactive.core.process.rsh.RSHProcess"
 hostname="tutu">
      <processReference  refid="localProcess"/>
     /rshProcess>
    </processDefinition>
   </processes>
  </infrastructure>
  </ProActiveDescriptor>]]></programlisting>

                <para>
                    Pay attention of what happened to your previous XML
                    deployment file. First of all to use the current jvm
                    the following line was added just under the
                    <emphasis role="bold">jvmSet</emphasis>
                    tag
                </para>

                <programlisting lang="xml"><![CDATA[<jvmSet>
 <currentJvm />
  ...
  <jvmSet></programlisting>

        <para>Then the jvms are not created directly using the localProcess,
        but instead using other processes named <emphasis
        role="bold">rsh_titi, rsh_toto, rsh_tata, rsh_tutu</para>

        <programlisting>  <jvms>  
  <jvm name="Jvm1">
   <creation>
    <processReference refid="rsh_titi"/>
   </creation>
  </jvm>
  <jvm name="Jvm2">
   <creation>
    <processReference refid="rsh_toto"/>
   </creation>
  </jvm>
  <jvm name="Jvm3">
   <creation>
    <processReference refid="rsh_tata"/>
   </creation>
  </jvm>
  <jvm name="Jvm4">
   <creation>
    <processReference refid="rsh_tutu"/>
   </creation>
  </jvm>
  </jvms>]]></programlisting>

                <para>
                    Those processes as shown below are rsh processes.
                    Note that it is
                    <emphasis role="bold">mandatory</emphasis>
                    for such processes to reference a
                    <emphasis role="bold">jvmProcess</emphasis>
                    , in this case named with the id
                    <emphasis role="bold">localProcess</emphasis>
                    , to create, at deployment time, a jvm on machines
                    titi, toto, tata, tutu, once connected to those
                    machines with rsh.
                </para>

                <programlisting><![CDATA[<processDefinition id="localProcess">  
  <jvmProcess
 class="org.objectweb.proactive.core.process.JVMNodeProcess"/>
 </processDefinition>
 <processDefinition id="rsh_titi">
  <rshProcess
 class="org.objectweb.proactive.core.process.rsh.RSHProcess"
 hostname="titi">
   <processReference refid="localProcess"/>
  /rshProcess>
 </processDefinition>
 <processDefinition id="rsh_toto">
  <rshProcess
 class="org.objectweb.proactive.core.process.rsh.RSHProcess"
 hostname="toto">
   <processReference refid="localProcess"/>
  /rshProcess>
 </processDefinition>
 <processDefinition id="rsh_tata">
  <rshProcess
 class="org.objectweb.proactive.core.process.rsh.RSHProcess"
 hostname="tata">
   <processReference refid="localProcess"/>
  /rshProcess>
 </processDefinition>
 <processDefinition id="rsh_tutu">
  <rshProcess
 class="org.objectweb.proactive.core.process.rsh.RSHProcess"
 hostname="tutu">
   <processReference refid="localProcess"/>
  /rshProcess>
 </processDefinition>
]]></programlisting>

                <para>
                    <emphasis role="bold">
                        Using Lists of Processes
                    </emphasis>
                </para>

                <para>
                    You can also use the notion of
                    <emphasis role="bold">Process List</emphasis>
                    , which leads to the same result but often
                    simplifies the xml. Two tags are provided, the first
                    is:
                </para>

                <para>
                    <emphasis role="bold">processListbyHost</emphasis>
                </para>

                <para>
                    This allows a single definition to list all
                    hostnames on which the same JVM profile will be
                    started.
                </para>

                <programlisting lang="xml"><![CDATA[<ProActiveDescriptor
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation=
 "http://www-sop.inria.fr/oasis/proactive/schema/3.2/DescriptorSchema.xsd">      
  <componentDefinition>
   <virtualNodesDefinition>
    <virtualNode name="matrixNode"
 property="multiple"/>
   </virtualNodesDefinition>
  </componentDefinition>
  <deployment>
   <mapping>
    </map>
    <map virtualNode="matrixNode">
     <jvmSet>
      <currentJvm/>
      <vmName value="Jvm1"/>
     </jvmSet>
    </map>
   </mapping>
   <jvms>
    <jvm name="Jvm1">
     <creation>
      <processReference
 refid="rsh_list_titi_toto_tutu_tata"/>
     </creation>
    </jvm>
   </jvms>
  </deployment>
  <infrastructure>
   <processes>
    <processDefinition
 id="localProcess">
     <jvmProcess
 class="org.objectweb.proactive.core.process.JVMNodeProcess"/>
    </processDefinition>
    <processDefinition
 id="rsh_list_titi_toto_tutu_tata">
     <processListbyHost
 class="org.objectweb.proactive.core.process.rsh.RSHProcessList"
 hostlist="titi toto tata tutu">
      <processReference
 refid="localProcess"/>
     </processListbyHost>
    </processDefinition>
   </processes>
  </infrastructure>
  </ProActiveDescriptor>]]></programlisting>

                <para>
                    The second is a shorthand for a set of numbered
                    hosts with a common prefix:
                </para>

                <para>
                    <emphasis>processList</emphasis>
                </para>

                <para>
                    This is used when the machine names follow a list
                    format, for instance titi1 titi2 titi3 ... titi100
                </para>

                <programlisting><![CDATA[<ProActiveDescriptor
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation=
 "http://www-sop.inria.fr/oasis/proactive/schema/3.2/DescriptorSchema.xsd">      
  <componentDefinition>
   <virtualNodesDefinition>
    <virtualNode name="matrixNode"
 property="multiple"/>
   </virtualNodesDefinition>
  </componentDefinition>
  <deployment>
   <mapping>
    </map>
    <map virtualNode="matrixNode">
     <jvmSet>
      <currentJvm/>
      <vmName value="Jvm1"/>
     </jvmSet>
    </map>
   </mapping>
   <jvms>
    <jvm name="Jvm1">
     <creation>
      <processReference
 refid="rsh_list_titi1_to_100"/>
     </creation>
    </jvm>
   </jvms>
  </deployment>
  <infrastructure>
   <processes>
    <processDefinition
 id="localProcess">
     <jvmProcess
 class="org.objectweb.proactive.core.process.JVMNodeProcess"/>
    </processDefinition>
    <processDefinition
 id="rsh_list_titi1_to_100">
     <processList
 class="org.objectweb.proactive.core.process.rsh.RSHProcessList"
 fixedName="titi" list="[1-100]"
 domain="titi_domain">
      <processReference
 refid="localProcess"/>
     </processList>
    </processDefinition>
   </processes>
  </infrastructure>
  </ProActiveDescriptor>]]></programlisting>
            </sect3>

            <sect3>
                <title>Execution on Clusters</title>

                <para>
                    If you have access to your own cluster, configure
                    the XML descriptor to launch the Jacobi example on
                    them, using the appropriate protocol:
                </para>

                <para>ssh, LSF, PBS, Globus, etc.</para>

                <para>
                    Have a look at
                    <xref linkend="Descriptor_html_objectives" />
                    to get the format of the XML descriptor for each of
                    the supported protocols.
                </para>
            </sect3>
        </sect2>
    </sect1>

    <!-- Pi MPI -> Pi ProActive -->

    <sect1>
        <title>
            An MPI to ProActive example through an Integral Pi
            application
        </title>

        <sect2>
            <title>Introduction</title>

            <para>
                In this chapter we are going to see a simple example of
                an MPI written program ported to ProActive.
            </para>

            <para>
                First let's introduce what we are going to compute.
            </para>

            <para>
                This simple program approximates
                <ulink url="http://en.wikipedia.org/wiki/Pi">pi</ulink>
                by computing :
            </para>

            <para>
                pi =
                <emphasis role="bold">integral</emphasis>
                from
                <emphasis role="bold">0</emphasis>
                to
                <emphasis role="bold">1</emphasis>
                of
                <emphasis role="bold">
                    <emphasis role="bold">4</emphasis>
                    /( 1+x*x ) dx
                </emphasis>
            </para>

            <para>Which is approximated by :</para>

            <para>
                <emphasis role="bold">sum</emphasis>
                from
                <emphasis role="bold">k=1</emphasis>
                to
                <emphasis role="bold">N</emphasis>
                of
                <emphasis role="bold">
                    4 / ( ( 1 +( k-1/2 ) **2 )
                </emphasis>
            </para>

            <para>
                The only input data required is N, the number of
                iterations.
            </para>

            <para>Involved files :</para>

            <itemizedlist>
                <listitem>
                    <para>
                        ProActive/doc-src/mpi_files/int_pi2.c : the
                        original MPI implementation
                    </para>
                </listitem>

                <listitem>
                    <para>
                        ProActive/src/Examples/org/objectweb/proactive/examples/integralpi/Launcher.java
                        : the main class
                    </para>
                </listitem>

                <listitem>
                    <para>
                        ProActive/src/Examples/org/objectweb/proactive/examples/integralpi/Worker.java
                        : the class implementing the SPMD code
                    </para>
                </listitem>
            </itemizedlist>
        </sect2>

        <sect2>
            <title>Initialization</title>

            <sect3>
                <title>MPI Initialization primitives</title>

                <para>
                    Some basic primitives are used, notice that MPI
                    provides a rank to each process and the group size (
                    the number of involved processes ).
                </para>

                <programlisting lang="c"><![CDATA[  // All instances call startup routine to get their instance number (mynum) 
  MPI_Init(&argc, &argv);
  MPI_Comm_rank(MPI_COMM_WORLD, &mynum);
  MPI_Comm_size(MPI_COMM_WORLD, &nprocs);

  // Get a value for N
  solicit (&N, &nprocs, mynum);]]></programlisting>
            </sect3>

            <sect3>
                <title>ProActive Initialization primitives</title>

                <para>
                    First we need to create the group of workers (MPI
                    processes represented by active objects). Notice
                    that the creation of active objects is done in
                    Launcher.java.
                </para>

                <para>
                    The group of active objects is created using
                    specified parameters and the nodes specified in the
                    deployment descriptor.
                </para>

                <programlisting lang="java"><![CDATA[// Group creation           
  Worker workers = (Worker) PASPMD.newSPMDGroup(
         Worker.class.getName(), params, provideNodes(args[0]));

  // Once the group is created and the value for N is entered we can start the workers job
  // Workers starts their job and return a group of Futures
  DoubleWrapper results = workers.start( numOfIterations );]]></programlisting>

                <para>
                    As with MPI, the ProActive's SPMD layer provides
                    some initialization primitives. In Worker.java you
                    can identify this initialization. Note that
                    one-to-one communications will be done thanks to an
                    array view on the created group.
                </para>

                <programlisting lang="java"><![CDATA[// Worker initialization
  rank = PASPMD.getMyRank();
  groupSize = PASPMD.getMySPMDGroupSize();

  // Get all workers references
  workersArray = (Worker[]) ProActiveGroup.getGroup(PASPMD.getSPMDGroup()).toArray(new Worker[0]);]]></programlisting>
            </sect3>
        </sect2>

        <sect2>
            <title>Communication primitives</title>

            <sect3>
                <title>Communication pattern</title>

                <para>
                    The communication pattern is very simple, it's done
                    in 2 steps. First the process 0 Broadcasts N then
                    waits for the result from each other process and
                    sums the received values.
                </para>

                <figure>
                    <title>Communication pattern - Step 1</title>

                    <mediaobject>
                        <imageobject>
                            <imagedata
                                fileref="guided_tour/pics/IntegralPI/MPI_step1.png"
                                format="PNG" />
                        </imageobject>
                    </mediaobject>
                </figure>

                <figure>
                    <title>Communication pattern - Step 2</title>

                    <mediaobject>
                        <imageobject>
                            <imagedata
                                fileref="guided_tour/pics/IntegralPI/MPI_step2.png"
                                format="PNG" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </sect3>

            <sect3>
                <title>MPI Approach</title>

                <para>
                    The MPI implementation involves 3 communication
                    primitives :
                </para>

                <itemizedlist>
                    <listitem>
                        <para>
                            <emphasis role="bold">MPI_Send</emphasis>
                            ( Sends data to one process )
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <emphasis role="bold">MPI_Recv</emphasis>
                            ( Receives data from a sending process )
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <emphasis role="bold">MPI_Bcast</emphasis>
                            ( Broadcast a data to all processes )
                        </para>
                    </listitem>
                </itemizedlist>

                <para>
                    Please note that MPI_Bcast, MPI_Send and MPI_Recv
                    primitives are blocking.
                </para>

                <programlisting lang="java"><![CDATA[  // Get a value of N from stdin for the next run and Broadcast it
    MPI_Bcast(pN, 1, MPI_INT, source, MPI_COMM_WORLD);

  // LOCAL COMPUTATION LOOP
  // ... 

  if ( mynum == 0 ) { // Check if i'm the leader process
     for (i=1; i < nprocs; i++) {
        source = i;
        info = MPI_Recv(&x, 1, MPI_FLOAT, source, type, MPI_COMM_WORLD, &status); // waits the value from source process
        sum=sum+x; // sum up the receive value
     }
  } else {
     info = MPI_Send(&sum, 1, MPI_FLOAT, dest, type, MPI_COMM_WORLD); // if i'm not the process 0 i send my sum      
  }]]></programlisting>
            </sect3>

            <sect3>
                <title>ProActive Approach</title>

                <para>
                    The ProActive implementation is quite similar to MPI
                    one. The fact is that all communications in
                    ProActive are asynchronous ( non-blocking ) by
                    default, therefore we need to specify explicitly to
                    block until a specific request.
                </para>

                <programlisting lang="java"><![CDATA[  // The leader collects partial results.
  // Others just send their computed data to the rank 0.
  
  if ( rank==0 ) { // Check if i'm the leader worker 
     for ( i=1; i<groupSize; i++ ) {
         body.serve(body.getRequestQueue().blockingRemoveOldest("updateX")); // block until an updateX call
         sum += x;
     }            
  } else {
     workersArray[0].updateX(sum);
  }]]></programlisting>

                <para>
                    The leader blocks his request queue until another
                    worker will do a distant call on the leader's
                    <emphasis role="bold">updateX</emphasis>
                    method which is :
                </para>

                <programlisting>
                    public void updateX(double value){ this.x = value; }
                </programlisting>
            </sect3>

            <sect3>
                <title>MPI to ProActive Summary</title>

                <table>
                    <title>MPI to ProActive</title>

                    <tgroup cols="2">
                        <colspec colname="col1" colnum="1"
                            colwidth="2*" />

                        <colspec colname="col2" colnum="2"
                            colwidth="2*" />

                        <thead>
                            <row>
                                <entry>MPI</entry>

                                <entry>ProActive</entry>
                            </row>
                        </thead>

                        <tbody>
                            <row>
                                <entry>MPI_Init and MPI_Finalize</entry>

                                <entry>Activities creation</entry>
                            </row>

                            <row>
                                <entry>MPI_Comm_Size</entry>

                                <entry>PASPMD.getMyGroupSize</entry>
                            </row>

                            <row>
                                <entry>MPI_Comm_Rank</entry>

                                <entry>PASPMD.getMyRank</entry>
                            </row>

                            <row>
                                <entry>MPI_Send and MPI_Recv</entry>

                                <entry>Method call</entry>
                            </row>

                            <row>
                                <entry>MPI_Barrier</entry>

                                <entry>PASPMD.barrier</entry>
                            </row>

                            <row>
                                <entry>MPI_Bcast</entry>

                                <entry>Method call on a group</entry>
                            </row>

                            <row>
                                <entry>MPI_Scatter</entry>

                                <entry>
                                    Method call with a scatter group as
                                    parameter
                                </entry>
                            </row>

                            <row>
                                <entry>MPI_Gather</entry>

                                <entry>
                                    Result of a group communication
                                </entry>
                            </row>

                            <row>
                                <entry>MPI_Reduce</entry>

                                <entry>Programmer's method</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </sect3>
        </sect2>

        <sect2>
            <title>Running ProActive example</title>

            <sect3>
                <title>Running ProActive example</title>

                <para>
                    In ProActive/scripts/unix or windows run
                    integralpi.sh or .bat, you can specify the number of
                    workers from the command line. Feel free to edit
                    scripts to specify another deployment descriptor.
                </para>

                <screen><![CDATA[bash-3.00$ ./integralpi.sh

--- IntegralPi --------------------------------------------------
The number of workers is 4
 --> This ClassFileServer is reading resources from classpath 2011
Created a new registry on port 1099
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
************* Reading deployment descriptor: file:./../../descriptors/Matrix.xml ********************
created VirtualNode name=matrixNode
**** Starting jvm on amda.inria.fr
**** Starting jvm on amda.inria.fr
**** Starting jvm on amda.inria.fr
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
 --> This ClassFileServer is reading resources from classpath 2012
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
 --> This ClassFileServer is reading resources from classpath 2013
 --> This ClassFileServer is reading resources from classpath 2014
**** Starting jvm on amda.inria.fr
Detected an existing RMI Registry on port 1099
Detected an existing RMI Registry on port 1099
Detected an existing RMI Registry on port 1099
ProActive Security Policy (proactive.runtime.security) not set. Runtime Security disabled
 --> This ClassFileServer is reading resources from classpath 2015
//amda.inria.fr/matrixNode2048238867 successfully bound in registry at //amda.inria.fr/matrixNode2048238867
**** Mapping VirtualNode matrixNode with Node: //amda.inria.fr/matrixNode2048238867 done
//amda.inria.fr/matrixNode690267632 successfully bound in registry at //amda.inria.fr/matrixNode690267632
**** Mapping VirtualNode matrixNode with Node: //amda.inria.fr/matrixNode690267632 done
//amda.inria.fr/matrixNode1157915128 successfully bound in registry at //amda.inria.fr/matrixNode1157915128
**** Mapping VirtualNode matrixNode with Node: //amda.inria.fr/matrixNode1157915128 done
Detected an existing RMI Registry on port 1099
//amda.inria.fr/matrixNode-814241328 successfully bound in registry at //amda.inria.fr/matrixNode-814241328
**** Mapping VirtualNode matrixNode with Node: //amda.inria.fr/matrixNode-814241328 done
4 nodes found
Generating class : pa.stub.org.objectweb.proactive.examples.integralpi.Stub_Worker

Enter the number of iterations (0 to exit) : 100000
Generating class : pa.stub.org.objectweb.proactive.examples.integralpi.Stub_Worker
Generating class : pa.stub.org.objectweb.proactive.examples.integralpi.Stub_Worker
Generating class : pa.stub.org.objectweb.proactive.examples.integralpi.Stub_Worker
Generating class : pa.stub.org.objectweb.proactive.examples.integralpi.Stub_Worker

         Worker 2 Calculated x = 0.7853956634245252 in 43 ms


         Worker 3 Calculated x = 0.7853906633745299 in 30 ms


         Worker 1 Calculated x = 0.7854006634245316 in 99 ms


         Worker 0 Calculated x = 3.141592653598117 in 12 ms


Calculated PI is 3.141592653598117 error is 8.324008149429574E-12

Enter the number of iterations (0 to exit) :  ]]></screen>
            </sect3>
        </sect2>
    </sect1>
</chapter>