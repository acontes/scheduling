<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="../viewDocbook.css"?>
<chapter id="nbody">
    <title>The nbody example</title>
    <sect1>
        <title>
            Using facilities provided by ProActive on a complete example
        </title>
        <sect2>
            <title>Rationale and overview</title>
            <para>
                This section of the guided tour goes through the
                different steps that you would take in writing an
                application with ProActive, from a simple design, to a
                more complicated structure. This is meant to help you
                get familiar with the Group facilities offered by
                ProActive. Please take note that this page tries to take
                you through the progression, step by step. You may find
                some
                <ulink
                    url="http://www-sop.inria.fr/oasis/proactive/apps/nbody.html">
                    more information
                </ulink>
                , mainly on the design, on the web page of the
                <ulink
                    url="http://www-sop.inria.fr/oasis/proactive/apps/">
                    applications/examples
                </ulink>
                of ProActive. This is a snapshot of the ProActive nbody
                example running on 3 hosts with 8 bodies:
            </para>
            <para>
                <figure>
                    <title>
                        NBody screenshot, with 3 hosts and 8 bodies
                    </title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                                fileref="guided_tour/pics/nbody/gui.png"
                                format="PNG" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>
            <para>
                <figure>
                    <title>
                        NBody screenshot, with the application GUI and
                        Java3D installed
                    </title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                                fileref="guided_tour/pics/nbody/gui3d.png"
                                format="PNG" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>
            <para>
                n-body is a classic problem. It consists in working out
                the position of bodies in space, which depend only on
                the gravitational forces that apply to them. A good
                introduction to the problem is given
                <ulink
                    url="http://www.cs.berkeley.edu/%7Esouravc/cs267/nbody.htm">
                    here
                </ulink>
                . You may find a detailled explanation of the underlying
                mathematics
                <ulink
                    url="http://members.fortunecity.com/kokhuitan/nbody.html">
                    here
                </ulink>
                . Different ways of finding numerical solutions are
                given
                <ulink url="http://www.amara.com/papers/nbody.html">
                    here
                </ulink>
                .
            </para>
            <para>
                In short, one considers several bodies (sometimes called
                particles) in space, where the only force is due to
                gravity. When only two bodies are at hand, this is
                expressed as
            </para>
            <para>
                <informaltable colsep="0" frame="none">
                    <tgroup cols="2">
                        <tbody>
                            <row>
                                <entry>
                                    <para>
                                        <informalfigure>
                                            <mediaobject>
                                                <imageobject>
                                                    <imagedata
                                                        fileref="guided_tour/pics/nbody/interactions.png"
                                                        format="PNG" />
                                                </imageobject>
                                            </mediaobject>
                                        </informalfigure>
                                    </para>
                                </entry>
                                <entry>
                                    <para>
                                        <informalfigure>
                                            <mediaobject>
                                                <imageobject>
                                                    <imagedata
                                                        fileref="guided_tour/pics/nbody/forces_simple.png"
                                                        format="PNG" />
                                                </imageobject>
                                            </mediaobject>
                                        </informalfigure>
                                        F
                                        <subscript>p-&gt;b</subscript>
                                        is the force that p applies on
                                        b, G is the gravitational
                                        constant, m
                                        <subscript>p</subscript>
                                        m
                                        <subscript>b</subscript>
                                        describe the mass of the bodies,
                                        r is the distance between p and
                                        b, andu is a unit vector in the
                                        direction going from p to b.
                                        When we consider all the forces
                                        that apply to one given body, we
                                        have to sum up the contribution
                                        of all the other bodies:
                                    </para>
                                    <para>
                                        <informalfigure>
                                            <mediaobject>
                                                <imageobject>
                                                    <imagedata
                                                        fileref="guided_tour/pics/nbody/forces_sum.png"
                                                        format="PNG" />
                                                </imageobject>
                                            </mediaobject>
                                        </informalfigure>
                                    </para>
                                    <para>
                                        This should be read as: the
                                        total force on the body b is the
                                        sum of all the forces applied to
                                        b, generated by all the other
                                        bodies in the system.
                                    </para>
                                    <para>
                                        This is the force that has to be
                                        computed for every body in the
                                        system. With this force, using
                                        the usual physics formulae,
                                        (Newton's second Law)
                                    </para>
                                    <para>
                                        <informalfigure>
                                            <mediaobject>
                                                <imageobject>
                                                    <imagedata
                                                        fileref="guided_tour/pics/nbody/acc.png"
                                                        format="PNG" />
                                                </imageobject>
                                            </mediaobject>
                                        </informalfigure>
                                    </para>
                                    <para>
                                        one may now compute the movement
                                        of a particle for a given time
                                        step (a the acceleration, v the
                                        velocity, x the position, t the
                                        time):
                                    </para>
                                    <para>
                                        <informalfigure>
                                            <mediaobject>
                                                <imageobject>
                                                    <imagedata
                                                        fileref="guided_tour/pics/nbody/movement_equations.png"
                                                        format="PNG" />
                                                </imageobject>
                                            </mediaobject>
                                        </informalfigure>
                                    </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
        </sect2>
        <sect2>
            <title>Usage</title>
            <para>
                With script located in the folder
                <literal>ProActive/script/[unix|windows]</literal>
                do:
            </para>
            <screen>
                $ nbody.[bat|sh] [-nodisplay | -displayft | -3d | -3dft]
                totalNbBodies maxIter
            </screen>
            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis role="bold">No parameter</emphasis>
                        starting in default mode (2D).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="bold">-nodisplay</emphasis>
                        starting in console mode.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="bold">-displayft</emphasis>
                        starting with fault-tolerance configuration.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="bold">-3d</emphasis>
                        starting GUI in 3D, must have
                        <ulink url="https://java3d.dev.java.net/">
                            Java3d
                        </ulink>
                        (≥ 1.4) installed and also must have ProActive
                        compiled with it installed.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="bold">-3dft</emphasis>
                        same as above with fault-tolerance
                        configuration.
                    </para>
                </listitem>
            </itemizedlist>
            <itemizedlist>
                <listitem>
                    <para>
                        <emphasis role="bold">totalNbBodies</emphasis>
                        is the total number of bodies, default is 4
                        bodies.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis role="bold">maxIter</emphasis>
                        is the maximun number of iterations, default is
                        10,000 iterations.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Right after starting the application, users have to
                choose one algorithm for computing. The choice is
                between:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Simplest version, one-to-one communication and
                        master.
                    </para>
                </listitem>
                <listitem>
                    <para>Group communication and master.</para>
                </listitem>
                <listitem>
                    <para>
                        Group communication, odd-even-synchronization.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Group communication, oospmd synchronization.
                    </para>
                </listitem>
                <listitem>
                    <para>Barnes-Hut.</para>
                </listitem>
            </itemizedlist>
            <para>Mouse controls with the 3D GUI:</para>
            <itemizedlist>
                <listitem>
                    <para>Left click: rotating.</para>
                </listitem>
                <listitem>
                    <para>Right click: moving the scene.</para>
                </listitem>
                <listitem>
                    <para>Scroll whell: zoom in/out</para>
                </listitem>
            </itemizedlist>
        </sect2>
        <sect2>
            <title>
                Source files:
                ProActive/src/org/objectweb/proactive/examples/nbody
            </title>
            <para>
                This guided tour is based on the files you may find in
                the directory
                ProActive/src/org/objectweb/proactive/examples/nbody.
                You'll find the following tree:
            </para>
            <para>
                <figure>
                    <title>The nbody directory structure</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                                fileref="guided_tour/pics/nbody/directory.png"
                                format="PNG" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>
            <para>
                The common directory contains files reused through the
                different versions. 'simple' is the simplest example,
                'groupcom' is the first example with Group
                communication, and 'groupdistrib' and 'groupoospmd' are
                two enhancements based on different synchronization
                schemes. 'barneshut' is a bit special, in that it
                contains a different algorithm to solve the nbody
                problem.
            </para>
        </sect2>
        <sect2>
            <title>Common files</title>
            <para>
                The files contained in 'common' are those that are
                reused throughout the different versions. Let's see what
                they do:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        First of all there are the two files called
                        Displayer.java and NBodyFrame.java. These handle
                        the graphical output of the bodies, as they move
                        about in space. They are not particularly of
                        interest, as the GUI is not the point of this
                        tutorial. Nonetheless, please note that the
                        important method here is:
                    </para>
                    <para>
                        <literal>
                            public void drawBody(int x, int y, int vx,
                            int vy, int weight, int d, int id) ;
                        </literal>
                    </para>
                    <para>
                        Taking position, velocity, diameter and a unique
                        identifier of the body, it updates the display
                        window.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Then, we have the files Force.java and
                        Planet.java. They are used to compute the
                        interaction between two distant bodies in the
                        universe. Since they are in the common
                        directory, they can be modified to include other
                        forces (for example, collision) in a simple
                        manner, which would be spread to all the
                        examples. A Planet is no more than a point in
                        space, with velocity and mass - the diameter
                        expresses the size to use for the display:
                    </para>
                    <programlisting lang="java"><![CDATA[public class Planet implements Serializable{
    public double mass;
    public double x,y,vx,vy;
    // position and velocity
    public double diameter;
    // diameter of the body, used by the Displayer
    ...]]></programlisting>
                    <para>
                        Please take note that it implements Serializable
                        because it will be sent as parameter to method
                        calls on Active Objects, but it is good practice
                        to have all your ProActive classes implement
                        Serializable. For example, migration requires
                        everything to implement it, and the same with
                        fault-tolerance....
                    </para>
                    <para>
                        The Force class is just the implementation of
                        what a physical force really is. It is the
                        implementation of a 3D vector, with the method
                        "add" following the physics rules.
                    </para>
                    <para>
                        <figure>
                            <title>
                                The equation of the force between two
                                bodies
                            </title>
                            <mediaobject>
                                <imageobject>
                                    <imagedata
                                        fileref="guided_tour/pics/nbody/forces_simple.png"
                                        format="PNG" />
                                </imageobject>
                            </mediaobject>
                        </figure>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Point3D.java and Cube.java are helper files.
                        They simply implement what a point in space
                        looks like, and what a region of space is. Of
                        course, they were created as being Serializable.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        And finally, the Start.java acts as the wrapper
                        for the main() method. There is a part which
                        reads command line parameters, counting bodies
                        and iterations, and constructing the optional
                        Displayer. Before choosing which example to run,
                        it creates the nodes required by the simulation:
                    </para>
                    <programlisting lang="java"><![CDATA[try {
	descriptorPad = PADeployment.getProactiveDescriptor(xmlFileName);
} catch (ProActiveException e) {
    abort(e);
}
descriptorPad.activateMappings();
vnode = descriptorPad.getVirtualNode("Workers");
Node[] nodes = null;
try {
	nodes = vnode.getNodes();
} catch (NodeException e) {
	abort(e);
}]]></programlisting>
                    <para>
                        The
                        <literal>Node [] nodes</literal>
                        are the different JVMs that were created on
                        possibly different machines. They are used for
                        Active Object creation. They were specified in
                        the descriptor used to deploy the application.
                        You may find more information on these in
                        <xref linkend="XML_Descriptors" />
                        , while Active Object creation is explained in
                        <xref linkend="ActiveObjectCreation" />
                        . Just as an example, in the simple package, the
                        Maestro is created on the first of these JVMs,
                        and takes three parameters, a
                        <literal>Domain []</literal>
                        , an
                        <literal>Integer</literal>
                        , and a
                        <literal>Start</literal>
                        (it will be detailed later):
                    </para>
                    <programlisting lang="java"><![CDATA[Object [] constructorParams ;
constructorParams = {domainArray, new Integer(maxIter), killsupport} ;
maestro = (Maestro) ProActive.newActive( Maestro.class.getName(), constructorParams , nodes[0] ) ;]]></programlisting>
                </listitem>
            </itemizedlist>
            <para>
                The files contained in the other directories, 'simple',
                'groupcom', 'groupdistrib' , 'groupoospmd' detail steps
                of increasing complexity, making the application use
                different concepts. 'barneshut' contains the final
                implementation, featuring the Barnes-Hut algorithm. But
                let's not go too fast. Let's have a look at the insides
                of the simplest implementation of the n-body problem.
            </para>
        </sect2>
        <sect2>
            <title>Simple Active Objects</title>
            <para>
                This is the implementation of the simplest example of
                nbody. We defined the
                <literal>Planet</literal>
                to be a passive object, and it does nothing. It is a
                container for position, velocity and mass, as we've seen
                in the description given higher up. The real actors are
                the
                <literal>Domains</literal>
                , they do all the work. Every
                <literal>Planet</literal>
                in the universe is associated with a
                <literal>Domain</literal>
                , which is an
                <literal>Active Object</literal>
                . This
                <literal>Domain</literal>
                contains the code to manage the communication of the
                possitions of the
                <literal>Planets</literal>
                during the simulation. They are created in the
                Start.java file:
            </para>
            <programlisting lang="java"><![CDATA[Rectangle universe = new Rectangle (-100,-100,100,100);
Domain [] domainArray = new Domain [totalNbBodies];
for (int  i = 0 ; i < totalNbBodies ; i++)  {
    Object [] constructorParams = new Object [] {
        new Integer(i),
        new Planet (universe)
    };
    try {
        // Create all the Domains used in the simulation
        domainArray[i] = (Domain) ProActive.newActive(
            Domain.class.getName(),
            constructorParams,
            nodes[(i+1) % nodes.length]
        );
    }
    catch (ActiveObjectCreationException e) { killsupport.abort(e); }
    catch (NodeException e) {  killsupport.abort(e); }
}]]></programlisting>
            <para>
                See how the call to
                <literal>ProActive.newActive</literal>
                creates one new
                <literal>Active Object</literal>
                , a
                <literal>Domain</literal>
                , at each iteration of the loop. The array
                <literal>nodes</literal>
                contains all the nodes on which an Active Object may be
                deployed; at each iteration, one given node, ie one JVM,
                is selected. The
                <literal>constructorParams</literal>
                are the parameters that are to be passed to the
                constructor of
                <literal>Domain</literal>
                , and since it's an
                <literal>Object []</literal>
                , the parameters may only be
                <literal>Objects</literal>
                (don't try to build constructors using ints in their
                constructor - this explains the use of the class
                <literal>Integer</literal>
                ).
            </para>
            <para>
                The
                <literal>Domains</literal>
                , once created, are initialized, and then they
                synchronize themselves by all pinging the maestro, with
                the notifyFinished call:
            </para>
            <programlisting lang="java"><![CDATA[// init workers, from the Start class
for (int i=0 ; i &lt; totalNbBodies ; i ++)
    domainArray[i].init(domainArray, displayer, maestro);
    // init method, defined within each worker
]]></programlisting>
            <programlisting lang="java"><![CDATA[public void init(Domain [] domainArray, Displayer dp, Maestro master) {
    this.neighbours = domainArray;
    .....
    maestro.notifyFinished();  // say we're ready to start
}]]></programlisting>
            <programlisting lang="java"><![CDATA[public void notifyFinished() {
    this.nbFinished ++;
    if (this.nbFinished == this.domainArray.length) {
        this.iter ++; 
        if (this.iter==this.maxIter)
            this.killsupport.quit();
            this.nbFinished = 0 ;
            for (int i= 0 ; i &lt; domainArray.length ; i++)
                this.domainArray[i].sendValueToNeighbours();
            }
        }
        ...]]></programlisting>
            <para>
                Notice how domainArray is passed to all the
                <literal>Domains</literal>
                , when calling
                <literal>init</literal>
                . This is the value assigned to the local field
                <literal>neighbours</literal>
                , which later on serves to communicate with all the
                other
                <literal>Domains</literal>
                of the simulation.
            </para>
            <para>
                The synchronization is done by the
                <literal>Maestro</literal>
                , which counts the number of
                <literal>Domains</literal>
                that have finished, and then asks them to go on to the
                next iteration. While in their execution, the
                <literal>Domains</literal>
                gather information concerning the position of all the
                other bodies, which need to be known to move the local
                <literal>Planet</literal>
                , at every time step. This is done using a push scheme.
                Instead of explicitly asking for information, this
                information is automatically issued:
            </para>
            <programlisting lang="java"><![CDATA[public void sendValueToNeighbours() {
    for (int i = 0 ; i < this.neighbours.length ; i ++)
        if (i != this.identification) // don't notify self!
             this.neighbours[i].setValue(this.info, this.identification);
             .....  
}
        
public void setValue(Planet inf, int id) {
    this.values [id] = inf;
    this.nbReceived ++ ;
    if (this.nbReceived &gt; this.nbvalues)  // This is a bad sign!
        System.err.println('Domain ' + identification + ' received too many answers');
        if (this.nbReceived == this.nbvalues) {
            this.maestro.notifyFinished();
            moveBody();
        }
}]]></programlisting>
            <para>
                This means that each
                <literal>Domain</literal>
                sends its information to all the other
                <literal>Domains</literal>
                , and then waits until it has received all the positions
                it is waiting for. The other
                <literal>Domains</literal>
                are stored as an array, which is called
                <literal>neighbours</literal>
                . You may find another view of this example on this
                <ulink
                    url="http://www-sop.inria.fr/oasis/proactive/apps/nbody-simple.html">
                    web page
                </ulink>
                .
            </para>
        </sect2>
        <sect2>
            <title>Groups of Active objects</title>
            <para>
                This is a simple improvement, which results in faster
                communication. You may have noticed the Group
                capabilities of ProActive. They give us the ability to
                call an operation on an object which is a Group, and
                have it sent to all the members of the Group. We can use
                them in this framework: first, create a Group (instead
                of having independant
                <literal>Active Objects</literal>
                ) :
            </para>
            <programlisting lang="java"><![CDATA[// in the Start class
Object [][] params = ...
Domain  domainGroup = null;
try {
    // Create all the Domains as part of a Group
    domainGroup = (Domain) ProActiveGroup.newGroup ( Domain.class.getName(), params, nodes);
}
catch ....]]></programlisting>
            <para>
                The double array params stores the parameters passed to
                the constructors of the
                <literal>Domains</literal>
                we're creating.
                <literal>Domain 0</literal>
                will have
                <literal>params[0][]</literal>
                passed as arguments,
                <literal>Domain 1 params[1][]</literal>
                , and so on. The nodes are the Nodes on which to create
                these Active Objects. Do notice the
                <literal>try... catch</literal>
                construction which is needed around any creation of
                <literal>Active Objects</literal>
                because it may raise exceptions. In this previous bit of
                code, a
                <literal>Group</literal>
                containing new
                <literal>Active Objects</literal>
                has been created and all these Objects belong to the
                group . You may have noticed that the type of the
                <literal>Group</literal>
                is Domain. It's a bit strange at first, and you may
                think this reference points to only one Active Object at
                once, but that's not true. We're accesssing all the
                objects in the group, and to be able to continue using
                the methods of the Domain class, the group is
                <emphasis role="bold">typed</emphasis>
                as
                <literal>Domain</literal>
                , and that's the reason why it's called a
                <emphasis role="bold">typed Group</emphasis>
                .
            </para>
            <para>
                Then this group is passed as a parameter to all the
                members of the Group in just one call:
            </para>
            <programlisting lang="java"><![CDATA[// Still in the Start class
domainGroup.init(domainGroup, displayer, maestro);]]></programlisting>
            <para>
                This method sets the local field as a copy of the passed
                parameter, and as such is unique. We can play around
                with it without affecting the others. So let's remove
                the local
                <literal>Domain</literal>
                from the Group, to avoid having calls on self:
            </para>
            <programlisting lang="java"><![CDATA[public void init(Domain domainGroup, Displayer dp, Maestro master) {
    this.neighbours = domainGroup;
    Group g = ProActiveGroup.getGroup(neighbours);
    g.remove(ProActive.getStubOnThis()); // no need to send information to self
    .....]]></programlisting>
            <para>
                Remember that in the previous example, the neighbours
                where stored in an array, and each was accessed in turn:
            </para>
            <programlisting lang="java"><![CDATA[for (int i = 0 ; i &lt; this.neighbours.length ; i ++) {
    if (i != this.identification) // don't notify self!
    this.neighbours[i].setValue(this.info, this.identification);
}]]></programlisting>
            <para>
                Well, that's is inefficient so replace this by the
                following code, because it works faster:
            </para>
            <para>
                <literal>
                    this.neighbours.setValue(this.info,
                    this.identification);
                </literal>
            </para>
            <para>
                This has the following meaning: call the method
                setValue, with the given parameters, on all the members
                of the Group
                <literal>neighbours</literal>
                . In one line of code, the method
                <literal>setValue</literal>
                is called on all the Active Objects in the group.
            </para>
            <para>
                You may find another view of this example on this
                <ulink
                    url="http://www-sop.inria.fr/oasis/proactive/apps/nbody-groupcom.html">
                    web page
                </ulink>
                .
            </para>
        </sect2>
        <sect2>
            <!-- TODO title might be wrong -->
            <title>Group Distribution</title>
            <para>
                Because the synchronization is centralized on one
                entity, the
                <literal>Maestro</literal>
                ? once a
                <literal>Domain</literal>
                has finished, it sends the notifyFinshed, and then sits
                idle. A way of making this better is to remove this
                bottleneck completely! This is done by using an odd-even
                scheme: if a Domain receives information from a distant
                <literal>Domain</literal>
                too early (ie in the wrong iteration), this information
                is stored, and will get used at the next iteration. In
                the meantime, the local Domain does not change its
                iteration, because it is still waiting for more results,
                in the current iteration.
            </para>
            <programlisting lang="java"><![CDATA[public void setValue(Planet inf, int receivedIter) {
    if (this.iter == receivedIter) {
        this.currentForce.add(info, inf);
        this.nbReceived ++ ;
        if (this.nbReceived == this.nbvalues)
            moveBody();
        }
        else {
            this.prematureValues.add(new Carrier (inf, receivedIter));
        }
    }]]></programlisting>
            <para>
                Also notice how the computation is done incrementally
                when the result is received (
                <literal>this.currentForce.add(info, inf);</literal>
                ), instead of when all the results have arrived. This
                allows for less time spent idle. Indeed, waiting for all
                the results before computing might leave idle time
                between setValue requests. And then, just before
                computing the new position of the body, the sum of all
                the forces has to be computed. It's better to have this
                sum ready when needed.
            </para>
            <para>
                The
                <literal>prematureValues</literal>
                Vector is the place where we put the values that arrive
                out of sync. When a value is early, it is queued there,
                and dequeued as soon as this
                <literal>Domain</literal>
                changes iteration.
            </para>
            <programlisting lang="java"><![CDATA[public void sendValueToNeighbours()  {
    reset();                  
    this.iter++;
    if (this.iter &lt; this.maxIter) {                           
        neighbours.setValue(this.info, this.iter);                      
        ... // display related code
        treatPremature();                  
    }                  
    ... // JVM destruction related code             
}]]></programlisting>
            <para>
                The treatPremature() method simply treats the values
                that were early as if they had just arrived, by calling
                the setValue method with the parameters stored.
            </para>
            <para>
                You may find another view of this example on this
                <ulink
                    url="http://www-sop.inria.fr/oasis/proactive/apps/nbody-groupdistrib.html">
                    web page
                </ulink>
                .
            </para>
        </sect2>
        <sect2>
            <title>Object Oriented SPMD Groups</title>
            <para>
                This is another way to improve the groupcom example. It
                also removes the master, but this time by inserting
                oospmd barriers, that can be thought as behaving like
                the maestro class, but faster. To create functional
                OOspmd Groups, there is a special instruction, which
                takes the same parameters as a newGroup instruction:
            </para>
            <programlisting lang="java"><![CDATA[Object [][] params =  ...
 Domain domainGroup = null;
 try {
    domainGroup = (Domain) ProSPMD.newSPMDGroup( Domain.class.getName(), params, nodes);
 }
 catch ...]]></programlisting>
            <para>
                Now, to use this OOspmd group properly, we want to use
                the barrier() methods. We put these in the Domains code,
                to do the synchronization. What happens is that each
                Domain hits the barrier call, and then waits for all the
                others to have reached it, before reading its request
                queue again.
            </para>
            <programlisting lang="java"><![CDATA[public void sendValueToNeighbours() {
    this.neighbours.setValue(this.info, this.identification);       
    ProSPMD.barrier('barrier' + this.iter);
    this.iter++;
    this.asyncRefToSelf.moveBody();    
  ....]]></programlisting>
            <para>
                Beware, the stop-and-wait is not just after the barrier
                call, but instead blocks the request queue. So if there
                is code after that barrier, it will get executed. In
                fact, the barrier should be seen as a prioritary request
                on the queue. This explains why we had to put the code
                after the barrier as a method placed on an asynchronous
                refernce to self. If we hadn't done it that way, but
                just appended the code of that method just after the
                barrier, the call to
                <literal>moveBody()</literal>
                would be executed before the barrier execution, which is
                exactly what we don't want!
            </para>
            <para>
                You may find another view of this example on this
                <ulink
                    url="http://www-sop.inria.fr/oasis/proactive/apps/nbody-groupoospmd.html">
                    web page
                </ulink>
                .
            </para>
        </sect2>
        <sect2>
            <title>Barnes-Hut</title>
            <para>
                This way to construct the nbody simulation is based on a
                very different algorithm. This is inserted to show how
                one can express this algorithm in ProActive, but breaks
                off from the previous track, having such a different
                approach to solving the problem. Here's how it works:
            </para>
            <para>
                To avoid broadcasting to every active object the new
                position of every particle, a tree implementation can
                simplify the problem by agglomerating sets of particles
                as a single particle, with a mass equal to the sum of
                masses of the all the particles:. This is the core of
                the Barnes-Hut algorithm. References on this can be
                found for example
                <ulink
                    url="http://physics.gmu.edu/%7Elarge/lr_forces/desc/bh/bhdesc.xml">
                    here
                </ulink>
                , and
                <ulink
                    url="http://www.cita.utoronto.ca/%7Edubinski/treecode/node2.html">
                    here
                </ulink>
                . This method allows us to have a complexity brought
                down to O(N log N).
            </para>
            <para>
                In our parallel implementation, we have defined an
                <literal>Active Object</literal>
                called
                <literal>Domain</literal>
                , which represents a volume in space, and which contains
                <literal>Planets</literal>
                . It is either subdivided into smaller
                <literal>Domains</literal>
                , or is a leaf of the total tree, and then only contains
                <literal>Planets</literal>
                . A Planet is still an Object with mass, velocity and
                position, but is no longer on a one-to-one connection
                with a
                <literal>Domain</literal>
                . We have cut down communications to the biggest
                <literal>Domains</literal>
                possible : when a
                <literal>Planet</literal>
                is distant enough, its interactions are not computed,
                but it is grouped with its local neighbours to a bigger
                particle. Here is an example of the
                <literal>Domains</literal>
                which would be known by the
                <literal>Domain</literal>
                drawn in red:
            </para>
            <informaltable frame="none">
                <tgroup cols="2">
                    <tbody>
                        <row>
                            <entry>
                                <para>
                                    <informalfigure>
                                        <mediaobject>
                                            <imageobject>
                                                <imagedata
                                                    fileref="guided_tour/pics/nbody/Domain_subdivision.png"
                                                    format="PNG" />
                                            </imageobject>
                                        </mediaobject>
                                    </informalfigure>
                                </para>
                            </entry>
                            <entry>
                                <para>
                                    <informalfigure>
                                        <mediaobject>
                                            <imageobject>
                                                <imagedata
                                                    fileref="guided_tour/pics/nbody/tree.png"
                                                    format="PNG" />
                                            </imageobject>
                                        </mediaobject>
                                    </informalfigure>
                                </para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <para>
                The Domain in the lower left hand-corner, drawn in blue,
                is also divided into sub-Domains, but this needs not be
                known by the Domain in red: it assumes all the particles
                in the blue Domain are only one big one, centered at the
                center of mass of all the particles within the blue.
            </para>
            <para>
                In this version, the
                <literal>Domains</literal>
                communicate with a reduced set of other
                <literal>Domains</literal>
                , spanning on volumes of different sizes.
                Synchronization is achieved by sending explicitely
                iteration numbers, and returning when needed older
                positions. You may notice that some
                <literal>Domains</literal>
                seem desynchronized with other ones, having several
                iterations inbetween. That is no problem because if they
                then need to be synchronized and send each other
                information, a mechanism saving the older positions
                permits to send them when needed.
            </para>
            <para>
                You may find another view of this example on this
                <ulink
                    url="http://www-sop.inria.fr/oasis/proactive/apps/nbody-simple.html">
                    web page
                </ulink>
                .
            </para>
        </sect2>
        <sect2>
            <title>Conclusion</title>
            <para>
                In this guided tour, we tried to show different
                facilities provided by ProActive, based on a real
                problem (nbody). We first saw how to deploy the
                application, then tuned it by adding Group
                communication, then removed a bottleneck ( due to the
                hard synchronization ) . Finally, given is the code
                associated to a different algorithm, which cumbersomely
                shows how to get Active Objects deployed along a tree
                structure to communicate. Remember that there is
                <ulink
                    url="http://www-sop.inria.fr/oasis/proactive/apps/nbody.html">
                    another explanation
                </ulink>
                of all this on the web.
            </para>
        </sect2>
    </sect1>
</chapter>