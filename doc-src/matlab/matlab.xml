<!-- Converted by db4-upgrade version 1.0 -->

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="ProActive_Scheduler_Matlab"><info><title>ProActive Scheduler's Matlab Extension</title></info>

		<section xml:id="Scheduler_Matlab_Overwiew"><info><title>Presentation</title></info>
			
			<para>
				MATLAB is a numerical computing environment and
				programming language. Created by The MathWorks, MATLAB
				allows easy matrix manipulation, plotting of functions
				and data, implementation of algorithms, creation of user
				interfaces, and interfacing with programs in other
				languages.
			</para>
			<para>
				The Goal of ProActive Scheduler's Matlab Extension is
				to:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						allow users to easily launch Matlab scripts over
						an heterogeneous grid
					</para>
				</listitem>
				<listitem>
					<para>
						describe complex task flows in Matlab using
						human-readable XML descriptors
					</para>
				</listitem>
				<listitem>
					<para>
						Ability to communicate the result of one task as
						input of another task.
					</para>
				</listitem>
				<listitem>
					<para>
						users won't have to write any other code than
						Matlab script code
					</para>
				</listitem>
				<listitem>
					<para>
						support the following Matlab types : Double,
						Complex, Int or String Arrays. Cells. Records.
					</para>
				</listitem>
			</itemizedlist>
			<para>
				A good way to start manipulating and scheduling Matlab
				scripts is to have a look at the standalone (and simple)
				Matlab/Scilab GUI described in the ProActive documentation.
				<!-- <xref linkend="ScilabDoc"/> -->
				If you want to directly through more complex Matlab
				job scheduling, go on with the following tutorial.
			</para>
		</section>
		<section xml:id="Scheduler_Matlab_Quick_Start"><info><title>Quick Start with the Matlab Extension</title></info>
			
			<para>
				To get quickly our hands in, we'll write a very simple
				Matlab job example. This simple example will compute the
				roots of several polynomials.
			</para>
			<section xml:id="Scheduler_Matlab_Installation_Prerequisite"><info><title>Installation</title></info>
				
				<para>
					Before starting to use the Matlab interface, you
					need to install the Matlab interface to Java. You'll
					find all the instructions on
					PROACTIVE/scripts/unix/matlab/README. This interface
					will build the native libraries of the Java
					Interface to Matlab. As this library is native, it
					is important that you build it for each couple
					&lt;Matlab version, Architecture&gt; inside your
					grid infrastructure. If you are using a ProActive
					installation on a centralized NFS folder, this will
					be sufficient. Otherwise, you will have to build and
					install the native library inside your ProActive
					installation on each machine used.
				</para>
				<para>
					The good news are, if you successfully run the
					configuration script, you won't have to bother where
					Matlab is installed at runtime, the Scheduler will
					determine it for you. A little drawback to this is
					that the scheduler will use the first Matlab
					installation found on the system, so it might not do
					what you want when several Matlab installations are
					on the same machine. Further releases of the
					extension will allow a finer control over that by
					specifying Matlab's minimum version requirement
					inside job descriptors.
				</para>
			</section>
			<section xml:id="Scheduler_Matlab_Simple_Script"><info><title>
					Writing a simple example : the Matlab Script
				</title></info>
				
				<para>
					We write a very simple script which computes the
					roots of a single given polynomial.
				</para>
				<programlisting>out=roots(in);</programlisting>
				<para>
					The
					<emphasis>in</emphasis>
					and
					<emphasis>out</emphasis>
					variables are specific variables which describe the
					inputs and outputs of a Matlab script for the
					Scheduler. in and out can contain anything supported
					by the extension (Double, Complex, or String arrays,
					Cells, Records).
				</para>
			</section>
			<section xml:id="Scheduler_Matlab_Simple_Descriptor"><info><title>
					Writing a simple example : the Scheduler job
					descriptor
				</title></info>
				
				<para>
					This is a step by step guide to write this job
					descriptor.
				</para>
				<section xml:id="Scheduler_Matlab_Job_Definition"><info><title>The job definition</title></info>
					
					<para>
						The
						<emphasis>job</emphasis>
						tag is the root tag of our descriptor, it must
						have a
						<emphasis>name</emphasis>
						attribute which holds an id of the job. It is
						generally followed by a
						<emphasis>description</emphasis>
						tag which gives textual description of the job.
						Finally, the next tag will be the type of job to
						schedule. In our case it will be a
						<emphasis>taskFlow</emphasis>
						job (a job containing several tasks).
					</para>
					<programlisting xml:lang="xml">&lt;job xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="urn:proactive:jobdescriptor:0.91 http://proactive.inria.fr/schemas/jobdescriptor/0.91/schedulerjob.xsd"
    xmlns="urn:proactive:jobdescriptor:0.91" name="Matlab_job_simplest"&gt;
    &lt;description&gt;A simple Matlab job, which computes the roots of several polynomials&lt;/description&gt;
    &lt;taskFlow&gt;
      ...
    &lt;/taskFlow&gt;
&lt;/job&gt;</programlisting>
				</section>
				<section xml:id="Scheduler_Matlab_Task_Definition"><info><title>The task definition</title></info>
					
					<para>
						The
						<emphasis>task</emphasis>
						tag contains all the information for a single
						task executed on a single machine. In our
						example, this task will be the matlab script
						calculating the root of a polynomial.
					</para>
					<para>
						The task tag must contain a
						<emphasis>name</emphasis>
						attribute like the job tag. Here it contains as
						well the attribute
						<emphasis>preciousResult</emphasis>
						which tells the scheduler that we need the
						result of this task as final output for our job.
						The task tag is immediately followed by a
						<emphasis>description</emphasis>
						tag containing a textual description of this
						task.
					</para>
					<para>
						The description tag is followed by a
						<emphasis>selection</emphasis>
						tag. This tag describes a script which will
						select, among all the machine resources that the
						Scheduler controls, the specific resources
						(machine) that can effectively run this task.
						This script can for example test that Matlab is
						installed and has the right version, that
						specific Toolboxes are installed... We provide a
						generic script which simply tests if Matlab is
						installed. The script is retrieved from the URL
						<uri xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://proactive.inria.fr/userfiles/file/scripts/checkMatlab.js">http://proactive.inria.fr/userfiles/file/scripts/checkMatlab.js</uri>
					</para>
					<programlisting xml:lang="xml">&lt;task name="root1" preciousResult="true"&gt;
    &lt;description&gt;Calculates the root of a polynomial&lt;/description&gt;
    &lt;selection&gt;
        &lt;script&gt;
            &lt;file url="http://proactive.inria.fr/userfiles/file/scripts/checkMatlab.js"/&gt;
        &lt;/script&gt;
    &lt;/selection&gt;
    ...
&lt;/task&gt;</programlisting>
				</section>
				<section xml:id="Scheduler_Matlab_Script_Definition"><info><title>The Matlab script definition</title></info>
					
					<para>
						Now we finally write the script that will be
						executed on the remote machine. The
						<emphasis>javaExecutable</emphasis>
						tag is a container for our Matlab script, it's a
						java program that will connect to the Matlab
						engine and launch the given script inside it.
					</para>
					<programlisting xml:lang="xml">&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.ext.matlab.SimpleMatlab"&gt;
    &lt;parameters&gt;
        &lt;parameter name="input" value="in=[1 0 3 -2 5 1];"/&gt;
        &lt;parameter name="script" value="out=roots(in);"/&gt;
    &lt;/parameters&gt;
&lt;/javaExecutable&gt;</programlisting>
					<para>
						The javaExecutable tag contains an attribute
						<emphasis>class</emphasis>
						which tells which type of Matlab task will be
						used, here we'll describe only the task called
						<emphasis>SimpleMatlab</emphasis>
						. In
						<xref linkend="Scheduler_Matlab_AdvancedTasks"/>
						, we describe more advanced tasks. The
						javaExecutable tag contains a child tag called
						<emphasis>parameters</emphasis>
						. This tag contains a list of
						<emphasis>parameter</emphasis>
						tags which define the task parameters. Each
						parameter tag, has
						<emphasis>name/value</emphasis>
						couple attributes.
					</para>
					<para>
						The SimpleMatlab task accepts the following
						parameters:
					</para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>script</emphasis>
								: defines which matlab script will be
								launched. The value attributes will
								contain the matlab script code (useful
								for one line scripts only).
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>scriptFile</emphasis>
								: defines which matlab script will be
								launched. The file at the given path
								will be loaded.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>scriptUrl</emphasis>
								: defines which matlab script will be
								launched. The file at the given remote
								url will be loaded.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>input</emphasis>
								: defines an input script which will be
								launched before the actual matlab
								script. The value attribute needs to
								contain the script code (which must be
								single-line only).
							</para>
						</listitem>
					</itemizedlist>
				</section>
				<section xml:id="Scheduler_Matlab_Complete_Descriptor"><info><title>Complete Job Descriptor</title></info>
					
					<example xml:id="Scheduler_Matlab_Simple_Descriptor_Example"><info><title>
							Simple Matlab Job descriptor Example
						</title></info>
						
						<programlisting xml:lang="xml">
							<textobject>
								<textdata fileref="matlab/jobs_descriptors/Job_matlab_simplest.xml"/>
							</textobject>
						</programlisting>
					</example>
				</section>
			</section>
		</section>
		<section xml:id="Scheduler_Matlab_More_Complex"><info><title>A More Complex Example : a Matlab task flow</title></info>
			
			<para>
				Now we will get through a more complex example. This
				example will use an interesting feature of the Matlab
				extension : the ability to pass results of one task as
				inputs of another task. This exemple, on the contrary of
				the previous one, is not a simple parallel batch
				processing, it's a flow of tasks, which depends from
				each others.
			</para>
			<para>
				This example will compute the sum of a big,
				randomly-generated array, values taken from -50 to +50.
				The example contains 3 steps:
			</para>
			<para>
				<orderedlist>
					<listitem>
						<para>
							It splits the big array into several smaller
							arrays.
						</para>
					</listitem>
					<listitem>
						<para>
							It computes the sum of each array in
							parallel.
						</para>
					</listitem>
					<listitem>
						<para>
							It merges the results from each parallel
							sub-total to compute the final sum.
						</para>
					</listitem>
				</orderedlist>
			</para>
			<para>
				This is not, of course, a real-case example as computing
				the sum of a big array will be much faster on a single
				machine (due to the overhead of launching Java and a
				Matlab engine and the network latency), but it is meant
				to illustrate a simple task flow in Matlab.
			</para>
			<para>
				We'll go through the new concepts introduced in this
				example compared to the previous one. Have a look at the
				new job descriptor first:
			</para>
			<example xml:id="Scheduler_Matlab_Complex_Descriptor_Example"><info><title>Complex Matlab Job descriptor Example</title></info>
				
				<programlisting xml:lang="xml">
					<textobject>
						<textdata fileref="matlab/jobs_descriptors/Job_matlab.xml"/>
					</textobject>
				</programlisting>
			</example>
			<section xml:id="Scheduler_Matlab_Descriptor_Variables"><info><title>Descriptor variables</title></info>
				
				<para>
					The
					<emphasis>variables</emphasis>
					declaration allows a user to define a variable which
					can be used as a pattern in other parts of the
					descriptor. This helps writing more generic
					descriptors and replacing only the variables values
					to adapt the descriptor to many contexts. Here is
					the variables declaration in the preceding
					descriptor:
				</para>
				<programlisting xml:lang="xml">&lt;variables&gt;
    &lt;variable name="HOME" value="/user/fviale/home"/&gt;
    &lt;variable name="MATLAB_SCRIPTS" value="${HOME}/matlab"/&gt;
&lt;/variables&gt;</programlisting>
				<para>
					the
					<emphasis>variables</emphasis>
					tag contains a list of
					<emphasis>variable</emphasis>
					tags which each defines a variable through a
					<emphasis>name</emphasis>
					and a
					<emphasis>value</emphasis>
					attribute. The variable can then be used by writing
					the pattern
					<emphasis>${name_of_the_variable}</emphasis>
					. Variable can be reused inside the variable
					declaration itself, but the variables are processed
					sequentially from top to bottom. Therefore, in this
					example, In this example the MATLAB_SCRIPTS variable
					could not be used before the HOME variable.
				</para>
			</section>
			<section xml:id="Scheduler_Matlab_AdvancedTasks"><info><title>
					New Tasks : MatlabSplitter and MatlabCollector
				</title></info>
				
				<programlisting xml:lang="xml">&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.ext.matlab.MatlabSplitter"&gt;
    &lt;parameters&gt;
        &lt;parameter name="scriptFile" value="${MATLAB_SCRIPTS}/splitter.m"/&gt;
        &lt;parameter name="input" value="in=round(rand(1,1000000)*100-50)"/&gt;
        &lt;parameter name="number_of_children" value="6"/&gt;
    &lt;/parameters&gt;
&lt;/javaExecutable&gt;</programlisting>
				<programlisting xml:lang="xml">&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.ext.matlab.MatlabCollector"&gt;
    &lt;parameters&gt;
        &lt;parameter name="scriptFile" value="${MATLAB_SCRIPTS}/collector.m"/&gt;
    &lt;/parameters&gt;
&lt;/javaExecutable&gt;</programlisting>
				<para>
					Two new tasks appear in this descriptor : the
					<emphasis>MatlabSplitter</emphasis>
					and the
					<emphasis>MatlabCollector</emphasis>
					. The Splitter task is used to split an input into a
					list of several chunks. The Collector task is used
					to collect and merge the results from several
					parallel tasks. Each of these tasks come with the
					same parameter as the SimpleMatlab tasks with an
					addition: The Splitter expects an additional
					parameter called
					<emphasis>number_of_children</emphasis>
					. This parameter tells the Matlab script responsible
					for splitting in how many parts the input should be
					divided.
				</para>
			</section>
			<section xml:id="Scheduler_Matlab_Dependencies"><info><title>Task dependencies</title></info>
				
				<para>
					In order to do complex task flows, it is necessary
					to add the concept of dependencies between tasks.
				</para>
				<programlisting xml:lang="xml">&lt;task name="sum1"&gt;
    &lt;description&gt;Calculates the sum of the elements in the array&lt;/description&gt;
    &lt;depends&gt;
        &lt;task ref="splitter"/&gt;
    &lt;/depends&gt;
    ...&lt;/task&gt;</programlisting>
				<para>
					The
					<emphasis>depends</emphasis>
					tag in this task definition defines a dependency of
					the task named "sum1" to the task named "splitter".
					This means that the task sum1 will be launched afer
					the task splitter is complete, and that the outputs
					of splitter will be fed as inputs to sum1.
				</para>
				<para>
					You'll notice that in this example, all the sumX
					SimpleMatlab tasks depend from the Splitter. This
					means that the output from the Splitter will be fed
					to each sum task. On the other hand, the Collector
					depends on every sumX task. It will be launched only
					after all these tasks have completed, and the
					results of all these tasks will be the inputs of the
					Collector, you'll see on
				</para>
			</section>
			<section xml:id="Scheduler_Matlab_SimpleTaskIndex"><info><title>
					New parameter in SimpleMatlab tasks: index
				</title></info>
				
				<programlisting xml:lang="xml">&lt;task name="sum1"&gt;
    &lt;description&gt;Calculates the sum of the elements in the array&lt;/description&gt;
    &lt;depends&gt;
        &lt;task ref="splitter"/&gt;
    &lt;/depends&gt;
    &lt;selection&gt;
        &lt;script&gt;
            &lt;file url="http://proactive.inria.fr/userfiles/file/scripts/checkMatlab.js"/&gt;
        &lt;/script&gt;
    &lt;/selection&gt;
    &lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.ext.matlab.SimpleMatlab"&gt;
        &lt;parameters&gt;
            &lt;parameter name="index" value="0"/&gt;
            &lt;parameter name="scriptFile" value="${MATLAB_SCRIPTS}/summer.m"/&gt;
        &lt;/parameters&gt;
    &lt;/javaExecutable&gt;
&lt;/task&gt;</programlisting>
				<para>
					A new parameter appears in this descriptor for the
					SimpleMatlab task : the
					<emphasis>index</emphasis>
					. The parameter is related to the splitting
					mechanism. It can be defined only inside a
					SimpleMatlab task and has sense only if the Simple
					task has a Splitter task as parent. The Splitter
					sends an output in the form of a list of results to
					each child task. The same list will be sent to every
					children. Therefore, each one needs to specify at
					which index of the list it will look at. For
					example, a splitter task splits the array [1,2,3,4]
					into two arrays [1,2] and [3,4], the first child
					needs to specify index 0 and second index 1 (note
					that the indexes range from 0 to
					number_of_children-1). By specifying these indexes,
					the first child will get as input the array [1,2]
					and the second child will get [3,4].
				</para>
			</section>
			<section xml:id="Scheduler_Matlab_ComplexExamples_Scripts"><info><title>Matlab Scripts for this example</title></info>
				
				<section xml:id="ComplexExamples_Splitter_Script"><info><title>Script of the Splitter Task</title></info>
					
					<programlisting><textobject><textdata 
						fileref="../../extensions/matlab/examples/splitter.m"/></textobject></programlisting>
					<para>
						The Splitter script contains two important
						aspects:
					</para>
					<itemizedlist>
						<listitem>
							<para>
								It contains two inputs, the variable
								<emphasis>in</emphasis>
								which is fed by the "input" script of
								the splitter task, and the variable
								<emphasis>nout</emphasis>
								which contains the value of the
								<emphasis>number_of_children</emphasis>
								parameter.
							</para>
						</listitem>
						<listitem>
							<para>
								The
								<emphasis>out</emphasis>
								variable, which is the output of the
								script must be a cell array of size
								nout.
							</para>
						</listitem>
					</itemizedlist>
				</section>
				<section xml:id="ComplexExamples_Summing_Script"><info><title>Script of the Summing Task</title></info>
					
					<programlisting><textobject><textdata 
						fileref="../../extensions/matlab/examples/summer.m"/></textobject></programlisting>
				</section>
				<section xml:id="ComplexExamples_Collector_Script"><info><title>Script of the Collector Task</title></info>
					
					<programlisting><textobject><textdata 
							fileref="../../extensions/matlab/examples/collector.m"/></textobject></programlisting>
					<para>
						The important aspect of the The Collector script
						is that the input parameter
						<emphasis>in</emphasis>
						is a cell array.
					</para>
				</section>
			</section>
		</section>

</chapter>
