<!-- Converted by db4-upgrade version 1.0 -->

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="faultTolerance"><info><title>Fault-Tolerance</title></info>
 

 <indexterm><primary>Fault-Tolerance</primary></indexterm>
  
 <section><info><title>Overview</title></info>
    

    <para>ProActive can provide fault-tolerance capabilities through two
    differents protocols: a Communication-Induced Checkpointing protocol (CIC)
    or a pessimistic message logging protocol (PML). Making a ProActive
    application fault-tolerant is <emphasis role="bold">fully
    transparent</emphasis>; active objects are turned fault-tolerant using
    Java properties that can be set in the deployment descriptor
    (see <xref linkend="XML_Descriptors"/>). The programmer
    can select <emphasis>at deployment time</emphasis> the most adapted
    protocol regarding the application and the execution environment.</para>

    <para>Persistence of active objects is obtained through standard Java
    serialization; a checkpoint thus consists in an object containing a
    serialized copy of an active object and few informations related to the
    protocol. As a consequence, a fault-tolerant active object must be
    serializable.</para>

    <section><info><title>Communication Induced Checkpointing (CIC)</title></info>
      

      <para>Each active object in a CIC fault-tolerant application have to
      checkpoint at least every <emphasis role="bold">TTC</emphasis> (Time To
      Checkpoint) seconds. When all the active objects have taken a
      checkpoint, a <emphasis role="bold">global state</emphasis> is formed.
      If a failure occurs, the <emphasis>entire</emphasis> application must
      restarts from such a global state. The TTC value depends mainly on the
      assessed frequency of failures. A little TTC value leads to very
      frequent global state creation and thus to a little rollback in the
      execution in case of failure. But a little TTC value leads also to a
      bigger overhead between a non-fault-tolerant and a fault-tolerant
      execution. The TTC value can be set by the programmer in the deployment
      descriptor.</para>

      <para>The failure-free overhead induced by the CIC protocol is usually
      low, and this overhead is quasi-independent from the message
      communication rate. The counterpart is that the recovery time could be
      long since all the application must restart after the failure of one or
      more active object.</para>
    </section>

    <section><info><title>Pessimistic message logging (PML)</title></info>
      

      <para>Each active object in a PML fault-tolerant application have to
      checkpoint at least every TTC seconds and all the messages delivered to
      an active object are logged on a stable storage. There is no need for
      global synchronization as with CIC protocol, each checkpoint is
      independent: if a failure occurs, only the faulty process have to
      recover from its latest checkpoint. As for CIC protocol, the TTC value
      impact the global failure-free overhead, but the overhead is more linked
      to the communication rate of the application.</para>

      <para>Regarding the CIC protocol, the PML protocol induces a higher
      overhead on failure-free execution, but the recovery time is lower as a
      single failure does not involve all the system.</para>

    </section>
  </section>

  <section><info><title>Making a ProActive
    application fault-tolerant</title></info>
    

    <section><info><title>Resource Server</title></info>
      

      <para>To be able to recover a failed active object, the fault-tolerance
      system must have access to a <emphasis>resource server</emphasis>. A
      resource server is able to return a free node that can host the
      recovered active object.</para>

      <para>A resource server is implemented in ProActive in
      <literal>ft.servers.resource.ResourceServer</literal>. This server can
      store free nodes by two differents way:</para>

      <itemizedlist>
        <listitem>
          <para>at deployment time: the user can specify in the deployment
          descriptor a resource virtual node. Each node mapped on this virtual
          node will automaticaly register itself as free node at the specified
          resource server.</para>
        </listitem>

        <listitem>
          <para>at execution time: the resource server can use an 
           underlying p2p network (see <xref linkend="p2p"/>) to reclaim free nodes
          when a hosting node is needed.</para>
        </listitem>
      </itemizedlist>

      <para>Note that those two mechanisms can be combined. In that case, the
      resource server first provides node registered at deployment time, and
      when no more such nodes are available, the p2p network is used.</para>
    </section>

    <section><info><title>Fault-Tolerance servers</title></info>
      

      <para>Fault-tolerance mechanism needs servers for the checkpoints
      storage, the localization of the active objects, and the failure
      detection. Those servers are implemented in the current version as a
      unique server (<literal>ft.servers.FTServer</literal>), that implements
      the interfaces of each server (<literal>ft.servers.*.*</literal>). This
      global server also includes a resource server.</para>

      <para>This server is a classfile server for recovered active objects. It
      must thus have access to all classes of the application, i.e. it must be
      started with <emphasis role="bold">all classes of the application in its
      classpath</emphasis>.</para>

      <para>The global fault-tolerance server can be launched using the
      <literal>ProActive/scripts/[unix|windows]/FT/startGlobalFTServer.[sh|bat]</literal>
      script, with 5 optional parameters:</para>

      <itemizedlist>
        <listitem>
          <para>the protocol: <literal>-proto [cic|pml]</literal>. Default
          value is <literal>cic</literal>.</para>
        </listitem>

        <listitem>
          <para>the server name: <literal>-name &lt;serverName&gt;</literal>.
          The default name is FTServer.</para>
        </listitem>

        <listitem>
          <para>the port number: <literal>-port &lt;portNumber&gt;</literal>.
          The default port number is 1100.</para>
        </listitem>

        <listitem>
          <para>the fault detection period: <literal>-fdperiod
          &lt;periodInSec&gt;</literal>. This value defines the time between
          two consecutive fault detection scanning. The default value is 10
          sec. Note that an active object is considered as faulty when it
          becomes unreachable, i.e. when it becomes unable to receive a
          message from another active object.</para>
        </listitem>

        <listitem>
         <para>the URL of a p2p service (see <xref linkend="p2p"/>) that can
          be used by the resource server: <literal>-p2p &lt;serviceURL&gt;</literal>. 
          There is no default value for this
          option.</para>
        </listitem>
      </itemizedlist>

      <para>The server can also be directly launched in the java source code,
      using
      <literal>org.objectweb.proactive.core.process.JVMProcessImpl</literal>
      class:</para>

      
        <para><screen>GlobalFTServer server = new JVMProcessImpl(
         new org.objectweb.proactive.core.process.AbstractExternalProcess.StandardOutputMessageLogger());
this.server.setClassname('org.objectweb.proactive.core.body.ft.servers.StartFTServer');
this.server.startProcess();</screen></para>
      

      <para>Note that if one of the servers is unreachable when a
      fault-tolerant application is deploying, fault-tolerance is
      automatically and transparently disabled for all the application.</para>
    </section>

    <section xml:id="faultTolerance_html_configuration"><info><title>Configure fault-tolerance for a ProActive application</title></info>
      

      <para>Fault-tolerance capabilities of a ProActive application are set in
      the deployment descriptor, using the <literal>faultTolerance</literal>
      service. This service is attached to <emphasis>a virtual
      node</emphasis>: active objects that are deployed on this virtual node
      are turned fault-tolerant. This service must first defines the protocol
      that have to be used for this application. The user can select the
      appropriate protocol with the entry <literal>&lt;protocol
      type='[cic|pml]'/&gt;</literal> in the definition of the service.</para>

      <para>The service also defines <emphasis role="bold">servers
      URLs</emphasis>:</para>

      <itemizedlist>
        <listitem>
          <para><literal>&lt;globalServer url='...'/&gt;</literal> set the URL
          of a <emphasis>global</emphasis> server, i.e. a server that
          implements all needed methods for fault-tolerance mechanism (stable
          storage, fault detection, localization). If this value is set, all
          others URLs will be <emphasis>ignored</emphasis>.</para>
        </listitem>

        <listitem>
          <para><literal>&lt;checkpointServer url='...'/&gt;</literal> set the
          URL of the checkpoint server, i.e. the server where checkpoints are
          stored.</para>
        </listitem>

        <listitem>
          <para><literal>&lt;locationServer url='...'/&gt;</literal> set the
          URL of the location server, i.e. the server responsible for giving
          references on failed and recovered active objects.</para>
        </listitem>

        <listitem>
          <para><literal>&lt;recoveryProcess url='...'/&gt;</literal> set the
          URL of the recovery process, i.e. the process responsible for
          launching the recovery of the application after a failure.</para>
        </listitem>

        <listitem>
          <para><literal>&lt;resourceServer url='...'/&gt;</literal> set the
          URL of the resource server, i.e. the server responsible for
          providing free nodes that can host a recovered active object.</para>
        </listitem>
      </itemizedlist>

      <para>Finally, the <emphasis role="bold">TTC</emphasis> value is set in
      fault-tolerance service, using <literal>&lt;ttc
      value='x'/&gt;</literal>, where x is expressed in
      <emphasis>seconds</emphasis>. If not, the default value (30 sec) is
      used.</para>
    </section>

    <section><info><title>A deployment descriptor example</title></info>
      

      <para>Here is an example of deployment descriptor that deploys 3 virtual
      nodes: one for deploying fault-tolerant active objects, one for
      deploying non-fault-tolerant active object (if needed), and one as
      resource for recovery. The two fault-tolerance behaviors correspond to
      two fault-tolerance services, <literal>appli</literal> and
      <literal>resource</literal>. Note that non-fault-tolerant active objects
      can communicate with fault-tolerant active objects as usual. Chosen
      protocol is CIC and TTC is set to 5 sec for all the application.</para>

      <screen> &lt;ProActiveDescriptor&gt;                        
  &lt;componentDefinition&gt;
   &lt;virtualNodesDefinition&gt;
    &lt;virtualNode name='NonFT-Workers' property='multiple'/&gt;
    &lt;virtualNode name='FT-Workers' property='multiple' <emphasis role="bold">ftServiceId='appli'</emphasis>/&gt;
    &lt;virtualNode name='Failed' property='multiple' <emphasis role="bold">ftServiceId='resource'</emphasis>/&gt;
   &lt;/virtualNodesDefinition&gt;
  &lt;/componentDefinition&gt;
  &lt;deployment&gt;
   &lt;mapping&gt;
    &lt;map virtualNode='NonFT-Workers'&gt;
     &lt;jvmSet&gt;
      &lt;vmName value='Jvm1'/&gt;
     &lt;/jvmSet&gt;
    &lt;/map&gt;
    &lt;map virtualNode='FT-Workers'&gt;
     &lt;jvmSet&gt;
      &lt;vmName value='Jvm2'/&gt;
     &lt;/jvmSet&gt;
    &lt;/map&gt;
    &lt;map virtualNode='Failed'&gt;
     &lt;jvmSet&gt;
      &lt;vmName value='JvmS1'/&gt;
      &lt;vmName value='JvmS2'/&gt;
     &lt;/jvmSet&gt;
    &lt;/map&gt;
   &lt;/mapping&gt;
   &lt;jvms&gt;
    &lt;jvm name='Jvm1'&gt;
     &lt;creation&gt;
      &lt;processReference refid='linuxJVM'/&gt;
     &lt;/creation&gt;
   &lt;/jvm&gt;
   &lt;jvm name='Jvm2'&gt;
    &lt;creation&gt;
     &lt;processReference refid='linuxJVM'/&gt;
    &lt;/creation&gt;
   &lt;/jvm&gt;
   &lt;jvm name='JvmS1'&gt;
    &lt;creation&gt;
     &lt;processReference refid='linuxJVM'/&gt;
    &lt;/creation&gt;
   &lt;/jvm&gt;
   &lt;jvm name='JvmS2'&gt;
    &lt;creation&gt;
     &lt;processReference refid='linuxJVM'/&gt;
    &lt;/creation&gt;
   &lt;/jvm&gt;
  &lt;/jvms&gt;
 &lt;/deployment&gt;
 &lt;infrastructure&gt;
  &lt;processes&gt;
   &lt;processDefinition id='linuxJVM'&gt;
    &lt;jvmProcess
 class='org.objectweb.proactive.core.process.JVMNodeProcess'/&gt;
   &lt;/processDefinition&gt;
  &lt;/processes&gt;
  &lt;services&gt;
   &lt;<emphasis role="bold">serviceDefinition id='appli'</emphasis>&gt;
    &lt;faultTolerance&gt;
   &lt;protocol type='cic'&gt;&lt;/protocol&gt;
       &lt;globalServer url='rmi://localhost:1100/FTServer'&gt;&lt;/globalServer&gt;
     &lt;ttc value='5'&gt;&lt;/ttc&gt;
    &lt;/faultTolerance&gt;
   &lt;/serviceDefinition&gt;
   &lt;<emphasis role="bold">serviceDefinition id='resource'</emphasis>&gt;
    &lt;faultTolerance&gt;
   &lt;protocol type='cic'&gt;&lt;/protocol&gt;
       &lt;globalServer  url='rmi://localhost:1100/FTServer'&gt;&lt;/globalServer&gt;
       &lt;resourceServer url='rmi://localhost:1100/FTServer'&gt;&lt;/resourceServer&gt;
     &lt;ttc value='5'&gt;&lt;/ttc&gt;
    &lt;/faultTolerance&gt;
   &lt;/serviceDefinition&gt;
  &lt;/services&gt;
 &lt;/infrastructure&gt;
&lt;/ProActiveDescriptor&gt;</screen>
    </section>
  </section>

  <section><info><title>Programming rules</title></info>
    

    <section><info><title>Serializable</title></info>
      

      <para>Persistence of active objects is obtained through standard Java
      serialization; a checkpoint thus consists in an object containing a
      serialized copy of an active object and a few informations related to
      the protocol. As a consequence, a fault-tolerant active object
      <emphasis>must be serializable</emphasis>. If a non serializable object
      is activated on a fault-tolerant virtual node, fault-tolerance is
      automatically and transparently disabled for this active object.</para>
    </section>

    <section><info><title>Standard Java main method</title></info>
      

      <para>Standard Java thread, typically main method, cannot be turned
      fault-tolerant. As a consequence, if a standard main method interacts
      with active objects during the execution, consistency after a failure
      can no more be ensured: after a failure, all the active objects will
      roll back to the most recent global state <emphasis>but the main will
      not</emphasis>.</para>

      <para>So as to avoid such inconsistency on recovery, the programmer must
      minimizes the use of standard main by, for example, delegating the
      initialization and launching procedure to an active object.</para>

      
        <para><programlisting xml:lang="java">...
public static void main(String[] args){
   Initializer init = (Initializer)(PAActiveObject.newActive('Initializer.getClas\
s.getName()', args);
   init.launchApplication();
   System.out.println('End of main thread');
}
...</programlisting></para>
      

      <para>The object <literal>init</literal> is an active object, and as
      such will be rolled back if a failure occurs: the application is kept
      consistent.</para>
    </section>

    <section><info><title>Checkpointing occurrence</title></info>
      

      <para>To keep fault-tolerance fully transparent (see <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www-sop.inria.fr/oasis/personnel/Christian.Delbe/publis/rr5246.pdf">the
      technical report</link> for more details), active objects can take a
      checkpoint <emphasis>before the service of a request</emphasis>. As a
      first consequence, if the service of a request is infinite, or at least
      much greater than TTC, the active object that serves such a request can
      no more take checkpoints. If a failure occurs during the execution, this
      object will force the entire application to rolls back to the beginning
      of the execution. The programmer must thus avoid infinite method such
      as</para>

      
        <para><programlisting xml:lang="java">...
public void infiniteMethod(){
   while (true){
     this.doStuff();
   }
}
...</programlisting></para>
      

      <para>The second consequence concerns the definition of the
      <literal>runActivity()</literal> method (see <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www-sop.inria.fr/oasis/ProActive/doc/api/org/objectweb/proactive/RunActive.html"><literal>runActive</literal></link>).
      Let us consider the following example:</para>

      
        <para><programlisting xml:lang="java">...
public void runActivity(Body body) {
   org.objectweb.proactive.Service service = new org.objectweb.proactive.Se\
rvice(body);
   while (body.isActive()) {
      Request r = service.blockingRemoveOldest();
      ...
      /* CODE A */
      ...
      /* CHECKPOINT OCCURRENCE */
      service.serve(r);
   }
}
...</programlisting></para>
      

      <para>If a checkpoint is triggered before the service of
      <literal>r</literal>, it characterizes the state of the active object at
      the point <literal>/* CHECKPOINT OCCURRENCE */</literal>. If a failure
      occurs, this active object is restarted by calling the
      <literal>runActivity()</literal> method, <emphasis>from a state in which
      the code <literal>/* CODE A */</literal> has been already
      executed</emphasis>. As a consequence, the execution looks like if
      <literal>/* CODE A */</literal> was executed two times.</para>

      <para>The programmer should then avoid to alter the state of an active
      object in the code preceding the call to
      <literal>service.serve(r)</literal> when he redefines the
      <literal>runActivity()</literal> method.</para>
    </section>

    <section><info><title>Activity Determinism</title></info>
      

      <para>All the activities of a fault-tolerant application must be deterministic 
       (see <citation><xref linkend="BCDH04" endterm="BCDH04.abbrev"/></citation> 
       for more details). The programmer must then avoid the use of non-deterministic 
       methods such as <literal>Math.random()</literal>.</para>
    </section>

    <section><info><title>Limitations and known bugs</title></info>
      

      <para>Fault-tolerance in ProActive is still not compliant with the
      following features:</para>

      <itemizedlist>
        <listitem>
          <para>active objects exposed as Web services
           (see <xref linkend="WSDoc"/>), or reachable using http protocol,</para>
        </listitem>

        <listitem>
         <para>and security (see <xref linkend="Security"/>), as
          fault-tolerance servers are implemented using standard RMI.</para>
        </listitem>
      </itemizedlist>
      
      <para>CIC and PML protocols are not compatible: a fault-tolerance application
      can use <emphasis role="bold">only</emphasis> one of the two protocols.</para>
      
      <para>Fault-Tolerance in ProActive is not compliant with on-the-fly RMI 
      stub generation, available since Java 1.5; even with a JRE 1.5 or greater, 
      ProActive RMI stubs must be created <emphasis role="bold">before</emphasis> 
      running the application, with <literal>/ProActive/compile/build.[sh/bat] 
      compile</literal>.</para>
      
      
    </section>
  </section>

  <section xml:id="faultTolerance_html_nbody"><info><title>  A complete example</title></info>
    

    <section><info><title>Description</title></info>
      

      <para>You can find in
      <literal>ProActive/scripts/[unix|windows]/FT/nbodyft.[sh|bat]</literal>
      a script that starts a fault-tolerant version of the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www-sop.inria.fr/oasis/ProActive/apps/nbody.html">ProActive
      NBody</link> example. This script actually call the
      <literal>ProActive/scripts/[unix|windows]/nbody.[sh|bat]</literal>
      script with the option <literal>-displayft</literal>. The java source
      code is the same as the standard version. The only difference is the
      'Execution Control' panel added in the graphical interface, which allows
      the user to remotely kill Java Virtual Machine so as to trigger a
      failure by sending a <literal>killall java</literal> signal. Note that
      this panel will not work with Windows operating system, since the
      <literal>killall</literal> does not exist. But a failure can be
      triggered for example by killing the JVM process on one of the
      hosts.</para>

      <para><figure><info><title>The nbody application, with Fault-Tolerance enabled</title></info>
          

          <mediaobject>
            <imageobject>
             <imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="images/nbodyft.png" format="PNG"  />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>This snapshot shows a fault-tolerant execution with 8 bodies on 3
      different hosts. Clicking on the 'Execute' button will trigger the
      failure of the host called Nahuel and the recovery of the 8 bodies. The
      checkbox <emphasis>Show trace</emphasis> is checked: the 100 latest
      positions of each body are drawn with darker points. These traces allow
      to verify that, after a failure, each body finally reach the position it
      had just before the failure.</para>
    </section>

    <section><info><title>Running NBody example</title></info>
      

      <para>Before starting the fault-tolerant body example, you have to edit
      the <literal>ProActive/descriptors/FaultTolerantWorkers.xml</literal>
      deployment descriptor so as to deploy on your own hosts (<emphasis role="bold">HOSTNAME</emphasis>), as follow:</para>

      <screen> ...
  &lt;processDefinition id='jvmAppli1'&gt;
    &lt;rshProcess
 class='org.objectweb.proactive.core.process.rsh.RSHJVMProcess'
 hostname='<emphasis role="bold">HOSTNAME</emphasis>'&gt;
    &lt;processReference refid='jvmProcess'/&gt;
   &lt;/rshProcess&gt;
  &lt;/processDefinition&gt;
 ...</screen>

      <para>Of course, more than one host is needed to run this example, as
      failure are triggered by killing all Java processes on the selected
      host.</para>

      <para>The deployment descriptor must also specify the GlobalFTServer
      location as follow, assuming that the script
      <literal>startGlobalFTServer.sh</literal> has been started on the host
      <emphasis role="bold">SERVER_HOSTAME</emphasis>:</para>

      <screen>...                        
  &lt;services&gt;
   &lt;serviceDefinition id='appli'&gt;
    &lt;faultTolerance&gt;
    &lt;protocol type='cic'&gt;&lt;/protocol&gt;
     &lt;globalServer
 url='rmi://<emphasis role="bold">SERVER_HOSTAME</emphasis>:1100/FTServer'&gt;&lt;/globalServer&gt;
     &lt;ttc value='5'&gt;&lt;/ttc&gt;
    &lt;/faultTolerance&gt;
   &lt;/serviceDefinition&gt;
   &lt;serviceDefinition id='ressource'&gt;
    &lt;faultTolerance&gt;
    &lt;protocol type='cic'&gt;&lt;/protocol&gt;
     &lt;globalServer
 url='rmi://<emphasis role="bold">SERVER_HOSTAME</emphasis>:1100/FTServer'&gt;&lt;/globalServer&gt;
     &lt;resourceServer
 url='rmi://<emphasis role="bold">SERVER_HOSTAME</emphasis>:1100/FTServer'&gt;&lt;/resourceServer&gt;
     &lt;ttc value='5'&gt;&lt;/ttc&gt;
    &lt;/faultTolerance&gt;
   &lt;/serviceDefinition&gt;
  &lt;/services&gt;
 ...</screen>

	  <para> Before running the application itself, you should start the Fault-Tolerance
	  server, using  <literal>ProActive/scripts/[unix|windows]/FT/startGlobalFTServer.[sh|bat]</literal>
      script (see 'Fault-Tolerance servers' section).</para>


      <para>Finally, you can start the fault-tolerant ProActive NBody and
      choose the version you want to run:</para>

      <screen>~/ProActive/scripts/unix/FT&gt; ./nbodyFT.sh
Starting Fault-Tolerant version of ProActive NBody...
--- N-body with ProActive ---------------------------------
 **WARNING**: $PROACTIVE/descriptors/FaultTolerantWorkers.xml MUST BE SET \
WITH EXISTING HOSTNAMES !
        Running with options set to 4 bodies, 3000 iterations, display true
 1: Simplest version, one-to-one communication and master
 2: group communication and master
 3: group communication, odd-even-synchronization
 4: group communication, oospmd synchronization
 5: Barnes-Hut, and oospmd
Choose which version you want to run [12345]:
4
Thank you!
 --&gt; This ClassFileServer is reading resources from classpath
Jini enabled
Ibis enabled
Created a new registry on port 1099
//tranquility.inria.fr/Node-157559959 successfully bound in registry at //t\
ranquility.inria.fr/Node-157559959
Generating class: pa.stub.org.objectweb.proactive.examples.nbody.common.St\
ub_Displayer
************* Reading deployment descriptor: file:./../../.././descriptors/\
FaultTolerantWorkers.xml ********************</screen>
    </section>
  </section>
</chapter>
