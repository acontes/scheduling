<!-- Converted by db4-upgrade version 1.0 -->

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="p2p"><info><title>Desktop Grid With ProActive</title></info>
  

  <indexterm><primary>P2P</primary></indexterm>
  
    <section xml:id="mozTocId325247"><info><title> Installing and Using the P2P Infrastructure</title></info>
    

    <section xml:id="p2p_html_network"><info><title> Create your P2P Network</title></info>
      

      <para>The P2P infrastructure is self-organized and configurable. When
      the infrastructure is running you have nothing to do to keep it up.
      There are 3 main parameters to configure:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Time To Update (TTU)</emphasis>: each
          peer checks if its known peers are available when TTU expires. By
          default, its value is 1 minute.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Number Of Acquaintances
          (NOA)</emphasis>: is the minimal number of peers one peer needs to
          know to keep up the infrastructure. By default, its value is 10
          peers.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Time To Live (TTL)</emphasis>: in hops
          for JVMs (node) depth search (acquisition). By default, its value is
          5 hops.</para>
        </listitem>
      </itemizedlist>

      <para>All parameter descriptions and the way to change their default
       values are explained in <xref linkend="Configuration_html_p2p_properties"/>. 
      Next section shows how to configure the infrastructure when starting the P2P Service with
      the command line.</para>

      <para>The bootstrapping or first contact problem is how a new peer can
      join the p2p infrastructure. We solved this problem by just specifying
      one or several addresses of supposed peers which are running in the p2p
      infrastructure. Next, we will explain how and where you can specify this
      list of peers.</para>

      <para>Now, you just have to start peers. There are two ways to do
      so:</para>

     <section xml:id="mozTocId117139"><info><title> Quick Start Peer</title></info>
        

        <para>This method explains how to rapidly launch a simple P2P Service
        on one host.</para>

        <para>ProActive provides a very simple <emphasis>script</emphasis> to
        start a P2P Service on your local host. The name of this script is
        <emphasis role="bold">startP2PService</emphasis>.</para>

        <itemizedlist>
          <listitem>
            <para>UNIX, GNU/Linux, BSD and MacOsX systems: the script is
            located in <emphasis role="bold">ProActive/scripts/unix/p2p/startP2PService.sh</emphasis>
            file.</para>
          </listitem>

          <listitem>
            <para>Microsoft Windows system: the script is located in <emphasis role="bold">ProActive/p2p/scripts/windows/p2p/startP2PService.bat</emphasis>
            file.</para>
          </listitem>
        </itemizedlist>

        <para>Before launching this script, you have to specify some
        parameters to this command:</para>

        <screen> startP2PService [-acq acquisitionMethod] [-port portNumber] [-s Peer ...] [-f PeersListFile]</screen>

        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">-acq acquisitionMethod</emphasis> the
            ProActive Runtime communication protocol used. Examples: rmi,
            http, ibis, ... By default it is <emphasis>rmi</emphasis>.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">-port portNumber</emphasis> is the
            port number where the P2P Service will listen. By default it is
            <emphasis>2410</emphasis></para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">-s Peer ...</emphasis> specify
            addresses of peers which are used to join the P2P infrastructure.
            Example:</para>

            <screen>rmi://applepie.proactive.org:8080</screen>
          </listitem>

          <listitem>
            <para><emphasis role="bold">-f PeersListFile</emphasis> same of
            <emphasis role="bold">-s</emphasis> but peers are specified in
            file <emphasis role="bold">ServerListFile</emphasis>. One per
            line.</para>
          </listitem>
        </itemizedlist>

        <para>More options:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">-noa NOA</emphasis> in number of host.
            NOA is the minimal number of peers one peer needs to know to keep
            up the infrastructure. By default, its value is 10 peers.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">-ttu TTU</emphasis> is in minutes.
            Each peer sends a heart beat to its acquaintances. By default, its
            value is 1 minute.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">-ttl TTL</emphasis> is in hop. TTL
            represents live time messages in hops of JVMs (node). By default,
            its value is 5 hops.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">-capacity
            Number_of_Messages</emphasis> is the maximum memory size to stock
            message UUID. Default value is 1000 messages UUID.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">-exploring Percentage</emphasis> is
            the percentage of agree response when a peer is looking for
            acquaintances. By default, its value is 66%.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">-booking Time</emphasis> in ms it
            takes while booking a shared node. It's the maximum time in
            milliseconds to create at least an active object in the shared
            node. After this time, and if no active objects are created, the
            shared node will leave and the peer which gets this shared node
            will be no longer be able to use it. Default is 3 minutes.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">-node_acq Time</emphasis> in
            milliseconds which is the timeout for node acquisition. The
            default value is 3 minutes.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">-lookup Time</emphasis> is the lookup
            frequency in milliseconds for re-asking nodes. By default, it's
            value is 30 seconds.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">-no_multi_proc_nodes</emphasis> to
            share only a node. Otherwise, 1 node by CPU that means the p2p
            service which is running on a bi-pro will share 2 nodes. By
            default, 1 shared node for 1 CPU.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">-xml_path</emphasis> to share nodes
            from a XML deployment descriptor file. This option takes a file
            path. By default, no descriptors are specified. That means the P2P
            Service shares only one local node or one local node by
            CPUs.</para>
          </listitem>
        </itemizedlist>

        <para>All arguments are optional.</para>

        <para><emphasis role="bold">Comment:</emphasis> With the UNIX version
        of the startP2PService script, the P2P service is persistent and runs
        like a UNIX <emphasis>nice</emphasis> process. If the JVMs that are
        running the P2P service stop (for a Java exception) the script
        re-starts a new one.</para>
      </section>

      <section xml:id="mozTocId979491"><info><title> Usage Example</title></info>
        

        <para>In this illustration, we will explain how to start a first peer
        and then how new peers can create a P2P network with the first
        one.</para>

        <para>Start the first peer with <emphasis>rmi</emphasis> protocol and
        listening on port <emphasis>2410</emphasis>:</para>

        <screen>first.peer.host$startP2PService.sh -acq rmi -port 2410</screen>

        <para>Now, start new peers and connect them to the first peer to
        create a tiny P2P network:</para>

        <screen>  second.peer.host$startP2PService.sh -acq rmi -port 2410 -s rmi://first.peer.host 
  third.peer.host$startP2PService.sh -acq rmi -port 2602 -s rmi://first.peer.host </screen>

        <para>You could specify a different port number for each peer.</para>

        <para>Use a file to specify the addresses of peers:</para>

        <para>The file <emphasis>hosts.file</emphasis>:</para>

        <screen> rmi://first.peer.host:2410
 rmi://third.peer.host:2602</screen>

        <screen> file.peer.host$startP2PService.sh -acq rmi -port 8989 -f hosts.file </screen>

        <para>Lastly, a new peer joins the P2P network:</para>

        <screen> last.peer.host$startP2PService.sh -acq rmi -port 6666 -s rmi://third.peer.host:2410 </screen>

        <para><figure><info><title>Usage example P2P network (after firsts
            connections)</title></info>
            

            <mediaobject>
              <imageobject>
                <imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="p2p_files/example.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section xml:id="mozTocId690540"><info><title> The P2P Daemon</title></info>
        

        <para>The daemon aims to use computers in Peer-to-Peer computations.
        There will be a Java virtual machine sleeping on your computer and
        waking up at scheduled times to get some work done.</para>

        <para>By default, the JVM is scheduled to wake up during the weekend
        and during the night. Next, we will explain how to change the
        schedule. The JVM is running with the lowest priority.</para>

       <section xml:id="mozTocId895651"><info><title> Installation</title></info>
          

          <para><emphasis role="bold">UNIX</emphasis></para>

          <para>Go to the directory: <emphasis role="bold">ProActive/compile</emphasis> and run this
          command:</para>

          <screen> $ ./build daemon </screen>

          <para>Before compiling you should change some parameters like the
          daemon user or the port in the file:</para>

          <screen> ProActive/p2p/src/common/proactivep2p.h </screen>

          <para>Ask your system administrator to add the daemon in a crontab
          or init.d. The process to run is located here:</para>

          <screen> ProActive/p2p/build/proactivep2p </screen>

          <para><emphasis role="bold">Microsoft Windows</emphasis></para>

          <para>To compile daemon source (in c++), we don't provide any
          automatic script, you have to do it yourself. All sources for
          Windows are in the directory: <emphasis role="bold">ProActive/p2p/src/windows</emphasis>. If you use
          Microsoft Visual Studio, you can find in the src directory the
          Microsoft VS project files.</para>

          <para>After that you are ready to install the daemon with Windows,
          you just have to run this script:</para>

          <screen> C:&gt;ProActive\scripts\windows\p2p\Service\install.bat </screen>

          <para>To remove the daemon:</para>

          <screen> C:&gt;ProActive\scripts\windows\p2p\Service\remove.bat </screen>

          <para><emphasis role="bold">Comment</emphasis>: By default the port
          number of the daemon is <emphasis role="bold">9015</emphasis>.</para>
        </section>

        <section xml:id="mozTocId799743"><info><title> Configuration</title></info>
          

          <para>The daemon is configured with XML files in the <emphasis role="bold">ProActive/p2p/config/</emphasis> directory. To find the
          correct configuration file, the daemon will first try with a host
          dependent file: <emphasis role="bold">config/proactivep2p.${HOST}.xml</emphasis> for example:
          <emphasis role="bold">config/proactivep2p.camel.inria.fr.xml</emphasis> if the
          daemon is running on the host named <emphasis role="bold">camel.inria.fr.</emphasis></para>

          <para>If this host specific file is not found, the daemon will load
          <emphasis role="bold">config/proactivep2p.xml</emphasis>. This
          mechanism can be useful to setup a default configuration and have a
          specific configuration for some hosts.</para>

         <para>The reference is the XML Schema called proactivep2p.xsd, shown in
          <xref linkend="miscFileSrc.p2p_files.proactivep2p.xsd"/>. For those
          not fluent in XML Schema, here is a description of all markup
          tags</para>

          <para>The root element in <emphasis role="bold">&lt;configFile&gt;</emphasis> it contains one or many
          <emphasis role="bold">&lt;p2pconfig&gt;</emphasis> . This latter
          element can start with a <emphasis role="bold">&lt;loadconfig
          path='path/to/xml'/&gt;</emphasis> it will include the designated
          XML file. After these file inclusions, you can with <emphasis role="bold">&lt;host name='name.domain'&gt;</emphasis> specify which
          hosts are concerned by the configuration. Then there can be a
          <emphasis role="bold">&lt;configForHost&gt;</emphasis> element
          containing a configuration for the selected hosts and/or a <emphasis role="bold">&lt;default&gt;</emphasis> element if no suitable
          configuration was already found.</para>

          <para>Bear in mind that the XML parser sees a lot of configuration
          and the first that matches is used and the parsing is finished. This
          means that the elements we have just seen are tightly linked
          together. For example if an XML file designated by a <emphasis role="bold">&lt;loadconfig&gt;</emphasis> contains a <emphasis role="bold">&lt;default&gt;</emphasis> element, then after this file
          no other element will be evaluated. This is because either a
          configuration was already found so the parsing stops, or no
          configuration matched and the <emphasis role="bold">&lt;default&gt;</emphasis> does, so the parsing
          ends.</para>

          <para>The proper configuration is contained in a <emphasis role="bold">&lt;configForHost&gt;</emphasis> or <emphasis role="bold">&lt;default&gt;</emphasis> element. It consists of the
          scheduled times for work and the hosts where we register ourselves.
          Here is an example:</para>

          <screen> &lt;periods&gt; 
  &lt;period&gt;
   &lt;start day='monday' hour='18'
 minute='0'/&gt;
   &lt;end day='tuesday' hour='6'
 minute='0'/&gt;
   &lt;/period&gt;
   &lt;period&gt;
    &lt;start day='saturday' hour='0'
 minute='0'/&gt;
    &lt;end day='monday' hour='6'
 minute='0'/&gt;
   &lt;/period&gt;
 &lt;/periods&gt;
 &lt;register&gt;
  &lt;registry url='trinidad.inria.fr'/&gt;
  &lt;registry url='amda.inria.fr'/&gt;
  &lt;registry url='tranquility.inria.fr'/&gt;
  &lt;registry url='psychoquack.inria.fr'/&gt;
 &lt;/register&gt;</screen>

          <para>In this example we clearly see that the JVM will wake up
          Monday evening and shut down Tuesday morning. It will also work
          during the weekend. In the <emphasis role="bold">&lt;register&gt;</emphasis> part we put the URL in which
          we will register ourselves, in the example we used the short form
          which is equivalent to <emphasis>rmi://host:9301</emphasis>.</para>
        </section>

        <section xml:id="mozTocId994982"><info><title> Control</title></info>
          

          <para>The following commands only work with UNIX friendly
          systems.</para>

          <itemizedlist>
            <listitem>
              <para><emphasis role="bold">Stop the JVM</emphasis>: This
              command will stop the JVM and will restart it at the next
              scheduled time, which is the day after:</para>

              <screen> $ProActive/p2p/build/p2pctl stop [hostname] </screen>
            </listitem>

            <listitem>
              <indexterm><primary>Kill</primary><secondary>P2P deamon</secondary></indexterm>
              <para><emphasis role="bold">Kill the daemon</emphasis>:</para>
              <screen> $ProActive/p2p/build/p2pctl killdaemon [hostname] </screen>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Restart the
              daemon</emphasis>:</para>

              <screen> $ProActive/p2p/build/p2pctl restart [hostname] </screen>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Test the daemon</emphasis>:</para>

              <screen> $ProActive/p2p/build/p2pctl alive [hostname] </screen>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Flush the daemon
              logs</emphasis>:</para>

              <screen> $ProActive/p2p/build/p2pctl flush [hostname] </screen>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">hostname</emphasis> is the name of the
          remote host which the daemon command is sent to. This parameter is
          optional, if the host name is not specified the command is executed
          on the local host.</para>

          <para>Under Windows you could use some littles scripts in <emphasis role="bold">ProActive//script/windows/p2p/JVM</emphasis> to do
          that.</para>

          <para>All daemon logs are written in a file. All logs are available
          in:</para>

          <screen> ProActive/p2p/build/logs/hostname </screen>
        </section>
      </section>
    </section>

    <section xml:id="p2p_html_appli"><info><title> Example of Acquiring Nodes by ProActive XML
      Deployment Descriptors</title></info>
      

      <para>You can customize some P2P settings such as:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">nodesAsked</emphasis> is the number of
          nodes you want from the P2P infrastructure. Setting <emphasis role="bold">MAX</emphasis> as value is equivalent to an infinite
          number of nodes. This attribute is required.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">acq</emphasis> is the communication
          protocol that's used to communicate with this P2P Service. All
          ProActive communication protocols are supported: rmi, http, etc.
          Default is rmi.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">port</emphasis> represents the port
          number on which to start the P2P Service. Default is 2410. The port
          is used by the communication protocol.</para>
        </listitem>

        <listitem>
          <para>The <emphasis role="bold">NOA Number Of
          Acquaintances</emphasis> is the minimal number of peers one peer
          needs to know to keep up the infrastructure. By default, its value
          is 10 peers.</para>
        </listitem>

        <listitem>
          <para>The <emphasis role="bold">TTU Time To Update</emphasis> each
          peer sends a heart beat to its acquaintances. By default, its value
          is 1 minute.</para>
        </listitem>

        <listitem>
          <para>The <emphasis role="bold">TTL Time To Live</emphasis>
          represents messages live time in hops of JVMs (node). By default,
          its value is 5 hops.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">multi_proc_nodes</emphasis> is a boolean
          (use true or false) attribute. When its value is true the P2P
          service will share 1 node by CPU, if not only one node is shared. By
          default, its value is true, i.e. 1 node / CPU.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">xml_path</emphasis> is used with a XML
          deployment descriptor path. The P2P Service shares nodes which are
          deployed by the descriptor. No default nodes are shared.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">booking_nodes</emphasis> is a boolean
          value (true or false). During asking nodes processs there is a
          timeout, booking timeout is used for obtaining nodes. That means if
          no active objects are created before the end of the timeout, the
          node will be free and no longer shared. To avoid the booking
          timeout, put this attribute at true, obtained nodes will be
          permanently booked for you. By default, its value is false. See
          below, for more information about the booking timeout.</para>
        </listitem>
      </itemizedlist>

      <para>With elements <emphasis role="bold">acq</emphasis> and <emphasis role="bold">port</emphasis>, if a P2P Service is already running with
      this configuration the descriptor will use this one, if not a new one is
      started.</para>

      <para>In order to get nodes, the <emphasis role="bold">peerSet</emphasis> tag will allow you to specify entry point
      of your P2P Infrastructure.</para>

      <para>You can get nodes from the P2P Infrastructure using the ProActive
      Deployment Descriptor as described above.</para>

      <para>In fact you will ask for a certain number of nodes and ProActive
      will notify a 'listener' (one of your class), every time a new node is
      available.</para>

      <programlisting xml:lang="java"> ProActiveDescriptor pad = PADeployment.getProactiveDescriptor('myP2PXmlDescriptor.xml');
 // getting virtual node 'p2pvn' defined in the ProActive Deployement Descriptor
 VirtualNode vn = pad.getVirtualNode('p2pvn');
 
 // adding 'this' or anyother class has a listener of the 'NodeCreationEvent'
 ((VirtualNodeImpl) vn).addNodeCreationEventListener(this);
 //activate that virtual node
 vn.activate();</programlisting>

      <para>As you can see, the class executing this code must implement an
      interface in order to be notified when a new node is available from the
      P2P infrastructure.</para>

      <para>Basically you will have to implement the interface
      NodeCreationEventListener that can be found in package
      org.objectweb.proactive.core.event. For example, this method will be
      called every time a new host is acquired:</para>

      <programlisting xml:lang="java"> public void nodeCreated(NodeCreationEvent event) 
 {
 // get the node
 Node newNode = event.getNode();
   // now you can create an active object on your node.
 }</programlisting>

      <para>You should carefully notice that you can be notified at any time,
      whatever the code you are executing, once you have activated the virtual
      node.</para>

      <para>A short preview of a XML descriptor:</para>

      <screen> &lt;infrastructure&gt;                        
  &lt;services&gt;
   &lt;serviceDefinition id='p2pservice'&gt;
    &lt;P2PService nodesAsked='2' acq='rmi' 
             port='2410' NOA='10' TTU='60000'
             TTL='10'&gt;
     &lt;peerSet&gt;
      &lt;peer&gt;rmi://localhost:3000&lt;/peer&gt;
     &lt;/peerSet&gt;
    &lt;/P2PService&gt;
   &lt;/serviceDefinition&gt;
  &lt;/services&gt;
 &lt;/infrastructure&gt;
</screen>

      <para>A complete example of file is available, see 
       <xref linkend="miscFileSrc.p2p_files.sample_p2p.xml"/> .</para>

      <para>The next figure shows a P2P Service started with a XML deployment
      descriptor (xml_path attribute). Six nodes are shared on different
      hosts:</para>

      <para><figure><info><title>A P2P Service which is sharing nodes deployed by a
          descriptor</title></info>
          

          <mediaobject>
            <imageobject>
              <imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="p2p_files/descriptor.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>For more information about ProActive XML Deployment Descriptor see 
       <!-- This url can only work in the html generated files: in pdf there's no ".." -->
       <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="../api/org/objectweb/proactive/Descriptor.html" os="html">the descriptor java doc</link>
       <phrase os="pdf"><literal>org.objectweb.proactive.Descriptor</literal> javadoc</phrase>.</para>
    </section>

    <section xml:id="mozTocId294040"><info><title> The P2P Infrastructure API Usage Example</title></info>
      

      <para>The next little sample of code explains how, from an application,
      you can start a P2P Service and get nodes:</para>

      <programlisting xml:lang="java">import org.objectweb.proactive.ProActive;
import org.objectweb.proactive.core.ProActiveException;
import org.objectweb.proactive.core.mop.ClassNotReifiableException;
import org.objectweb.proactive.core.node.Node;
import org.objectweb.proactive.core.node.NodeException;
import org.objectweb.proactive.core.node.NodeFactory;
import org.objectweb.proactive.core.runtime.ProActiveRuntime;
import org.objectweb.proactive.core.runtime.RuntimeFactory;
import org.objectweb.proactive.extra.p2p.service.P2PService;
import org.objectweb.proactive.extra.p2p.service.StartP2PService;
import org.objectweb.proactive.extra.p2p.service.node.P2PNodeLookup;
...
// This constructor uses a file with address of peers
// See the Javadoc to choose different parameters
StartP2PService startServiceP2P = new StartP2PService(p2pFile);
// Start the P2P Service on the local host
startServiceP2P.start();
// Get the reference on the P2P Service
P2PService serviceP2P = startServiceP2P.getP2PService();
// By the application's P2P Service ask to the P2P infrastructure
// for getting nodes.
P2PNodeLookup p2pNodeLookup = serviceP2P.getNodes(nNodes,
 virtualNodeName, JobID);
// You can migrate the P2P node lookup from the p2p service
// to an another node:
p2pNodeLookup.moveTo("//localhost/localNode");
// Use method from p2pNodeLookup to get nodes
// such as
while (! p2pNodeLookup.allArrived()) {
 Vector arrivedNodes = p2pNodeLookup.getAndRemoveNodes();
 // Do something with nodes
 ...
}
// Your application
...
// End of your program
// Free shared nodes
p2pNodeLookup.killAllNodes();</programlisting>
    </section>
  </section><section xml:id="mozTocId121981"><info><title> Overview</title></info>
    
    
    <para>Computational Peer-To-Peer (P2P) is becoming a key execution
    environment. The potential of 100,000 nodes interconnected to execute a
    single application is rather appealing, especially for Grid computing.
    Mimicking data P2P, one could start a computation that no failure would
    ever be able to stop (and maybe nobody).</para>

    <para>
     The ProActive P2P aims to use spare CPU cycles from organization's
    or institution's desktop workstations.</para>

    <para>This short document explains how to create a simple computational
    P2P network. This network is a <emphasis role="bold">dynamic JVMs
    network</emphasis> which works like computational nodes.</para>

    <para>The P2P infrastructure works as an overlay network. It works with a
    <emphasis role="bold">P2P Service</emphasis> which is a peer which in turn
    is in computational node. The P2P Service is implemented with a ProActive
    Runtime and few Active Objects. The next figure shows an example of a network
    of hosts where some JVMs are running and several of them are running the
    P2P Service.</para>

    <para><figure><info><title>A network of hosts with some running the P2P Service</title></info>
        

        <mediaobject>
          <imageobject>
            <imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="p2p_files/overlaynetwork.png" format="PNG"/>
          </imageobject>
          <caption><para> Example of a ProActive P2P infrastructure.</para></caption>
        </mediaobject>
      </figure> 
     </para>

    <para>When the P2P infrastructure is running, it is very easy to obtain
    some nodes (JVMs). The next section describes how to use it.</para>

    <para>Further research information is available 
    at <uri xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www-sop.inria.fr/oasis/Alexandre.Di_Costanzo/AdC/Publications.html">http://www-sop.inria.fr/oasis/Alexandre.Di_Costanzo/AdC/Publications.html</uri>.</para>
  </section>

  <section xml:id="p2p_html_infrastructure_model"><info><title>The P2P Infrastructure Model</title></info>
    

    <para>The goals of this work are to use sparse CPU cycles from
    institutions' desktop workstations combined with grids and clusters.
    Desktop workstations are not available all the time for sharing
    computation times with different users other than the workstation owner.
    Grids and clusters have the same problem as normal users don't want to
    share their usage time.</para>

    <para>Managing different sorts of resources (grids, clusters, desktop
    workstations) as a single network of resources with a high instability
    between them needs a fully decentralized and dynamic approach.</para>

    <para>Therefore, P2P is a good solution for sharing a dynamic JVM network,
    where JVMs are the shared resources. Thereby, the P2P Infrastructure is a
    P2P network which shares JVMs for computation. This infrastructure is
    completely self-organized and fully configurable.</para>

    <para>Before going on to consider the P2P infrastructure, it's important
    to define what Peer-to-Peer is.</para>

   <section xml:id="mozTocId356736"><info><title>What is Peer-to-Peer?</title></info>
      

      <para>There are a lot of P2P definitions, many of them are similar to
      other distributed infrastructures, such as Grid, client / server, etc.
      There are 2 better definitions which describe really P2P well:</para>

      <itemizedlist>
        <listitem>
          <para>From Peer-to-Peer Harnessing the Power of Disruptive
          Technologies (edited by Andy Oram):</para>
        </listitem>
      </itemizedlist>

      <para>'[...] P2P is a class of applications that take advantage of
      <emphasis role="bold">resources</emphasis> - available at the edges of
      the Internet [...]'</para>

      <itemizedlist>
        <listitem>
          <para>And from A Definition of Peer-to-Peer Networking for the
          Classification of Peer-to-Peer Architectures and Applications
          (Rdiger Schollmeier - P2P'01):</para>
        </listitem>
      </itemizedlist>

      <para>'[...] Peers are <emphasis role="bold">accessible</emphasis> by
      other peers directly [...] Any arbitrary chosen peer can be <emphasis role="bold">removed</emphasis> from the network <emphasis role="bold">without fault</emphasis> [...]'</para>

      <para><emphasis role="bold">P2P's focus on sharing, decentralization,
      instability and fault tolerance.</emphasis></para>
    </section>

    <section xml:id="mozTocId928306"><info><title>The P2P Infrastructure in
      short</title></info>
      

     <section xml:id="mozTocId101413"><info><title>Bootstrapping: First Contact</title></info>
        

        <para>A fresh (or new) peer which would like to join the P2P network,
        will encounter a serious bootstrapping problem or first contact
        problem: 'How can it connect to the P2P network?'</para>

       <indexterm><primary>JINI</primary><secondary>P2P</secondary></indexterm>
       
       <para>A solution for that is to use a specific protocol. ProActive
        provides an interface for a network-centric services protocol which is
        named JINI. JINI can be used for discovering services in a dynamic
        computing environment, such as a fresh peer which would like to join a
        P2P network. This protocol is perfectly adapted to solve the
        bootstrapping problem. However, there is a serious drawback for using
        a protocol such as JINI as peer discovering protocol. JINI is limited
        to working only in the same sub-network. That means JINI doesn't pass
        through firewalls or NAT and can't be considered to be used for
        Internet.</para>

        <para>Therefore, a different solution for the bootstrapping problem
        was chosen. The solution for ProActive first contact P2P is inspired
        from Data P2P Networks. This solution is based on real life , i.e.
        when a person wants to join a community, this person has to first know
        another person who is already a member of the community. After the
        first person has contacted the community member, the new person is
        introduced to all the community members.</para>

        <para>The ProActive P2P bootstrapping protocol works as
        follows:</para>

        <itemizedlist>
          <listitem>
            <para>A fresh peer has a list of 'server' addresses. These are
            peers which have a high potential to be available and to be in the
            P2P network, they are in a certain way the P2P network
            core.</para>
          </listitem>

          <listitem>
           <indexterm><primary>Acquaintance</primary><secondary>definition</secondary></indexterm>
           <para>With this list the fresh peer tries to contact each server.
            When a server is reached the server is added to ithe fresh peer's
            list of known peers (acquaintances).</para>
          </listitem>

          <listitem>
            <para>Then the fresh peer knows some servers, it is in the P2P
            Network and it is no longer a fresh peer, it is a peer of the P2P
            network.</para>
          </listitem>
        </itemizedlist>

        <para>Furthermore, in the case of the fresh peer not able to contact
        any servers from the list, the fresh peer will try every TTU (see
        below, about Time To Update parameter) to re-contact all of them until
        one or several of them are finally available. At any moment when the
        peer knows nobody because all of its acquaintances are no longer
        available, the peer will try to contact all the servers as explained
        earlier.</para>

        <para>An example of a fresh peer which is trying to join a P2P network
        is shown by the next Figure. The new peer has 2 servers to contact in
        order to join the existing P2P infrastructure.</para>

        <para><figure><info><title>New peer trying to join a P2P network</title></info>
            

            <mediaobject>
              <imageobject>
                <imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="p2p_files/firstContact.png" format="PNG"/>
              </imageobject>
              <caption><para> Example of first contact (Bootstrapping).</para></caption>

            </mediaobject>
          </figure> </para>
      </section>

      <section xml:id="mozTocId470123"><info><title>Discovering and Self-Organizing
        in Continue</title></info>
        

        <para>The main particularity of a P2P network is the peers high
        volatility. This results from various attributes which compose
        P2P:</para>

        <itemizedlist>
          <listitem>
            <para>Peers run on different kinds of computers: desktop
            workstations, laptops, servers, cluster nodes, etc.</para>
          </listitem>

          <listitem>
            <para>Each peer has a particular configuration: operating system,
            etc.</para>
          </listitem>

          <listitem>
            <para>Communicating network between peers consists of different
            speed connections: modem, 100Mb Ethernet, fiber channel,
            etc.</para>
          </listitem>

          <listitem>
            <para>Peers are not available all the time and not all at the same
            moment.</para>
          </listitem>

          <listitem>
            <para>Peer latency is not equal for all.</para>
          </listitem>

          <listitem>
            <para>etc.</para>
          </listitem>
        </itemizedlist>

        <para>The result is the instability of the P2P network. But the
        ProActive P2P infrastructure deals with these problems with
        transparency.</para>

        <para>ProActive P2P infrastructure aims to maintain a created P2P
        network alive while there are available peers in the network, this is
        called self-organizing of the P2P network. Because P2P doesn't have
        exterior entities, such as centralized servers which maintain peer
        data bases, the P2P network has to be self-organized. That means all
        peers should be enabled to stay in the P2P network by their own
        means.</para>

        <para>There is a solution which is widely used in data P2P networks;
        this consists of each peer keeping a list of their neighbors, a peer's
        neighbor is typically a peer close to it (IP address or
        geographically).</para>

       <indexterm><primary>Acquaintance</primary><secondary>List of</secondary></indexterm> 
       <indexterm><primary>NOA</primary></indexterm> 
       
       <para>In the same way, this idea was selected to keep the ProActive
        P2P infrastructure up. All peers have to maintain a list of <emphasis role="bold">acquaintances</emphasis>. At the beginning, when a fresh
        peer has just joined the P2P infrastructure, it knows only peers from
        its bootstrapping step (<xref linkend="mozTocId101413"/>). However,
        depending on how long the list of servers is, many of them could be
        unreachable, unavailable, etc. and the fresh peer ends up knowing a
        small number of acquaintances. Knowing a small number of acquaintances
        is a real problem in a dynamic P2P network when all the servers will
        be unavailable, the fresh peer will be unconnected from the P2P
        infrastructure.</para>

        <para>Therefore, the ProActive P2P infrastructure uses a specific
        parameter called: <emphasis role="bold">Number Of Acquaintances
        (NOA)</emphasis>. This is a minimum size of the list of acquaintances
        of all peers. The more the peers are highly dynamic, the more NOA
        should be high. Thereby, a peer must discover new acquaintances
        through the P2P infrastructure.</para>

        <para>In <xref linkend="mozTocId299524"/>, we
        will see in detail how the message protocol works. For the moment we
        will just explain briefly the discovering acquaintances process
        without going into detail about the message protocol.</para>

        <para>The peer called 'Alice' has 2 acquaintances resulting from its
        first contact with the P2P infrastructure and by default NOA is 10
        peers. Alice must find at least 8 peers to be able to stay with a
        certain guarantee inside the infrastructure.</para>

        <para>The acquaintance discovering works as follows:</para>

        <itemizedlist>
          <listitem>
            <para>Send an exploring message to all of its acquaintances, and
            wait for responses from new acquaintances (not peers that have
            already been contacted peers and not already known peers).</para>
          </listitem>

          <listitem>
            <para>When receiving an exploring message:</para>

            <itemizedlist>
              <listitem>
                <para>Forward the message to acquaintances until the message
                Time To Live (TTL) reaches 0.</para>
              </listitem>

              <listitem>
                <para>Choose to be or not to be an acquaintance of the asking
                peer.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>In order to not have isolated peers in the infrastructure, all
        peers registration are symmetric. That means if Alice knows the peer
        'Bob', Bod also knows Alice. Hence, when a peer chooses whether to be
        an acquaintance or not, the peer has to check previously in its own
        acquaintance list if it doesn't already know the asking peer. Next, if
        it's an unknown peer, the peer decides with a random function to be an
        acquaintance or not. With the parameter of <emphasis role="bold">agree
        responses</emphasis>, it is possible to configure the percentage of
        positive responses to an exploring message. The random function is a
        temporary solution to solve the flooding problem due to the message
        protocol (see <xref linkend="mozTocId299524"/>), we
        are thinking of using a new parameter Maximum Number of Acquaintances
        and improving the message protocol. For the moment, we don't consider
        peers IP addresses or geographical location of the peers as an
        acquaintances criteria.</para>

        <indexterm><primary>TTU</primary></indexterm> 
        
        <para>As the P2P infrastructure is a dynamic environment, the list of
        acquaintances must also be dynamic. Many acquaintances could be
        unavailable and must be removed of the list. When the size of the list
        is less than the NOA, the peer has to discover new peers. Therefore,
        all peers keep their lists up-to-date. That's why a new parameter must
        be introduced: <emphasis role="bold">Time To Update (TTU)</emphasis>.
        The peer must frequency check its own acquaintances' list to remove
        unavailable peers and discover new peers. To verify the acquaintances
        availability, the peer send a <emphasis role="bold">Heart
        Beat</emphasis> to all of its acquaintances. The heart beat is sent
        every TTU.</para>

        <para>The next figure shows a peer which is sending a heart beat to
        all of its acquaintances.</para>

        <para><figure><info><title>Heart beat sent every TTU</title></info>
            

            <mediaobject>
              <imageobject>
                <imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="p2p_files/heartbeat.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>

      <section xml:id="mozTocId299524"><info><title>Asking Computational Nodes</title></info>
        

        <para>The main goal of this work is to provide an infrastructure for
        sharing computational nodes (JVMs). Therefore, a resource query
        mechanism is needed; there are 2 types of resources in this context,
        thus 2 query types:</para>

        <itemizedlist>
          <listitem>
            <para>Exploring the P2P infrastructure to search new
            acquaintances.</para>
          </listitem>

          <listitem>
            <para>Asking free computational nodes to deploy distributed
            applications.</para>
          </listitem>
        </itemizedlist>

        <para>The mechanism is similar to Gnutella's communication system:
        <emphasis role="bold">Breadth-First Search</emphasis> algorithm (BFS).
        The system is message-based with application-level routing.</para>

        <para>All BFS messages must contain this information:</para>

        <itemizedlist>
          <listitem>
            <para>A Unique Universal Message Identifier (UUID): this message
            identifier is not totally universally unique, it is just unique
            for the infrastructure;</para>
          </listitem>

          <listitem>
           <indexterm><primary>TTL</primary></indexterm> 
 
           <para>The <emphasis role="bold">Time To Live (TTL) infrastructure
            parameter</emphasis>, in number of hops;</para>
          </listitem>

          <listitem>
            <para>A reference to the requester peer. The peer waits for
            responses for nodes or acquaintances.</para>
          </listitem>
        </itemizedlist>

        <para>Our BFS inspired version works as follow:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis role="bold">Broadcasting</emphasis> a request
            message to all of its acquaintances with an <emphasis role="bold">UUID</emphasis>, and <emphasis role="bold">TTL</emphasis>, and <emphasis role="bold">number of
            asked nodes</emphasis>.</para>
          </listitem>

          <listitem>
            <para>When <emphasis role="bold">receiving</emphasis> a
            message:</para>

            <itemizedlist>
              <listitem>
                <para>Test the message UUID, <emphasis role="bold">is it an
                old message?</emphasis></para>

                <itemizedlist>
                  <listitem>
                    <para>Yes, it is: continue;</para>
                  </listitem>

                  <listitem>
                    <para>No, it's not:</para>

                    <itemizedlist>
                      <listitem>
                        <para><emphasis role="bold">Keep</emphasis> the
                        <emphasis role="bold">UUID</emphasis>;</para>
                      </listitem>

                      <listitem>
                        <para>I have a free node:</para>
                      </listitem>

                      <listitem>
                        <para><itemizedlist>
                            <listitem>
                              <para>Send the node reference to the caller and
                              waiting an <emphasis role="bold">ACK</emphasis>
                              until <emphasis role="bold">timeout</emphasis></para>
                            </listitem>

                            <listitem>
                              <para>if <emphasis role="bold">timeout</emphasis> is
                              reached or <emphasis role="bold">NACK</emphasis></para>
                            </listitem>

                            <listitem>
                              <para><itemizedlist>
                                  <listitem>
                                    <para>continue;</para>
                                  </listitem>
                                </itemizedlist></para>
                            </listitem>

                            <listitem>
                              <para>if <emphasis role="bold">ACK</emphasis> and
                              <emphasis role="bold">asked nodes - 1 &gt;
                              0</emphasis> and <emphasis role="bold">TTL &gt;
                              0</emphasis> then</para>
                            </listitem>

                            <listitem>
                              <para><itemizedlist>
                                  <listitem>
                                    <para><emphasis role="bold">Broadcast</emphasis>
                                    with <emphasis role="bold">TTL - 1</emphasis> and
                                    <emphasis role="bold">asked nodes
                                    -1</emphasis></para>
                                  </listitem>
                                </itemizedlist></para>
                            </listitem>

                            <listitem>
                              <para>continue;</para>
                            </listitem>
                          </itemizedlist></para>
                      </listitem>
                    </itemizedlist>
                  </listitem>
                </itemizedlist>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>Gnutella's BFS got a lot of justified critics for scaling,
        bandwidth, etc. It is true this protocol is not good enough but we're
        working to improve it. We are inquiring into solutions with a not
        fixed TTL to avoid network flooding.</para>

        <para>The next Figure shows briefly the execution of the inspired BFS
        algorithm:</para>

        <para><figure><info><title>Asking nodes to acquaintances and getting a node</title></info>
            

            <mediaobject>
              <imageobject>
                <imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="p2p_files/sendingNode.png" format="PNG"/>
              </imageobject>
            </mediaobject>
          </figure></para>
      </section>
    </section>
  </section>

  <section xml:id="p2p_html_implementation"><info><title> The P2P Infrastructure Implementation</title></info>
    

    <section xml:id="mozTocId467214"><info><title>Peers Implementation</title></info> 
      

      <para>The P2P infrastructure is implemented with ProActive. Thus the
      shared resource is not a JVMs but a ProActive node, nodes are like a
      container which receives work.</para>

      <para>The P2P infrastructure is not directly implemented in the
      ProActive core at the ProActive runtime level because we choose to be
      above communication protocols, such as RMI, HTTP, Ibis, etc. Therefore,
      the P2P infrastructure can use RMI or HTTP as communication layer.
      Hence, the P2P infrastructure is implemented with classic ProActive
      active objects and especially with ProActive typed group for
      broadcasting communications between peers due to your inspired
      BFS.</para>

      <para>Using active objects for the implementation is a good mapping with
      the idea of a peer which is an independent entities that works as a
      server with a FIFO request queue. The peer is also a client which sends
      requests to other peers.</para>

      <para>The list of P2P active objects:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">P2PService</emphasis>: is the main
          active object. It serves all register requests or resource queries,
          such as nodes or acquaintances.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">P2PNodeManager</emphasis>: works
          together with the P2PService, this active object manages one or
          several shared nodes. It handles the booking node system, see 
          <xref linkend="mozTocId690451"/> for more details.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">P2PAcquaintanceManager</emphasis>:
          manages the list of acquaintances and provides group communication,
          see  <xref linkend="mozTocId587594"/>.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">P2PNodeLookup</emphasis>: works as a
          broker when the P2PService asks nodes. All the asking node protocol
          is inside it. This broker can migrate to a different node to be
          closer to the deployed application.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">FirstContact</emphasis>: it's the 
           bootstrapping object (see <xref linkend="mozTocId101413"/>).</para>
        </listitem>
      </itemizedlist>

      <para>The Figure below shows the connection between all active
      objects:</para>

      <para><figure><info><title>Nodes and Active Objects which make up a P2P Service.</title></info>
          

          <mediaobject>
            <imageobject>
              <imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="p2p_files/implementation.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>All communications between peers use Group communication but for
      sending a response to a request message, it's a point-to-point
      communication. Though ProActive communications are asynchronous, it's
      not really messages which are sent between peers. Nevertheless, it's not
      a real problem; ProActive is implemented above Java RMI which is RPC and
      RPC is synchronous. However, ProActive uses future mechanism and
      Rendez-vous method to turn RPC methods to asynchronous. That means
      ProActive is asynchronous RPC. Rendez-vous is interesting in your case
      because it guarantees the method is successfully received by the
      receiver. With the Heart beat message which is sent a Java exception
      when an acquaintance is down.</para>

      <para>The P2PAcquaintanceManager manages the list of acquaintances, this
      list is represented by a ProActive typed group of P2PService. This is
      the point of the next section.</para>
    </section>

    <section xml:id="mozTocId587594"><info><title>  Dynamic Shared ProActive Group</title></info>
      

      <para>ProActive typed group does not allow access to group elements and
      make calls from different active objects to the same group is not
      possible, i.e. a group can not be shared. However, the point of the P2P
      infrastructure is to broadcast messages to all members on the
      acquaintance list, ProActive typed group is perfect for doing that. A
      typed group of P2PService is a good implementation of the acquaintance
      list design.</para>

      <para>But a typed group does not support to be shared by many active
      objects, especially for making group method calls from different
      objects, adding / removing / etc. members in the group. For the P2P
      infrastructure the P2PAcquaintanceManager (PAM) was designed.</para>

      <para>The PAM is a standard active object, at its initialization it
      constructs an empty P2PService group. The PAM provides an access to few
      group methods, such as removing, adding and group size methods. All
      other active objects, such as P2PService or P2PNodeLookup, have to use
      PAM methods to access the group. The PAM works as a server with an FIFO
      queue behind the group.</para>

      <para>That solves the problem of group members accessing but not how
      other active objects can call methods on the group. The ProActive group
      API provides a method to active a group that is made possible to get
      ProActive reference on the group. The PAM actives the group after its
      creation. P2PService, P2PNodeLookup and all get the group reference from
      a PAM's getter.</para>

      <para>The PAM, during its activity, frequently sends heart beats to
      remove unavailable peers. The P2PService adds, via the PAM, new
      discovered acquaintances (P2PService) and the P2PNodeLookup calls group
      methods to ask nodes to the group reference. The P2PService does also
      group method calls.</para>

      <para>In short, this can be seen in the next Figure:</para>

      <para><figure><info><title>Dynamic Shared ProActive Typed Group.</title></info>
          

          <mediaobject>
            <imageobject>
              <imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="p2p_files/dynamicGroup.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>We just explained how to share a typed group between active
      objects but that is not solve all the problems. For the moment, the BFS
      implementation with broadcasting to all acquaintances each time is not
      perfect due to the message which is always send back to the previous
      sender. We are working to add member exclusion in a group method
      call.</para>
    </section>

    <section xml:id="mozTocId690451"><info><title>Sharing Node Mechanism</title></info>
      

      <para>The sharing node mechanism is an independent activity from the P2P
      service. Nodes are the sharing resource of this P2P network. This
      activity is handled by the P2PNodeManager active object.</para>

      <para>At the initialization of the P2PNodeManager (PNM), it has to
      instantiate the shared resource. By default, it's 1 ProActive nodes by
      CPUs, for example on a single processor machine the PNM starts 1 node
      and on a bi-processors machine it starts 2 nodes. It's possible to
      choose to share only a single node. An another way is to share nodes
      from an XML deployment descriptor file by specifing the descriptor to
      the PNM which actives the deployment and gets nodes ready to
      share.</para>

      <para>When the P2P service receives a node request, the request is
      forwarded (after the BFS broadcast) to the PNM which checks for a free
      node. In the case of at least 1 free node, the PNM must book the node
      and send back a reference to the the node to the original request
      sender. However, the booking remains valid for a predetermined time,
      this time expires after a configurable timeout. The PNM knows if the
      node is used or not by testing the active object presence inside the
      node. Consequently, at the end of the booking time, the PNM kills the
      node, the node is no longer usable. Though, some applications need empty
      nodes for a long time before using them, thereby there is a pseudo
      expand booking time system: creating 'Dummy' active objects in booked
      nodes for later use. This system is allowed by the P2PNodeLookup.</para>

      <para>The P2PNodeLookup could receive more nodes than it needs, for all
      additional nodes, the P2PNodeLookup sends a message to all PNMs' nodes
      to cancel its booking on the node.</para>

      <para>The deployed applications have to leave nodes after use.
      Therefore, the PNM offers a leaving node mechanism that is the
      application sent a leaving message for a specified node to the PNM which
      kills all node's active objects by terminating their bodies and kills
      the node. After that, the PNM creates a new node which is ready for
      sharing. However, if nodes are deployed by an XML descriptor the PNM
      does't kill the node, it just terminates all its active objects and
      re-shares the same node.</para>

      <para>The asking node mechanism is allowed by the P2PNodeLookup, this
      object is active by the P2PService when it receives an asking node
      request from an application. The P2PNodeLookup (PNL) works as a broker,
      it could migrate to another place (node, machine, etc.) to be near the
      application.</para>

      <para>The PNL aims to find the number of nodes requested by the
      application. It uses the BFS to frequently flood the network until it
      gets all nodes or until the timeout is reached. However, the application
      can ask to the maximum number of nodes, in that case the PNL asks to
      nodes until the end of the application. The PNL provides a listener /
      producer event mechanism which is great for the application which wants
      to know when a node is found.</para>

      <para>Finally, the application kills nodes by the PNL which is in charge
      of contacting all the PNMs of each node and asks them to leave nodes.
      The PNMs leave nodes with the same mechanism of the booking
      timeout.</para>

      <para>Lastly, the asking nodes mechanism with the PNL is fully
      integrated to the ProActive XML deployment descriptor.</para>
    </section>

    <section xml:id="mozTocId586812"><info><title>Monitoring: IC2D </title></info>
      

	<para>IC2D hides all P2P internal object by default, in order to monitor the
	infrastructure itself we invite you to check the IC2D documentation <xref linkend="IC2D_EclipsePlugin"/> to set
	the right option.</para>
	
	
      <para>A screen shot made with IC2D. You can see 3 P2P services which are
      sharing 2 nodes (bi-processors machines). Inside the nodes there are
      some active Domain objects from the nBody application which is deployed
      on this small P2P infrastructure.</para>

      <para><figure><info><title>nBody application deployed on P2P Infrastructure.</title></info>
          

          <mediaobject>
            <imageobject>
              <imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="p2p_files/screenshot.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </figure></para>
    </section>
  </section>

  

  <section xml:id="p2p_html_limitations"><info><title> Future Work</title></info>
    

    <itemizedlist>
      <listitem>
        <para>Plug technical services (<xref linkend="technicalService"/>), such as Fault-tolerance schemes or Load
        Balancing, for each application at the deployment time.</para>
      </listitem>
    </itemizedlist>
  </section>
  
   <section xml:id="p2p_research"><info><title>Research Work</title></info>
    

    		<para>
			The seminal paper
			<citation>
				<xref linkend="p2p_article" endterm="p2p.abbrev"/>
			</citation>
			.
		</para>
		    <para>Further research information is available 
    at <uri xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www-sop.inria.fr/oasis/Alexandre.Di_Costanzo/">http://www-sop.inria.fr/oasis/Alexandre.Di_Costanzo/</uri>.</para>
		
		
  </section>
</chapter>
