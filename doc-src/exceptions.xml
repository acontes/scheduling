<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="exceptions">
  <title>Exception Handling</title>

  <indexterm><primary>Exceptions</primary></indexterm>

  <sect1 >
    <title>Exceptions and Asynchrony</title>

    <para>In the asynchronous environment provided by ProActive, exceptions
    cannot be handled the same as in a sequential environment. Let's see the
    problem with exceptions and asynchrony in a piece of code:</para>

    <programlisting lang="java"> <emphasis role="bold">try</emphasis> {
     Result r = someAO.someMethodCall(); // Asynchronous method call that can throw an exception
     // ...
     doSomethingWith(r);
 }  <emphasis role="bold">catch</emphasis> (SomeException se) {
     doSomethingWithMyException(se);
 }  </programlisting>

    <para>In this piece of code, as the method call in line 2 is asynchronous,
    we don't wait for its completion and continue the execution. So, it's
    possible the control flow exits the <emphasis role="bold">try</emphasis>.
    In this case, if the method call ends up with an exception, we cannot
    throw it anymore back in the code because we are no more in the <emphasis
    role="bold">try</emphasis> block. That's why, by default, ProActive method
    calls with potential exceptions are handled synchronously.</para>

    <sect2 >
      <title>Barriers around <emphasis role="bold">try</emphasis>
      blocks</title>

      <para>The ProActive solution to this problem is to put barriers around
      <emphasis role="bold">try</emphasis>/<emphasis
      role="bold">catch</emphasis> blocks. This way, the control flow cannot
      exit the block, the exception can be handled in the appropriate
      <emphasis role="bold">catch</emphasis> block, and the call is
      asynchronous within the block.</para>

      <para>With this configuration, the potential exception can be throw for
      several points:</para>

      <itemizedlist>
        <listitem>
          <para>When accessing a future</para>
        </listitem>

        <listitem>
          <para>In the barrier</para>
        </listitem>

        <listitem>
          <para>Using the provided API (see after)</para>
        </listitem>
      </itemizedlist>

      <para>Let's reuse the previous example to see how to use these
      barriers</para>

      <programlisting lang="java"> <emphasis role="bold">ProActive.tryWithCatch(SomeException.class);</emphasis>
 <emphasis role="bold">try</emphasis> {
       Result r = someAO.someMethodCall(); // Asynchronous method call that can throw an exception
       // ...
       doSomethingWith(r);
 <emphasis role="bold">ProActive.endTryWithCatch();</emphasis>
    } <emphasis role="bold">catch</emphasis> (SomeException se) {
       doSomethingWithMyException(se);
    } <emphasis role="bold">finally {</emphasis>
 <emphasis role="bold">ProActive.removeTryWithCatch();</emphasis>
 <emphasis role="bold">}</emphasis> </programlisting>

      <para>With this code, the call in line 3 will be asynchronous, and the
      exception will be handled in the correct <emphasis
      role="bold">catch</emphasis> block. Even if this implies waiting at the
      end of the <emphasis role="bold">try</emphasis> block for the completion
      of the call.</para>

      <para>Let's see in detail the needed modifications to the code:</para>

      <itemizedlist>
        <listitem>
          <para>ProActive.tryWithCatch() call right before the <emphasis
          role="bold">try</emphasis> block. The parameter is either the caught
          exception class or an array of these classes if there are
          many</para>
        </listitem>

        <listitem>
          <para>ProActive.endWithTry() at the end of the <emphasis
          role="bold">try</emphasis> block</para>
        </listitem>

        <listitem>
          <para>ProActive.removeTryWithCatch() at the beginning of the
          <emphasis role="bold">finally</emphasis> block, so the block becomes
          mandatory</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 >
      <title>TryWithCatch Annotator</title>

      <para>These needed annotations can be seen as cumbersome, so we provide
      a tool to add them automatically to a given source file. It transforms
      the first example code in the second. Here is a sample session with the
      tool:</para>

      <screen>$ ProActive/scripts/unix/trywithcatch.sh MyClass.java 
--- ProActive TryWithCatch annotator -----------------------
$ diff -u MyClass.java~ MyClass.java
--- MyClass.java~
+++ MyClass.java
@@ -1,9 +1,13 @@
 public class MyClass {
     public MyClass someMethod(AnotherClass a) {
+        ProActive.tryWithCatch(AnException.class);
         try {
             return a.aMethod();
+            ProActive.endTryWithCatch();
         } catch (AnException ae) {
             return null;
+        } finally {
+            ProActive.removeTryWithCatch();
         }
     }
 }</screen>

      <para>As we can see, ProActive method calls are added to make sure all
      calls within <emphasis role="bold">try</emphasis>/<emphasis
      role="bold">catch</emphasis> blocks are handled asynchronously.</para>
    </sect2>

    <sect2 >
      <title>Additional API</title>

      <para>We have seen the 3 methods mandatory to perform asynchronous calls
      with exceptions, but the complete API includes two more calls. So far,
      the blocks boundaries define the barries. But, some control over the
      barrier is provided thanks to two additional methods.</para>

      <para>The first method is ProActive.throwArrivedException(). During a
      computation an exception may be raised but there is no point from where
      the exception can be thrown (a future or a barrier). The solution is to
      call the ProActive.throwArrivedException() method which simply queries
      ProActive to see if an exception has arrived with no opportunity of
      being thrown back in the user code. In this case, the exception is
      thrown by this method.</para>

      <para>The method behaviour is thus dependant on the timing. That is,
      calling this method may or may not result in an exception being thrown,
      depending on the time for an exception to come back. That's why another
      method is provided, this is ProActive.waitForPotentialException().
      Unlike the previous one, this method is blocking. After calling this
      method, either an exception is thrown, or it is assured that all
      previous calls in the block completed successfully, so no exception can
      be thrown from the previous calls.</para>
    </sect2>
  </sect1>
</chapter>
