<!-- Converted by db4-upgrade version 1.0 -->

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="exceptions"><info><title>Exception Handling</title></info>
  

  <indexterm><primary>Exceptions</primary></indexterm>

  <section><info><title>Exceptions and Asynchrony</title></info>
    

    <para>In the asynchronous environment provided by ProActive, exceptions
    cannot be handled the same as in a sequential environment. Let's see the
    problem with exceptions and asynchrony in a piece of code:</para>

    <programlisting xml:lang="java"><textobject><textdata fileref="code_snippets/exceptions/basic_exception.txt"/></textobject> </programlisting>

    <para>As the method call in line 2 is asynchronous, the program continues execution 
    without waiting for its completion. So, it is
    possible for the control flow to exit the <literal>try</literal>.
    In this case, if the method call finishes with an exception, we cannot
    throw it back in the code anymore because we are no more in the <literal>
    try</literal> block. That is why ProActive method
    calls with potential exceptions are handled synchronously by default.</para>

    <section><info><title>Barriers around <literal>try</literal>
      blocks</title></info>
      

      <para>The ProActive solution to this problem is to put barriers around
      <literal>try/catch</literal> blocks. This way the control flow cannot
      exit the block, the exception can be handled in the appropriate
      <literal>catch</literal> block, and the call is
      asynchronous within the block.</para>

      <para>With this configuration, the potential exception can be thrown at
      several points:</para>

      <itemizedlist>
        <listitem>
          <para>when accessing a future</para>
        </listitem>

        <listitem>
          <para>inside the barrier</para>
        </listitem>

        <listitem>
          <para>by using the provided API (see after)</para>
        </listitem>
      </itemizedlist>

      <para>Let's reuse the previous example to see how to use these
      barriers</para>

      <programlisting xml:lang="java"><textobject><textdata fileref="code_snippets/exceptions/trywithcatch_exception.txt"/></textobject></programlisting>

      <para>With this code, the call in line 3 will be asynchronous, and the
      exception will be handled in the correct <literal>
      catch</literal> block. Even if this implies waiting at the
      end of the <literal>try</literal> block for the completion
      of the call.</para>

      <para>Let's see in detail the needed modifications to the code:</para>

      <itemizedlist>
        <listitem>
          <para><literal>PAException.tryWithCatch()</literal> call right before the <literal>
          try</literal> block. The parameter is either the caught
          exception class or an array of these classes if there are
          many</para>
        </listitem>

        <listitem>
          <para><literal>PAException.endTryWithCatch()</literal> at the end of the <literal>try</literal> block</para>
        </listitem>

        <listitem>
          <para><literal>PAException.removeTryWithCatch()</literal> at the beginning of the
          <literal>finally</literal> block, so the block becomes
          mandatory</para>
        </listitem>
      </itemizedlist>
    </section>

    <section><info><title>TryWithCatch Annotator</title></info>
      

      <para>These needed annotations can be seen as cumbersome, so we provide
      a tool to add them automatically to a given source file. It transforms
      the first example code in the second. Here is a sample session with the
      tool:</para>

      <programlisting xml:lang="screen"><textobject><textdata fileref="code_snippets/exceptions/trywithcatch_annotator_session.txt"/></textobject></programlisting>

      <para>As we can see, ProActive method calls are added to make sure all
      calls within <literal>try/catch</literal> blocks are handled asynchronously. The tool can be
      found in <literal>ProActive/scripts/unix/</literal>.</para>
      
    </section>
	<!-- TODO add an example maybe, currently there's no example whatsoever in the code -->
    <section><info><title><literal>throwArrivedException()</literal> and <literal>waitForPotentialException()</literal></title></info>
      

      <para>We have seen the 3 methods mandatory to perform asynchronous calls
      with exceptions, however the complete API includes two more calls. So far
      the blocks boundaries define the barries. But, some control over the
      barrier is provided thanks to two additional methods.</para>

      <para>The first method is <literal>PAException.throwArrivedException()</literal>. During a
      computation an exception may be raised but there is no point from where
      the exception can be thrown (a future or a barrier). The solution is to
      call the <literal>PAException.throwArrivedException()</literal> method which simply queries
      ProActive to see if an exception has arrived with no opportunity of
      being thrown back in the user code. In this case, the exception is
      thrown by this method.</para>

      <para>The method behaviour is thus dependent on the timing. That is,
      calling this method may or may not result in an exception being thrown,
      depending on the time for an exception to come back. That is why another
      method is provided:  <literal>PAException.waitForPotentialException()</literal>.
      Unlike the previous <literal>PAException.throwArrivedException()</literal>,
       this method is blocking. After calling this
      method, either an exception is thrown or it is assured that all
      previous calls in the block completed successfully, so no exception can
      be thrown from the previous calls.</para>
    </section>
  </section>
</chapter>
