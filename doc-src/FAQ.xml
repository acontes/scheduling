<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<appendix id="FAQ">
  <title>Frequently Asked Questions</title>

  <para><emphasis role="bold">Note:</emphasis> This FAQ is under construction.
  If one of your question is not answered here, just send it at 
  <email>proactive@objectweb.org</email> and we'll update the FAQ.</para>

 <qandaset>
 
  <qandadiv>
   <title>Running ProActive</title>
  
  <qandaentry>
        <question>
          <para>How do I build ProActive from the distribution?</para>
        </question>

        <answer>
         <para>ProActive uses 
          <ulink url="http://jakarta.apache.org/ant/">Ant</ulink> for its build.
          Assuming that the environment variable <literal>JAVA_HOME</literal>
          is properly set to your Java distribution, just go into the
          <literal>compile</literal> directory and use the script:</para>
         
         <itemizedlist>
          <listitem> <para>on Windows: <literal>build.bat all</literal></para> </listitem>
          <listitem> <para>on Unix systems: <literal>build all</literal></para> </listitem>
         </itemizedlist>
         
         <para> <literal>'all'</literal>  represents the target of the 
          build. It will compile all sources files and generate the documentation.
          To compile only the source files, for example if you 
          have modified the code, you should try</para>          
         <itemizedlist>
          <listitem> <para>on Windows: <literal>build.bat compile</literal></para> </listitem>
          <listitem> <para>on Unix systems: <literal>build compile</literal></para> </listitem>
         </itemizedlist>

          <para>If you want only to compile only parts of ProActive, 
           you should try <literal>build</literal>, with no arguments. 
           As of version v3.2, the result is: </para>
          
          <screen>/home/bob/ProActive/compile/$ build
           Buildfile: ./proactive.xml
           
           Main targets:
           
           all            Compile All and build the docs
           clean          Remove all generated files
           compile        build the class files
           core           Compile the ProActive core classes
           dist           Create the distribution binary
           docs           Construct the javadoc and the manual
           examples       Compile all the examples
           ibis           Everything related to ProActive IBIS
           ic2d           Compile the IC2D Tool
           javadoc        Use javadoc to build information on the ProActive classes
           manual         Build all the different manual version: html, pdf...
           manualHtml     Make only the html files in the manual
           manualPdf      Make only the pdf files in the manual
           rewrite        Rewrite classes to enhance performance with ibis
           runBench       Run benchmarks
           runTests       Run all non regression tests
           runTestsLocal  Run all non regression tests on the current host only
           Default target: compile </screen>          

          </answer>
      </qandaentry>

      <qandaentry>
       <question>
        <para>Why don't the examples and compilation work under Windows?</para>
       </question>
       
         <answer>
					 <indexterm><primary>Microsoft Windows</primary><secondary>Running ProActive</secondary></indexterm>
					 
        <para>It happens quite often, that the default installation
         directory under Windows is under Program Files which contains space.
         Then setting the JAVA_HOME environment variable to the install
         directory, might be a problem for bat files(all windows examples,
         and compilation are ran with bat files). To get rid of those
         problems, the best thing is to install jdk in a directory whose name
         does not contain spaces such as C:\java\j2sdk.... or
         D:\java\j2sdk... and then to set the JAVA_HOME environment variable
         accordingly: set JAVA_HOME=C:\java\j2sdk... Another solution is to
         do a copy paste of the command defined in the bat file in the DOS
         window.</para>
       </answer>
      </qandaentry>
      
      <qandaentry>
        <question>
          <para>Why do I get a Permission denied when trying to launch
          examples scripts under Linux?</para>
        </question>

        <answer>
          <para>According to the tool used to unpackage the ProActive
          distribution, permissions of newly created files can be based on
          default UMASK permissions. If you get a permission denied, just run
          the command: chmod 755 *.sh in the ProActive/scripts/unix directory
          in order to change the permissions.</para>
        </answer>
      </qandaentry>

     </qandadiv>
     <qandadiv>
       <title>General Concepts</title>
       
       
       <qandaentry>
        <question>
         <para>How does the node creation happen?</para>
        </question>
        
        <answer>
         <para>An active object is always attached to a node. A node
          represents a logical entity deployed onto one JVM. When creating a
          new active object you have to provide a URL or a reference to a
          node. That node has to exist at the moment you create the active
          object. It has to be launched on a local or on a remote JVM. In
          order to be accessible from any remote JVM, a node automatically
          registers itself in the local RMI Registry on the local machine.
          Getting a reference to a remote node ends up doing a lookup into a
          RMI registry. The class <literal>NodeFactory</literal> provides a
          method <literal>getNode</literal> for doing that.</para>
         
         <para>In order to start a node you can use the script
          <literal>startNode</literal> located in the
          <literal>scripts</literal> directory in the sub-directory
          <literal>windows</literal> or <literal>unix</literal>. At the
          moment, <literal>startNode</literal> can only start a node on the
          local machine. It is not possible to start a remote node using
          startNode. The reason is that starting a node on a remote host
          implies the use of protocol such as RSH, SSH or rLogin that are
          platform dependant and that cannot be easily abstracted from java.
          We are working on that area at the moment with the XML-based
          deployment descriptor that will allow the remote creation of nodes
          using various protocol.</para>
         
         <para>It is nevertheless possible to create an object on a remote
          node once it is created. On host X you can use startNode to start a
          new node</para>
         
         <screen> startNode.sh ///node1 </screen>
         
         <para>On host Y you can create an active object on host X</para>
         
         <screen>        org.objectweb.proactive.core.node.Node n = org.objectweb.proactive.core.n\
          ode.NodeFactory.getNode('//X/node1');
          ProActive.turnActive(myObject, n);       </screen>
         
         <para>You do not need to start any rmiregistry manually as they are
          started automatically as needed.</para>
         
         <para>As we support other ways of registration and discovery (such
          as Jini), getting a node can be protocol dependant. For instance,
          the url of a node <literal>jini://host.org/node</literal> won't be
          accessed the same way as <literal>rmi://host.org/node</literal>. The
          class <literal>NodeFactory</literal> is able to read the protocol
          and to use the right way to access the node.</para>
         
         <para>When an active object is created locally without specifying a
          node, it is automatically attached to a default node. The default
          node is created automatically by <emphasis
                                                    role="bold">ProActive</emphasis> on the local JVM when a first
          active object is created without a given node. The name of the
          default node is generated based on a random number.</para>
        </answer>
       </qandaentry>
       
       
       <qandaentry>
        <question>
         <para>How does the RMI Registry creation happen?</para>
        </question>
        
        <answer>
         <para><emphasis role="bold">ProActive</emphasis> relies on the RMI
          Registry for registering and discovering nodes. For this reason, the
          existence of a RMI Registry is necessary for 
          <emphasis role="bold">ProActive</emphasis> to be used. In order to simplify
          the deployment of <emphasis role="bold">ProActive</emphasis>
          applications, we have included the creation of the RMI Registry with
          the creation of nodes. Therefore, if no RMI Registry exists on the
          local machine, <emphasis role="bold">ProActive</emphasis> will
          automatically create one. If one exists, 
          <emphasis role="bold">ProActive</emphasis> will automatically use it.</para>
        </answer>
       </qandaentry>
       
       
       
       <qandaentry>
        <question>
         <para>What is the class server, why do we need it?</para>
        </question>
        
        <answer>
         <para>In the RMI model, a class server is a HTTP Server able to
          answer simple HTTP requests for getting class files. It is needed in
          the case an object being sent to a remote location where the class
          the object belongs to is unknown. In such case, if the property
          <literal>java.rmi.server.codebase</literal> has been set properly to
          an existing class server, RMI will attempt to download the missing
          class files.</para>
         
         <para>Because <emphasis role="bold">ProActive</emphasis> makes use
          of on-the-fly, in memory, generated classes (the stubs), a class
          server is necessary for each JVM using active objects. For this
          reason, <emphasis role="bold">ProActive</emphasis> starts
          automatically one small class server per JVM. The launching and the
          use of this class server is transparent to you.</para>
        </answer>
       </qandaentry>
       
       <qandaentry id="reifiableDefinition">
        <question>
         <para>What is a reifiable object?</para>
        </question>
        
        <answer>
         <para>An object is said to be reifiable if it meets certain
          criterias in order to become an Active Object:</para>
         
         <itemizedlist>
          <listitem>
           <para>The object is not of primitive type</para>
          </listitem>
          
          <listitem>
           <para>The class of the object is not final</para>
          </listitem>
          
          <listitem>
           <para>The object has a constructor with no arguments</para>
          </listitem>
         </itemizedlist>
        </answer>
       </qandaentry>
       
       <qandaentry>
        <question>
         <para>What is the body of an active object? What are its local and
          remote representations?</para>
        </question>
        
        <answer>
         <para>When created, an active object is associated with a Body that
          is the entity managing all the non functional properties of the
          active object. The body contains the request queue receiving all
          reified method calls to the reified object (the object from which
          the active object has been created). It is responsible for storing
          pending requests and serving them according to a given
          synchronization policy, which default behavior is FIFO.</para>
         
         <para>The body of the active object should be the only object able
          to access directly the reified object. All other objects accessing
          the active object do so through the stub-proxy couple that
          eventually sends a request to the body. The body owns its own thread
          that represent the activity of the active object.</para>
         
         <para>The body has two representations. One is local and given by
          the interface Body (see code in <xref role="javaFileSrc" linkend="Body.java"/>). This is the
          local view of the body an object can have when being in the same JVM
          as the body. For instance, the implementation of the activity of an
          object done through the method <literal>runActivity(Body)</literal>
          of the interface <literal>RunActive</literal> sees the body locally
          as it is instantiated by the body itself. The other representation,
          given by the interface UniversalBody 
          (see code in <xref role="javaFileSrc" linkend="core/body/UniversalBody.java"/>), is
          remote. It represents the view of the body a remote object can have
          and therefore the methods that can be invoked. That view is the one
          used by the proxy of a remote reference to the active object to send
          request to the body of the active object.</para>
        </answer>
       </qandaentry>
       
       <qandaentry>
        <question>
         <para>What is a ProActive stub?</para>
        </question>
        
        <answer>
         <para>When you create an active object from a regular object, you
          get in return a reference on an automatically generated 
          <emphasis role="bold">ProActive</emphasis> stub. 
          <emphasis role="bold">ProActive</emphasis> uses 
          <ulink url="http://asm.objectweb.org/">ASM</ulink> to generate the stub on
          the fly. Suppose you have a class <literal>A</literal> and an
          instance <literal>a</literal> of this class. A way to turn the
          instance <literal>a</literal> into an active object is to use the
          method <literal>ProActive.turnActive</literal>:</para>
         
         <screen>    A a = new A();
          A activeA = (A) ProActive.turnActive(a);</screen>
         
         <para>In the code above, the variable <literal>a</literal> is a
          direct reference onto the instance of <literal>A</literal> stored
          somewhere in memory. In contrast, the variable
          <literal>activeA</literal> is a direct reference onto an instance of
          the generated ProActive stub for the class <literal>A</literal>. By
          convention, the ProActive stub of a class <literal>A</literal> is a
          class generated in memory by ProActive that inherit from
          <literal>A</literal> and that is stored in the package
          <literal>pa.stub</literal> as <literal>pa.stub.Stub_A</literal>. The
          ProActive stub of a class redefines all public methods to reify them
          through a generic proxy. The proxy changes all method calls into
          requests that are sent to the body associated to the reified object
          (the object pointed by <literal>a</literal> in our example).</para>
         
         <para>The reified object can be indifferently in the same virtual
          machine as the active reference or in another one.</para>
        </answer>
       </qandaentry>
       
      <qandaentry>
       <question>
        <para>Are the call to an Active Object always asynchronous?</para>
       </question>
       
       <answer>
        <para>No. Calls to an Active Object methods are asynchronous under
         some conditions. This is explained in
         <xref linkend="FutureObjectCreation"/>. If for instance the
         return type of a method call is not reifiable, you can use wrappers
         to keep asynchronism capabilities: suppose that one of your object
         has a method</para>
        
        <screen> <emphasis role="bold"> int</emphasis> getNumber() </screen>
        
        <para>calling this method with ProActive is sychronous since the 'int'
         type is not reifiable. To keep the asynchronism it is advised to
         use the classes given in the 
         <literal>org.objectweb.proactive.core.util.wrapper</literal> 
         package, or to create your own wrapper based on these examples. In
         the case highlighted above, you should use</para>
        
        <screen> <emphasis role="bold">IntWrapper </emphasis>getNumber() </screen>
                
        <para>Then calling this new <literal>getNumber()</literal> method is
         asynchronous. Remember that 
         <emphasis role="bold">only the methods return type are concerned</emphasis>,
         not the parameters.</para>
       </answer>
      </qandaentry>

      </qandadiv>
       <qandadiv>
        <title>Exceptions</title>

      <qandaentry>
        <question>
          <para>Why do I get an exception java.lang.NoClassDefFoundError about asm?</para>
        </question>

        <answer>
          <para>ProActive uses <ulink
          url="http://www.objectweb.org/asm/">ASM</ulink> for the on the fly
          generation of stub classes. The library <literal>asm.jar</literal>,
          provided in the directory <literal>lib</literal> of <emphasis
          role="bold">ProActive</emphasis> is needed in order for any active
          object to function properly. If the library is not in the
          <literal>CLASSPATH</literal> you will get the following exception or
          a similar one:</para>

<screen>    Exception in thread 'main' java.lang.NoClassDefFoundError: org/objectweb/asm/Constants
        at java.lang.ClassLoader.defineClass0(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:509)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:246)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:54)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:193)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:186)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:265)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:262)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:322)
        at org.objectweb.proactive.core.mop.MOP.&lt;clinit&gt;(MOP.java:88)
        at org.objectweb.proactive.ProActive.createStubObject(ProActive.java:836)
        at org.objectweb.proactive.ProActive.createStubObject(ProActive.java:830)
        at org.objectweb.proactive.ProActive.newActive(ProActive.java:255)
        at org.objectweb.proactive.ProActive.newActive(ProActive.java:180)
        at org.objectweb.proactive.examples.binarytree.TreeApplet.main(TreeApplet.java:103)</screen>

          <para>The problem can simply be fixed by adding asm<literal>.jar</literal> in the
          <literal>CLASSPATH</literal>.</para>
         
         <indexterm><primary>CLASSPATH</primary><secondary>missing</secondary></indexterm>
        </answer>
      </qandaentry>

      
      <qandaentry>
       <question>
        <para>Why do I get an exception java.lang.NoClassDefFoundError about bcel?</para>
       </question>
       
       <answer>

        <para>ProActive uses <ulink url="http://jakarta.apache.org/bcel/">BCEL</ulink> for the on the
         fly generation of stub classes. The library
         <literal>bcel.jar</literal>, provided in the directory
         <literal>lib</literal> of <emphasis role="bold">ProActive</emphasis>
         is needed in order for any active object to function properly. If
         the library if not in the <literal>CLASSPATH</literal> you will get
         the following exception or a similar one:</para>

        <screen>    Exception in thread 'main' java.lang.NoClassDefFoundError: org/apache/bcel/generic/Type
         at org.objectweb.proactive.core.mop.MOPClassLoader.loadClass(MOPClassLoader.java:129)
         at org.objectweb.proactive.core.mop.MOPClassLoader.loadClass(MOPClassLoader.java:109)
         at org.objectweb.proactive.core.mop.MOP.createStubClass(MOP.java:341)
         at org.objectweb.proactive.core.mop.MOP.findStubConstructor(MOP.java:376)
         at org.objectweb.proactive.core.mop.MOP.createStubObject(MOP.java:443)
         at org.objectweb.proactive.core.mop.MOP.newInstance(MOP.java:165)
         at org.objectweb.proactive.core.mop.MOP.newInstance(MOP.java:137)
         at org.objectweb.proactive.ProActive.createStubObject(ProActive.java:590)
         at org.objectweb.proactive.ProActive.createStubObject(ProActive.java:585)
         at org.objectweb.proactive.ProActive.newActive(ProActive.java:170)
         at org.objectweb.proactive.ProActive.newActive(ProActive.java:137)
         at DiscoveryManager.main(DiscoveryManager.java:226)</screen>
        
        <para>The problem can simply be fixed by adding
         <literal>bcel.jar</literal> in the <literal>CLASSPATH</literal>.</para>
        
        <indexterm><primary>CLASSPATH</primary><secondary>missing</secondary></indexterm>

       </answer>
      </qandaentry>
               
      <qandaentry>
       <question>
        <para>Why do I get an exception java.security.AccessControlException
         access denied?</para>
       </question>
       
       <answer>
        <para>If you don't properly set permissions when launching code
         using ProActive you may get the following exception or a similar
         one.</para>
        
        <screen>   java.security.AccessControlException: access denied (java.net.SocketPermission 127.0.0.1:1099 connect,resolve)
         at java.security.AccessControlContext.checkPermission(AccessControlContext.java:270)
         at java.security.AccessController.checkPermission(AccessController.java:401)
         at java.lang.SecurityManager.checkPermission(SecurityManager.java:542)
         at java.lang.SecurityManager.checkConnect(SecurityManager.java:1044)
         at java.net.Socket.connect(Socket.java:419)
         at java.net.Socket.connect(Socket.java:375)
         at java.net.Socket.&lt;init&gt;(Socket.java:290)
         at java.net.Socket.&lt;init&gt;(Socket.java:118)
         at sun.rmi.transport.proxy.RMIDirectSocketFactory.createSocket(RMIDirectSocketFactory.java:22)
         at sun.rmi.transport.proxy.RMIMasterSocketFactory.createSocket(RMIMasterSocketFactory.java:122)
         at sun.rmi.transport.tcp.TCPEndpoint.newSocket(TCPEndpoint.java:562)
         at sun.rmi.transport.tcp.TCPChannel.createConnection(TCPChannel.java:185)
         at sun.rmi.transport.tcp.TCPChannel.newConnection(TCPChannel.java:171)
         at sun.rmi.server.UnicastRef.newCall(UnicastRef.java:313)
         at sun.rmi.registry.RegistryImpl_Stub.lookup(Unknown Source)
         at org.objectweb.proactive.core.rmi.RegistryHelper.detectRegistry(RegistryHelper.java:101)
         at org.objectweb.proactive.core.rmi.RegistryHelper.getOrCreateRegistry(RegistryHelper.java:114)
         at org.objectweb.proactive.core.rmi.RegistryHelper.initializeRegistry(RegistryHelper.java:77)
         at org.objectweb.proactive.core.node.rmi.RemoteNodeFactory(RemoteNodeFactory.java:56)
         at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
         at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
         at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
         at java.lang.reflect.Constructor.newInstance(Constructor.java:274)
         at java.lang.Class.newInstance0(Class.java:296)
         at java.lang.Class.newInstance(Class.java:249)
         at org.objectweb.proactive.core.node.NodeFactory.createNodeFactory(NodeFactory.java:281)
         at org.objectweb.proactive.core.node.NodeFactory.createNodeFactory(NodeFactory.java:298)
         at org.objectweb.proactive.core.node.NodeFactory.getFactory(NodeFactory.java:308)
         at org.objectweb.proactive.core.node.NodeFactory.createNode(NodeFactory.java:179)
         at org.objectweb.proactive.core.node.NodeFactory.createNode(NodeFactory.java:158)
         ...</screen>
        
        <para>ProActive uses 
         <ulink url="http://java.sun.com/products/jdk/rmi/">RMI</ulink> as its
         underlying transport technology. Moreover it uses code downloading
         features to automatically move generated stub classes from one JVM
         to another one. For those reasons, ProActive needs to install a
         <literal>SecurityManager</literal> that controls the execution of
         the Java code based on a set of permissions given to the JVM.
         Without explicit permissions nothing is granted for the code running
         outside <literal>java.*</literal> or <literal>sun.*</literal>
         packages.</para>
        
        <para>See Permissions in the 
         <ulink url="http://java.sun.com/j2se/1.3/docs/guide/security/permissions.html">JavaTM
          2 SDK</ulink> to learn more about Java permissions.</para>
        
        <para>As a first approximation, in order to run your code, you can
         create a simple policy file granting all permissions for all
         code:</para>
        
        <screen> grant { permission java.security.AllPermission; }; </screen>
        
        <para>Then you need to start your Java program using the property
         <literal>-Djava.security.policy</literal>. For instance:</para>
        
        <screen> java -Djava.security.policy=my.policy.file MyMainClass </screen>
       </answer>
      </qandaentry>
 
      <qandaentry>
       <question>
        <para>Why do I get an exception when using Jini?</para>
       </question>
       
       <answer>
        <para>In order to get <emphasis role="bold">Jini</emphasis> working
         properly in ProActive, you have to put in your HOME directory a copy
         of proactive.java.policy located in ProActive/scripts/unix or
         windows. Indeed the rmid deamon needs this file to start. If you try
         to use Jini without this policy file, it will not work. Moreover, if
         you did it once, make sure that there is no file called
         machine_namejiniLockFile in your working directory. This file is
         usefull to avoid many Service Lookup to be created by concurrent
         threads. This file is removed automatically when a Lookup Service is
         created. If the application failed(for instance because of the
         policy file) it is possible that this file remains in the directory,
         in that case if you restart the application it will not work. So
         checkout if this file is present in your working directory, if so
         remove it and restart the application</para>
       </answer>
      </qandaentry>
      
      <qandaentry>
       <question>
        <para>Why do I get a java.rmi.ConnectException: Connection refused to host: 127.0.0.1 ?</para>
       </question>
       
       <answer>
        <para>Sometimes, the hosts files (<literal>/etc/hosts</literal> for UNIX)
         contains <literal>127.0.0.1</literal> along with the name of the machine.
         This troubles ProActive, and JAVA network connexions in general. To circumvent
         this issue , you should start your programs with the command line argument 
         <screen>-Dsun.net.spi.nameservice.provider.1=dns,sun"</screen>
         This tells java not to look at the hosts file, but rather to ask
         the DNS for network information.</para>
       </answer>
      </qandaentry>
      
     
     </qandadiv>
       <qandadiv>
        <title>Writing ProActive-oriented code</title>

        <qandaentry>
         <question>
          <para>Why aren't my object's properties updated?</para>
         </question>
         
         <answer>
          <para>Suppose you have a class <literal>A</literal> with an
           attribute <literal>a1</literal> as the example below.</para>
          
          <screen>    public class A {
           public int a1;
           public static void main(String[] args) {
           A a = new A();
           A activeA = (A) ProActive.turnActive(a);
           a.a1 = 2;       // set the attribute a1 of the instance pointed by a to 2
           activeA.a1 = 2; // !!! set the attribute a1 of the stub instance to 2
           }
           }</screen>
          
          <para>When you reference an active object, you always reference it
           through its associated stub 
           (see <xref linkend="ActiveObjectCreation_html_elementRole"/> for the definition of Stub). 
           The stub class inheriting from the reified class, it
           has also all its attributes. But those attributes are totally
           useless as the only role of the generated stub is to reify every
           public methods call into a request passed to the associated proxy.
           Therefore accessing directly the attributes of an active object
           through its active reference would result in accessing the
           attributes of the generated stub. This is certainly not the behavior
           one would expect.</para>
          
          <para>The solution to this problem is very simple: 
           <emphasis role="bold">active object properties should only be accessed through a
            public method</emphasis>. Otherwise, you're accessing the local
           Stub's properties.</para>
         </answer>
        </qandaentry>
        

        <qandaentry>
 <question>
  <para>How can I pass a reference on an active object or the
   difference between this and ProActive.getStubOnThis()?</para>
 </question>
 
 <answer>
  <para>Suppose you have a class <literal>A</literal> that you want to
   make active. In <literal>A</literal> you want to have a method that
   returns a reference on that instance of <literal>A</literal> as the
   example below.</para>
  
  <screen>  public class A {
   public A getRef() {
   return this;  // !!!! THIS IS WRONG FOR AN ACTIVE OBJECT
   }
   }</screen>
  
  <para>There is indeed a problem in the code above. If an instance of
   <literal>A</literal> is created as, or turned into an active object,
   the method <literal>getRef</literal> will in fact be called through
   the <emphasis role="bold">Body</emphasis> of the active object by
   its active thread. The value returned by the method will be the
   direct reference on the reified object and not a reference on the
   active object. If the call is issued from another JVM, the value
   will be passed by copy and the result (assuming A is serializable)
   will be a deep copy of A with no links to the active object.</para>
  
  <para>The solution, if you want to pass a link to the active object
   from the code of the reified object, is to use the method
   <literal>ProActive.getStubOnThis()</literal>. This method will
   return the reference to the stub associated to the active object
   whose thread is calling the method. The correct version of the
   previous class is:</para>
  
  <screen>  public class A {
   public A getRef() {
   return ProActive.getStubOnThis(); // returns a reference on the stub
   }
   }</screen>
 </answer>
</qandaentry>


<qandaentry>
 <question>
  <para>How can I create an active object?</para>
 </question>
 
 <answer>
  <para>To create an active object you invoke one of the methods
   <literal>newActive</literal> or <literal>turnActive</literal> of the
   <literal>ProActive</literal> class.
   <literal>ProActive.newActive</literal> creates an active object
   based on the instantiation of a new object,
   <literal>ProActive.turnActive</literal> creates an active object
   based on an existing object. The different versions of the same
   <literal>newActive</literal> or <literal>turnActive</literal>
   methods allow you to specify where to create the active object
   (which node) and to customize its activity or its body (see
   questions below).</para>
  
  <para>Here is a simple example creating an active object of class
   <literal>A</literal> in the local JVM. If the invocation of the
   constructor of class <literal>A</literal> throws an exception, it is
   placed inside an exception of type
   <literal>ActiveObjectCreationException</literal>. When the call to
   <literal>newActive</literal> returns, the active object has been
   created and its active thread is started.</para>
  
  <screen>  public class A {
   private int i;
   private String s;
   public A() {}
   public A(int i, String s) {
   this.i = i;
   this.s = s;
   }
   }
   // instance based creation 
   A a;
   Object[] params = new Object[] { new Integer (26), 'astring' };
   try {
   a = (A) ProActive.newActive(A.class.getName(), params);
   } catch (ActiveObjectCreationException e) {
   // creation of ActiveObject failed
   e.printStackTrace();
   }
   // object based creation
   A a = new A(26, 'astring');
   try {
   a = (A) ProActive.turnActive(a);
   } catch (ActiveObjectCreationException e) {
   // creation of ActiveObject failed
   e.printStackTrace();
   }</screen>
 </answer>
</qandaentry>


    <qandaentry>
 <question>
  <para>What are the differences between instantiation based and
   object based active objects creation?</para>
 </question>
 
 <answer>
  <para>In <emphasis role="bold">ProActive</emphasis> there are two
   ways to create active objects. One way is to use
   <literal>ProActive.newActive</literal> and is based on the
   instantiation of a new object, the other is to use
   <literal>ProActive.turnActive</literal> and is based on the use of
   an existing object.</para>
  
  <para>When using instantiation based creation, any argument passed
   to the constructor of the reified object through
   <literal>ProActive.newActive</literal> is serialized and passed by
   copy to the object. This is because the model behind 
   <emphasis role="bold">ProActive</emphasis> is uniform whether the active
   object is instantiated locally or remotely. The parameters are
   therefore guaranteed to be passed by copy to the constructor. When
   using <literal>ProActive.newActive</literal> you must make sure that
   the arguments of the constructor are
   <literal>Serializable</literal>. On the other hand, the class used
   to create the active object <emphasis role="bold">does not need to
    be</emphasis><literal>Serializable</literal> even in the case the
   active object is created remotly.</para>
  
  <para>When using object based creation, you create the object that
   is going to be reified as an active object before hand. Therefore
   there is no serialization involved when you create the object. When
   you invoke <literal>ProActive.turnActive</literal> on the object two
   cases are possible. If you create the active object locally (on a
   local node), it will not be serialized. If you create the active
   object remotely (on a remote node), the reified object will be
   serialized. Therefore, if the <literal>turnActive</literal> is done
   on a remote node, the class used to create the active object this
   way <emphasis role="bold">has to
    be</emphasis><literal>Serializable</literal>. In addition, when
   using <literal>turnActive</literal>, care must be taken that no
   other references to the originating object are kept by other objects
   after the call to turnActive. A direct call to a method of the
   originating object without passing by a ProActive stub on this
   object will break the model.</para>
 </answer>
</qandaentry>

<qandaentry>
 <question>
  <para>Why do I have to write a no-args constructor?</para>
 </question>
 
 <answer>
  <para><emphasis role="bold">ProActive</emphasis> automatically
   creates a stub/skeleton pair for your active objects. When the stub
   is instancied on the remote node, its constructor ascends the
   ancestors chain, thus calling its parent constructor [the active
   object]. So if you place initialization stuff in your no args
   constructor, it will be executed <emphasis role="bold">on the
    stub</emphasis>, which can lead to disastrous results!</para>
 </answer>
</qandaentry>

      <qandaentry>
       <question>
        <para id="activity">How do I control the activity of an active
         object?</para>
       </question>
       
       <answer>

        <para>As explained in <xref linkend="ActiveObjectCreationWithCustomActivity"/>, 
         there are two ways to define the activity of your active object</para>
        
        <itemizedlist>
         <listitem>
          <para>Implementing one or more of the sub-interfaces of
           <literal>Active</literal> directly in the class used to create
           the active object</para>
         </listitem>
         
         <listitem>
          <para>Passing an object implementing one or more of the
           sub-interfaces of <literal>Active</literal> in parameter to the
           method <literal>newActive</literal> or
           <literal>turnActive</literal></para>
         </listitem>
        </itemizedlist>
        
        <para><emphasis  role="bold">Implementing the interfaces
          directly in the class used to create the active
          object</emphasis></para>
        
        <para>This is the easiest solution when you do control the class
         that you make active. Depending on which phase in the life of the
         active object you want to customize, you implement the corresponding
         interface (one or more) amongst <literal>InitActive</literal>,
         <literal>RunActive</literal> and <literal>EndActive</literal>. Here
         is an example that has a custom initialization and activity.</para>
        
        <screen>  import org.objectweb.proactive.*;
         public class A implements InitActive, RunActive {
         private String myName;
         public String getName() {
         return myName;
         }
         // -- implements InitActive
         public void initActivity(Body body) {
         myName = body.getName();
         }
         // -- implements RunActive for serving request in a LIFO fashion
         public void runActivity(Body body) {
         Service service = new Service(Body);
         while (body.isActive()) {
         service.blockingServeYoungest();
         }
         }
         public static void main(String[] args) throws Exception {
         A a = (A) ProActive.newActive(A.class.getName,null);
         System.out.println('Name = '+a.getName());
         }
         }</screen>
        
        <para><emphasis  role="bold">Passing an object
          implementing the interfaces when creating the active
          object</emphasis></para>
        
        <para>This is the solution to use when you do not control the class
         that you make active or when you want to write generic activities
         policy and reused them with several active objects. Depending on
         which phase in the life of the active object you want to customize,
         you implement the corresponding interface (one or more) amongst
         <literal>InitActive</literal>, <literal>RunActive</literal> and
         <literal>EndActive</literal>. Here an example that has a custom
         activity.</para>
        
        <para>Compared to the solution above where interfaces are directly
         implemented in the reified class, there is one restriction here: you
         cannot access the internal state of the reified object. Using an
         external object should therefore be used when the implementation of
         the activity is generic enough not to have to access the member
         variables of the reified object.</para>
        
        <screen>  import org.objectweb.proactive.*;
         public class LIFOActivity implements RunActive {
         // -- implements RunActive for serving request in a LIFO fashion
         public void runActivity(Body body) {
         Service service = new Service(Body);
         while (body.isActive()) {
         service.blockingServeYoungest();
         }
         }
         }
         import org.objectweb.proactive.*;
         public class A implements InitActive {
         private String myName;
         public String getName() {
         return myName;
         }
         // -- implements InitActive
         public void initActivity(Body body) {
         myName = body.getName();
         }
         public static void main(String[] args) throws Exception {
         // newActive(classname, constructor parameter (null = none), 
         //           node (null = local), active, MetaObjectFactory (null = d\
         efault)
         A a = (A) ProActive.newActive(A.class.getName(), null, null, new LIFO\
         Activity(), null);
         System.out.println('Name = '+a.getName());
         }
         }</screen>
       </answer>
      </qandaentry>
      
      <qandaentry>
       <question>
        <para>What happened to the former live() method and Active
         interface?</para>
       </question>
       
       <answer>
        <para>The former <literal>Active</literal> interface was simply a
         marker interface allowing to change the body and/or the proxy of an
         active object. It was of no use most of the time and was made
         obsolete with the introduction of the MetaObjectFactory 
         (see code in <xref role="javaFileSrc" linkend="core/body/MetaObjectFactory.java"/>)
         in the <emphasis role="bold">0.9.3</emphasis> release.</para>
        
        <para>Up to <emphasis role="bold">ProActive 0.9.3</emphasis> the
         activity of an active object was given by a method
         <literal>live(Body)</literal> called by reflection of the reified
         object. Doing this way didn't allow compile time type checking of
         the method, was using reflection, didn't allow to externalize from
         the reified object its activity, didn't allow to give a custom
         activity to an active object created using
         <literal>turnActive</literal>. We addressed all those issues using
         the new mechanism based on the three interfaces
         <literal>InitActive</literal>, <literal>RunActive</literal> and
         <literal>EndActive</literal>.</para>
        
        <para>In order to convert the code of an active object containing a
         method <literal>live</literal> to the new interface you just need
         to:</para>
        
        <itemizedlist>
         <listitem>
          <para>implement the new interface <literal>RunActive</literal>
           (and remove <literal>Active</literal> if it was
           implemented)</para>
         </listitem>
         
         <listitem>
          <para>changed the name of the method <literal>live</literal> to
           <literal>runActivity</literal></para>
         </listitem>
        </itemizedlist>
       </answer>
      </qandaentry>
      
      <qandaentry>
       <question>
        <para>Why should I avoid to return null in methods body?</para>
       </question>
       
       <answer>
        <para>On the <emphasis role="bold">caller</emphasis> side the test
         <emphasis role="bold">if(result_from_method == null)</emphasis> has
         no sense. Indeed result_from_method is a couple Stub-FutureProxy as
         explained above, so even if the method returns null,
         result_from_method cannot be null:</para>
        
        <screen>public class MyObject{
         public MyObject(){
         //empty constructor with no-args
         }
         
         public Object getObject{
         if(.....) {
         return new Object();
         }
         else {
         return null; --&gt; to avoid in ProActive
         }
         }
         
         }</screen>
        
        <para>On the caller side:</para>
        
        <screen>MyObject o = new MyObject();
         Object result_from_method = o.getObject();
         if(result_from_method == null){
         ......
         }</screen>
        
        <para>This test is never true, indeed, result_from_method is
         <emphasis role="bold">Stub--&gt;Proxy--&gt;null</emphasis> if the
         future is not yet available or the method returns null or 
         <emphasis role="bold">Stub--&gt;Proxy--&gt;Object</emphasis> if the future is
         available, but result_from_method is <emphasis role="bold">never
          null</emphasis>. See Documentation on Futures in <xref linkend="FutureObjectCreation_commonerror"/>
         for more documentation about common errors to
         avoid.</para>
       </answer>
      </qandaentry>
      
      <qandaentry>
       <question>
        <para>How can I use Jini in ProActive?</para>
       </question>
       
       <answer>
        <para>In order to use <emphasis role="bold">Jini</emphasis> in
         ProActive you have to configure properly the deployment descriptor.
         All informations on how to configure XML deployment descriptor are
         provided in <xref linkend="XML_Descriptors"/>.</para>
       </answer>
      </qandaentry>
      
      <qandaentry>
        <question>
         <para>How do I make a Component version out of an Active Object
          version?</para>
        </question>
        
        <answer>
         <para>There is such an example, in the examples/components/c3d
          directory. The code for c3d is adapted to use components.</para>
         
         <para>There are several steps to cover:</para>
         
         <orderedlist>
          <listitem>
           <para>Make sure you have made interfaces for the objects which
            are to be made components. This is needed to be able to do the
            binding between components</para>
          </listitem>
          
          <listitem>
           <para>Replace the references to Active Object classes by their
            interfaces</para>
          </listitem>
          
          <listitem>
           <para>Create a component wrapper for each Active Object which
            should appear as a component. It should contain the binding
            behavior (bindFc,unbindFc,listFc,lookupFc methods), and maybe
            handle attribute modification.</para>
          </listitem>
          
          <listitem>
           <para>Create a main class where the compoents are created then
            bound, or use an ADL file to do so.</para>
          </listitem>
         </orderedlist>
        </answer>
       </qandaentry>
  
      
       <qandaentry>
        <question>
         <para>How can I use Jini in ProActive?</para>
        </question>
        
        <answer>
         <para>In order to use <emphasis role="bold">Jini</emphasis> in
          ProActive you have to configure properly the deployment descriptor.
          All informations on how to configure XML deployment descriptor are
          provided in <xref linkend="XML_Descriptors"/>.</para>
        </answer>
       </qandaentry>
       
       <qandaentry>
        <question>
         <para>Why is my call not asynchronous?</para>
        </question>
        
        <answer>
         <para>ProActive allows to have asynchronous code, 
          in the following cases:</para>
          
          <itemizedlist>
           <listitem>
            <para>The return value is reifiable (see <xref linkend="reifiableDefinition"/>).
             This is needed to ensure the creation of the Future, which is the container
             returned (the future is used while waiting for the effective result to arrive). 
             The returned class has to be Serializable, can not be final, and must have an empty 
             no-arguments constructor.</para>
           </listitem>
          
           <listitem>
            <para>The return value is void. In this case, the rendez-vous is made, and
             then the caller resumes its activity, while the receiver has now a new methodCall
             in its queue.  </para>
           </listitem>

          </itemizedlist>
          
          <para>More explanations can be found in <xref linkend="FutureObjectCreation"/>.</para>
        </answer>
        
       </qandaentry>
       
      
     </qandadiv>
     <qandadiv>
       <title>Deployment Descriptors</title>

       <qandaentry>
       <question>
        <para>What is the difference between passing parameters in
         Deployment Descriptor and setting properties in ProActive
         Configuration file?</para>
       </question>
       
       <answer>
        <para>Parameters defined in Deployment Descriptor should be only jvm
         related, whereas properties set in the Configuration file are
         ProActive properties or user-defined properties. They are used with
         a different approach: parameters given in descriptors are part of
         the java command that will create other jvms, whereas properties
         will be loaded once jvms are created</para>
       </answer>
      </qandaentry>
      
      <qandaentry>
       <question>
        <para>Why do I get the following message when parsing my xml
         deployment file: ERROR: file:~/ProActive/descriptor.xml Line:2
         Message:cvc-elt.1: Cannot find the declaration of element
         'ProActiveDescriptor'</para>
       </question>
       
       <answer>
        <para>This message turns up because the Schema cannot be found.
         Indeed at the beginning of our XML deployment files we put the
         line</para>
        
        <screen>&lt;ProActiveDescriptor xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' 
         xsi:noNamespaceSchemaLocation='DescriptorSchema.xsd'&gt;</screen>
        
        <para>which means, the schema named DescriptorSchema.xsd is expected
         to be found in the current directory to validate the xml. Be sure
         you have this file in the same dir than your file, or just change
         the path to point to the correct schema.</para>
       </answer>
      </qandaentry>
      

    </qandadiv>
   </qandaset>

   </appendix>
   
  
