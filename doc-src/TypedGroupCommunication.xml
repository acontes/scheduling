<!-- Converted by db4-upgrade version 1.0 -->

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="TypedGroupCommunication"><info><title>Typed Group Communication</title></info>
  

  <section xml:id="TypedGroupCommunication_html_overview"><info><title>Overview</title></info>
    

    <para>Group communication is a crucial feature for high-performance and
	    Grid computing. While previous works and libraries proposed such a
	    characteristic (e.g. MPI, or object-oriented frameworks), the use of
	    groups imposed specific constraints on programmers, for instance the use
	    of dedicated interfaces to trigger group communications. We aim at a more
	    flexible mechanism by proposing a scheme where,
	    given a Java class, one can initiate group communications using the
	    standard public methods of the class together with the classical dot
	    notation; in this way, group communications remains typed.
	</para>

    <para>In order to ease the use of the group communication, we provide a
	    set of static methods on the <literal>ProActiveGroup</literal> class and a
	    set of methods on the <literal>Group</literal> interface.	ProActive
	    also provides <literal>typed group communication</literal>, meaning that only methods defined on
		classes or interfaces implemented by members of the group
		can be called.	
	</para>
	<para>
	 	There are several ways to create groups of active objects. 	Similar to active objects,
	 	we have instantiation based creation and object based creation. Instantiation based
	 	creation is done through <literal>newGroup(..)</literal> and <literal>
	 	newGroupInParallel</literal> while object based creation is done through 
	 	<literal> turnActiveAsGroup(...)</literal>. 
	 	Group creation takes several parameters similar to active object creation.
	 	To understand the parameters that are not explained here read <xref linkend="ActiveObjectCreation"/>
	 	as it contains a detailed explanation of every active object creation parameter.
	 	The following diagrams contain
	 	all the methods in the <literal>PAGroup</literal> class and <literal>Group</literal> interface.   
	</para>     
     	<figure><info><title>PAGroup class  and Group interface</title></info>
			
			<mediaobject>
				<imageobject>
					<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="images/PAGroupAndGroup.png"  format="PNG"  align="center"/>
				</imageobject>
			</mediaobject>
	</figure>

<!-- 
     	<figure><info><title>Group creation methods and parameters</title></info>
			
			<mediaobject>
				<imageobject>
					<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="images/groupCreationMethodsTable.png"  format="PNG"  align="center"/>
				</imageobject>
			</mediaobject>
	</figure>
     -->
    <para>
    	In this chapter we will show how to create a group, send a request to the
    	members of the group, and retrieve the results. 
		For the examples  we will be using the following
			class that can be instantiated as an active	object:
		</para>	
		<programlisting xml:lang="java"><textobject><textdata fileref="code_snippets/ActiveWorker.txt"/></textobject></programlisting>

  </section>

  <section xml:id="TypedGroupCommunication_html_Creation"><info><title>Instantiation Typed Group Creation</title></info>
    

   

	 <indexterm><primary>Group</primary><secondary>Creation</secondary></indexterm>
    
 	   

    <para>Any object that is reifiable can be included in a
    group. Groups are created using the static method
    <literal>PAGroup.newGroup(...)</literal> or <literal>PAGroup.newGroupInParallel(...)</literal>.
    
    The common superclass for all the group members has to be specified, thus giving the group a minimal
    type. We will be using the <literal>Worker</literal> class specified above. </para>

  
  		<programlisting xml:lang="java"><textobject><textdata fileref="code_snippets/groupInstantiationCreation.txt"/></textobject></programlisting>
  
  
   
    <para>We can also specify parameters for the creation. If we have a class <literal>A</literal>
    we can specify an array of <literal>Object</literal> to hold the parameters:</para>

	<programlisting xml:lang="java"><textobject><textdata fileref="./automatic_snippets/group_creation_example.snip"/></textobject></programlisting>
	
	<para>We can access the individual members of the group using <literal>get(index)</literal></para>
	<programlisting xml:lang="java"><textobject><textdata fileref="./automatic_snippets/group_get_members.snip"/></textobject></programlisting>

    <para>Elements can be included into a typed group only if their class
    equals or extends the class specified at the group creation. For example,
    an object of class B (B extending A) can be included to a group of type A.
    However based on Java typing, only the methods defined in the class A can
    be invoked on the group.</para>
  </section>

  <section xml:id="TypedGroupCommunication_html_repr"><info><title>Group representation and manipulation</title></info>
    

    <para>The <emphasis role="bold">typed group representation</emphasis> we
    have presented corresponds to the functional view of groups of objects. In
    order to provide a dynamic management of groups, a second and
    complementary representation of a group has been designed. In order to
    manage a group, this second representation must be used instead. This
    second representation, <emphasis role="bold">the management
    representation</emphasis>, follows a more standard pattern for grouping
    objects: the <literal>Group</literal> interface.</para>

    <para>We are careful to have a strong coherence between both
    representations of the same group, which implies that modifications
    executed through one representation are immediately reported on the other
    one. In order to switch from one representation to the other, two methods
    have been defined : the static method named
    <literal>PAGroup.getGroup</literal>, returns the Group form
    associated to the given group object; the method
    <literal>getGroupByType</literal> defined in the <literal>Group</literal>
    interface does the opposite.</para>

    <para>Below is an example of when and how to use each representation of a
    group:</para>
    
      <para><programlisting xml:lang="java">   // definition of one standard Java object
   // and two active objects
A a1 = new A();
A a2 = (A) ProActive.newActive('A', paramsA[], node);
B b  = (B) ProActive.newActive('B', paramsB[], node);
   // Note that B extends A
   // For management purposes, get the representation
   // as a group given a typed group, created with
   // code on the left column:
Group gA = PAGroup.getGroup(ag1);
   // Now, add objects to the group:
   // Note that active and non-active objects 
   // may be mixed in groups
gA.add(a1);
gA.add(a2);
gA.add(b); 
   // The addition of members to a group immediately
   // reflects on the typed group form,  so a method
   // can be invoked on the typed group  and will
   // reach all its current members
ag1.foo(); // the caller of ag1.foo() may not belong to ag1
   // A new reference to the typed group  
   // can also be built as follows
A ag1new = (A) gA.getGroupByType();</programlisting></para>
 
 
     	<programlisting xml:lang="java"><textobject><textdata fileref="./automatic_snippets/get_group.snip"/></textobject></programlisting>
    
  </section>

  <section xml:id="TypedGroupCommunication_html_result"><info><title>Group as result of group communications</title></info>
    

    <para>The particularity of our group communication mechanism is that the
    <emphasis role="bold">result</emphasis> of a typed group communication
    <emphasis role="bold">is also a group</emphasis>. The result group is
    transparently built at invocation time, with a future for each elementary
    reply. It will be dynamically updated with the incoming results, thus
    gathering results. Nevertheless, the result group can be immediately used
    to execute another method call, even if all the results are not available.
    In that case the <emphasis role="bold">wait-by-necessity</emphasis>
    mechanism implemented by ProActive is used.</para>

    
      <para><programlisting xml:lang="java">   // A method call on a group, returning a result
V vg = ag1.bar();
   // vg is a typed group of 'V': operation 
   // below is also a collective operation
   // triggered on results
vg.f1();</programlisting></para>
    

    <para>As said in the Group creation section, groups whose type is based on
    final classes or primitive types cannot be built. So, the construction of
    a dynamic group as a result of a group method call is also limited.
    Consequently, only methods whose return type is either void or is a
    'reifiable type', in the sense of the Meta Object Protocol of ProActive,
    may be called on a group of objects; otherwise, they will raise an
    exception at run-time, because the transparent construction of a group of
    futures of non-reifiable types fails.</para>

    <para>To take advantage with the asynchronous remote method call model of
    ProActive, some new synchronization mechanisms have been added. Static
    methods defined in the <literal>PAGroup</literal> class enable to
    execute various forms of synchronisation. For instance:
    <literal>waitOne</literal>, <literal>waitN</literal>,
    <literal>waitAll</literal>, <literal>waitTheNth</literal>,
    <literal>waitAndGet</literal>. Here is an exemple:</para>

    
      <para><programlisting xml:lang="java">   // A method call on a typed group
V vg = ag1.bar(); 
   // To wait and capture the first returned 
   // member of vg
V v = (V) PAGroup.waitAndGetOne(vg);
   // To wait all the members of vg are arrived
PAGroup.waitAll(vg);
</programlisting></para>
    
  </section>

  <section xml:id="TypedGroupCommunication_html_comms"><info><title>Broadcast vs Dispatching</title></info>
    

    <para>Regarding the parameters of a method call towards a group of
    objects, the default behaviour is to broadcast them to all members. But
    sometimes, only a specific portion of the parameters, usually dependent of
    the rank of the member in the group, may be really useful for the method
    execution, and so, parts of the parameter transmissions are useless. In
    other words, in some cases, there is a need to transmit different
    parameters to the various members.</para>

    <para>A common way to achieve the scattering of a global parameter is to
    use the rank of each member of the group, in order to select the
    appropriate part that it should get in order to execute the method. There
    is a natural traduction of this idea inside our group communication
    mechanism:<emphasis role="bold">the use of a group of objects in order to
    represent a parameter of a group method call that must be scattered to its
    members</emphasis>.</para>

    <para>The default behaviour regarding parameters passing for method call
    on a group, is to pass a deep copy of the group of type P to all members.
    Thus, in order to scatter this group of elements of type P instead, the
    programmer must apply the static method <literal>setScatterGroup</literal>
    of the <literal>PAGroup</literal> class to the group. In order to
    switch back to the default behaviour, the static method
    <literal>unsetScatterGroup</literal> is available.</para>
	<para>We create a new group and a new group of parameters:</para>
	<programlisting xml:lang="java"><textobject><textdata fileref="./automatic_snippets/group_scatter_creation.snip"/></textobject></programlisting>
	<para>And then set the scattering, dispatch and set unscatter</para>
	<programlisting xml:lang="java"><textobject><textdata fileref="./automatic_snippets/group_scatter_example.snip"/></textobject></programlisting>
     
  </section>
  
  <section><info><title>Access By Name</title></info>
  <para> Group members can be accessed by name if on addition we specify the name.
  To use the named members we create the group and add members with  the <literal>addNamedElement(String key,E value)</literal> method 
  from the <literal>org.objectweb.proactive.core.group.Group</literal> interface. 
  </para>
  	<programlisting xml:lang="java"><textobject><textdata fileref="./automatic_snippets/typed_group_name_access_creation.snip"/></textobject></programlisting>
  <para>To retrieve the named members we use the <literal>getNamedElement(String) </literal> from the same interface.</para>
  	<programlisting xml:lang="java"><textobject><textdata fileref="./automatic_snippets/typed_group_name_access_example.snip"/></textobject></programlisting>
  </section>
  
  <section><info><title>Unique serialization</title></info>
  	<para>Unique serialization is an optimization option that allows performing the serialization
  	of the arguments before streaming them. If unique serialization is activated the arguments will 
  	be transformed into a byte array once, and afterward streamed. The one time serialization is
  	 useful if the size of the arguments is significant and we consider the bandwidth saved more 
  	 important than ability to stream the serialized objects as soon as possible. This behaviour
  	 can be toggled using <literal>setUniqueSerialization(Object)</literal> and
  	 <literal> unsetUniqueSerialization(Object) </literal> from the static class
  	  <literal>org.objectweb.proactive.api.PAGroup</literal></para>
   	<programlisting xml:lang="java"><textobject><textdata fileref="./automatic_snippets/group_unique_serialization.snip"/></textobject></programlisting>
 <para>To learn more, see the 
 <!-- This url can only work in the html generated files: in pdf there's no ".." -->
 <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="../api/org/objectweb/proactive/core/group/package-summary.html" os="html">JavaDoc</link> 
 <phrase os="pdf">javadoc of org.objectweb.proactive.core.group</phrase>
      and the paper <citation><xref linkend="BBC02" endterm="BBC02.abbrev"/></citation>.
     </para>

  </section>
  
</chapter>
