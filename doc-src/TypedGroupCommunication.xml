<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="TypedGroupCommunication">
  <title>Typed Group Communication</title>

  <sect1  id="TypedGroupCommunication_html_overview">
    <title>Overview</title>

    <para>Group communication is a crucial feature for high-performance and
	    Grid computing. While previous works and libraries proposed such a
	    characteristic (e.g. MPI, or object-oriented frameworks), the use of
	    groups imposed specific constraints on programmers, for instance the use
	    of dedicated interfaces to trigger group communications. We aim at a more
	    flexible mechanism by proposing a scheme where,
	    given a Java class, one can initiate group communications using the
	    standard public methods of the class together with the classical dot
	    notation; in this way, group communications remains typed.
	</para>

    <para>In order to ease the use of the group communication, we provide a
	    set of static methods on the <literal>ProActiveGroup</literal> class and a
	    set of methods on the <literal>Group</literal> interface.	ProActive
	    also provides <literal>typed group communication</literal>, meaning that only methods defined on
		classes or interfaces implemented by members of the group
		can be called.	
	</para>
	<para>
	 	There are several ways to create groups of active objects. 	Similar to active objects,
	 	we have instantiation based creation and object based creation. Instantiation based
	 	creation is done through <literal>newGroup(..)</literal> and <literal>
	 	newGroupInParallel</literal> while object based creation is done through 
	 	<literal> turnActiveAsGroup(...)</literal>. The following table contains
	 	the list of parameters that these two methods take. As the parameters are 
	 	similar with the ones used for active object creation we will only present those
	 	that are specific to group creation. 
	 	To understand the parameters that are not explained here read <xref linkend="ActiveObjectCreation"/>
	 	as it contains a detailed explanation of every active object creation parameter.  
	</para>

<!-- 
    
      <para><programlisting lang="java">   // created at once, 
   // with parameters specified  in params,
   // and on the nodes specified in nodes
A ag1 = (A) ProActiveGroup.newGroup( 'A', params, [nodes]);
   // A general group communication without result
   // A request to foo is sent in parallel to all active objects 
   // in the target group (ag1)
ag1.foo(...);
   // A general group communication with a result
V vg = ag1.bar(...);
   // vg is a typed group of 'V': operation 
   // below is also a collective operation
   // triggered on results
vg.f1();</programlisting></para>
    
     -->
     
     
     	<figure>
			<title>Group creation methods and parameters</title>
			<mediaobject>
				<imageobject>
					<imagedata
						fileref="images/groupCreationMethodsTable.png" 
						contentwidth="100" format="PNG"	width="6in" align="center" />
				</imageobject>
			</mediaobject>
	</figure>
    
    <para>
    	In this chapter we will show how to create a group, send a request to the
    	members of the group, and retrieve the results. 
		For the examples  we will be using the following
			class that can be instantiated as an active	object:
		</para>	
		<programlisting lang="java"><textobject><textdata
						fileref="code_snippets/ActiveWorker.txt" /></textobject></programlisting>

  </sect1>

  <sect1  id="TypedGroupCommunication_html_Creation" >
    

   <title>Instantiation Typed Group Creation</title>

	 <indexterm><primary>Group</primary><secondary>Creation</secondary></indexterm>
    
 	   

    <para>Any object that is reifiable can be included in a
    group. Groups are created using the static method
    <literal>PAGroup.newGroup(...)</literal> or <literal>PAGroup.newGroupInParallel(...)</literal>.
    
    The common superclass for all the group members has to be specified, thus giving the group a minimal
    type. We will be using the <literal>Worker</literal> class specified above. </para>

  
  		<programlisting lang="java"><textobject><textdata
						fileref="code_snippets/groupInstantiationCreation.txt" /></textobject></programlisting>
  
  
   
    <para>Here are examples of some group creation operations:</para>

    
      <para><programlisting lang="java">   // Pre-construction of some parameters: 
   //   For constructors:
Object[][] params = {{...} , {...} , ... };
   //   Nodes to identify JVMs to map objects
Node[] nodes  = { ... , ..., ... };
   // Solution 1: 
   // create an empty group of type 'A'
A ag1 = (A) PAGroup.newGroup('A');
   // Solution 2: 
   // a group of type 'A' and its members are 
   // created at once, 
   // with parameters specified  in params,
   // and on the nodes specified in nodes
A ag2 = (A) PAGroup.newGroup('A', params, nodes);
   // Solution 3: 
   // a group of type 'A'  and its members are 
   // created at once, 
   // with parameters specified in params,
   // and on the nodes directly specified 
A ag3 = (A) PAGroup.newGroup('A', params[], 
                   {rmi://globus1.inria.fr/Node1,
                    rmi://globus2.inria.fr/Node2});</programlisting></para>
    

    <para>Elements can be included into a typed group only if their class
    equals or extends the class specified at the group creation. For example,
    an object of class B (B extending A) can be included to a group of type A.
    However based on Java typing, only the methods defined in the class A can
    be invoked on the group.</para>
  </sect1>

  <sect1  id="TypedGroupCommunication_html_repr" >
    <title>Group representation and manipulation</title>

    <para>The <emphasis role="bold">typed group representation</emphasis> we
    have presented corresponds to the functional view of groups of objects. In
    order to provide a dynamic management of groups, a second and
    complementary representation of a group has been designed. In order to
    manage a group, this second representation must be used instead. This
    second representation, <emphasis role="bold">the management
    representation</emphasis>, follows a more standard pattern for grouping
    objects: the <literal>Group</literal> interface.</para>

    <para>We are careful to have a strong coherence between both
    representations of the same group, which implies that modifications
    executed through one representation are immediately reported on the other
    one. In order to switch from one representation to the other, two methods
    have been defined : the static method named
    <literal>PAGroup.getGroup</literal>, returns the Group form
    associated to the given group object; the method
    <literal>getGroupBytype</literal> defined in the <literal>Group</literal>
    interface does the opposite.</para>

    <para>Below is an example of when and how to use each representation of a
    group:</para>

    
      <para><programlisting lang="java">   // definition of one standard Java object
   // and two active objects
A a1 = new A();
A a2 = (A) ProActive.newActive('A', paramsA[], node);
B b  = (B) ProActive.newActive('B', paramsB[], node);
   // Note that B extends A
   // For management purposes, get the representation
   // as a group given a typed group, created with
   // code on the left column:
Group gA = PAGroup.getGroup(ag1);
   // Now, add objects to the group:
   // Note that active and non-active objects 
   // may be mixed in groups
gA.add(a1);
gA.add(a2);
gA.add(b); 
   // The addition of members to a group immediately
   // reflects on the typed group form,  so a method
   // can be invoked on the typed group  and will
   // reach all its current members
ag1.foo(); // the caller of ag1.foo() may not belong to ag1
   // A new reference to the typed group  
   // can also be built as follows
A ag1new = (A) gA.getGroupByType();</programlisting></para>
    
  </sect1>

  <sect1  id="TypedGroupCommunication_html_result">
    <title>Group as result of group communications</title>

    <para>The particularity of our group communication mechanism is that the
    <emphasis role="bold">result</emphasis> of a typed group communication
    <emphasis role="bold">is also a group</emphasis>. The result group is
    transparently built at invocation time, with a future for each elementary
    reply. It will be dynamically updated with the incoming results, thus
    gathering results. Nevertheless, the result group can be immediately used
    to execute another method call, even if all the results are not available.
    In that case the <emphasis role="bold">wait-by-necessity</emphasis>
    mechanism implemented by ProActive is used.</para>

    
      <para><programlisting lang="java">   // A method call on a group, returning a result
V vg = ag1.bar();
   // vg is a typed group of 'V': operation 
   // below is also a collective operation
   // triggered on results
vg.f1();</programlisting></para>
    

    <para>As said in the Group creation section, groups whose type is based on
    final classes or primitive types cannot be built. So, the construction of
    a dynamic group as a result of a group method call is also limited.
    Consequently, only methods whose return type is either void or is a
    'reifiable type', in the sense of the Meta Object Protocol of ProActive,
    may be called on a group of objects; otherwise, they will raise an
    exception at run-time, because the transparent construction of a group of
    futures of non-reifiable types fails.</para>

    <para>To take advantage with the asynchronous remote method call model of
    ProActive, some new synchronization mechanisms have been added. Static
    methods defined in the <literal>PAGroup</literal> class enable to
    execute various forms of synchronisation. For instance:
    <literal>waitOne</literal>, <literal>waitN</literal>,
    <literal>waitAll</literal>, <literal>waitTheNth</literal>,
    <literal>waitAndGet</literal>. Here is an exemple:</para>

    
      <para><programlisting lang="java">   // A method call on a typed group
V vg = ag1.bar(); 
   // To wait and capture the first returned 
   // member of vg
V v = (V) PAGroup.waitAndGetOne(vg);
   // To wait all the members of vg are arrived
PAGroup.waitAll(vg);
</programlisting></para>
    
  </sect1>

  <sect1  id="TypedGroupCommunication_html_comms" >
    <title>Broadcast vs Dispatching</title>

    <para>Regarding the parameters of a method call towards a group of
    objects, the default behaviour is to broadcast them to all members. But
    sometimes, only a specific portion of the parameters, usually dependent of
    the rank of the member in the group, may be really useful for the method
    execution, and so, parts of the parameter transmissions are useless. In
    other words, in some cases, there is a need to transmit different
    parameters to the various members.</para>

    <para>A common way to achieve the scattering of a global parameter is to
    use the rank of each member of the group, in order to select the
    appropriate part that it should get in order to execute the method. There
    is a natural traduction of this idea inside our group communication
    mechanism:<emphasis role="bold">the use of a group of objects in order to
    represent a parameter of a group method call that must be scattered to its
    members</emphasis>.</para>

    <para>The default behaviour regarding parameters passing for method call
    on a group, is to pass a deep copy of the group of type P to all members.
    Thus, in order to scatter this group of elements of type P instead, the
    programmer must apply the static method <literal>setScatterGroup</literal>
    of the <literal>PAGroup</literal> class to the group. In order to
    switch back to the default behaviour, the static method
    <literal>unsetScatterGroup</literal> is available.</para>

    
      <para><programlisting lang="java">   // Broadcast the group gb to all the members
   // of the group ag1:
ag1.foo(gb);
   // Change the distribution mode of the 
   // parameter group:
PAGroup.setScatterGroup(gb);
   // Scatter the members of gb onto the 
   // members of ag1:
ag1.foo(gb);</programlisting></para>
    

     
 <para>To learn more, see the 
 <!-- This url can only work in the html generated files: in pdf there's no ".." -->
 <ulink os="html" url="../api/org/objectweb/proactive/core/group/package-summary.html">JavaDoc</ulink> 
 <phrase os="pdf">javadoc of org.objectweb.proactive.core.group</phrase>
      and the paper <citation><xref linkend="BBC02" endterm="BBC02.abbrev"/></citation>.
     </para>
  </sect1>
</chapter>