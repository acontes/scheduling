<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="TypedGroupCommunication">
  <title>Typed Group Communication</title>

  <sect1  id="TypedGroupCommunication_html_overview">
    <title>Overview</title>

	<para>
		ProActive provides <literal>typed group commu-
		nication</literal>, meaning that only methods defined on
		classes or interfaces implemented by members of the group
		can be called.	
	</para>

    <para>Group communication is a crucial feature for high-performance and
    Grid computing. While previous works and libraries proposed such a
    characteristic (e.g. MPI, or object-oriented frameworks), the use of
    groups imposed specific constraints on programmers, for instance the use
    of dedicated interfaces to trigger group communications.</para>

    <para>We aim at a more flexible mechanism. We propose a scheme where,
    given a Java class, one can initiate group communications using the
    standard public methods of the class together with the classical dot
    notation; in that way, group communications remains typed.</para>

    <para>In order to ease the use of the group communication, we provide a
    set of static methods on the <literal>ProActiveGroup</literal> class and a
    set of methods on the <literal>Group</literal> interface.</para>

    <para>Here, a short compilation about the syntax and some method used in
    the Group Communication API is presented. More informations follow.</para>

    
      <para><programlisting lang="java">   // created at once, 
   // with parameters specified  in params,
   // and on the nodes specified in nodes
A ag1 = (A) ProActiveGroup.newGroup( 'A', params, [nodes]);
   // A general group communication without result
   // A request to foo is sent in parallel to all active objects 
   // in the target group (ag1)
ag1.foo(...);
   // A general group communication with a result
V vg = ag1.bar(...);
   // vg is a typed group of 'V': operation 
   // below is also a collective operation
   // triggered on results
vg.f1();</programlisting></para>
    
  </sect1>

  <sect1  id="TypedGroupCommunication_html_Creation" >
    

   <title>Creation of a Group</title>

	 <indexterm><primary>Group</primary><secondary>Creation</secondary></indexterm>
    
	 <para>Any object that is reifiable has the ability to be included in a
    group. Groups are created using the static method
    <literal>ProActiveGroup.newGroup</literal>. The common superclass for all
    the group members has to be specified, thus giving the group a minimal
    type.</para>

    <para>Let us take a standard Java class:</para>

    
      <para><programlisting lang="java">class A { 
  public A() {}
  public void foo (...) {...}
  public V bar (...) {...}
  ...
}</programlisting></para>
    

    <para>Here are examples of some group creation operations:</para>

    
      <para><programlisting lang="java">   // Pre-construction of some parameters: 
   //   For constructors:
Object[][] params = {{...} , {...} , ... };
   //   Nodes to identify JVMs to map objects
Node[] nodes  = { ... , ..., ... };
   // Solution 1: 
   // create an empty group of type 'A'
A ag1 = (A) ProActiveGroup.newGroup('A');
   // Solution 2: 
   // a group of type 'A' and its members are 
   // created at once, 
   // with parameters specified  in params,
   // and on the nodes specified in nodes
A ag2 = (A) ProActiveGroup.newGroup('A', params, nodes);
   // Solution 3: 
   // a group of type 'A'  and its members are 
   // created at once, 
   // with parameters specified in params,
   // and on the nodes directly specified 
A ag3 = (A) ProActiveGroup.newGroup('A', params[], 
                   {rmi://globus1.inria.fr/Node1,
                    rmi://globus2.inria.fr/Node2});</programlisting></para>
    

    <para>Elements can be included into a typed group only if their class
    equals or extends the class specified at the group creation. For example,
    an object of class B (B extending A) can be included to a group of type A.
    However based on Java typing, only the methods defined in the class A can
    be invoked on the group.</para>
  </sect1>

  <sect1  id="TypedGroupCommunication_html_repr" >
    <title>Group representation and manipulation</title>

    <para>The <emphasis role="bold">typed group representation</emphasis> we
    have presented corresponds to the functional view of groups of objects. In
    order to provide a dynamic management of groups, a second and
    complementary representation of a group has been designed. In order to
    manage a group, this second representation must be used instead. This
    second representation, <emphasis role="bold">the management
    representation</emphasis>, follows a more standard pattern for grouping
    objects: the <literal>Group</literal> interface.</para>

    <para>We are careful to have a strong coherence between both
    representations of the same group, which implies that modifications
    executed through one representation are immediately reported on the other
    one. In order to switch from one representation to the other, two methods
    have been defined : the static method named
    <literal>ProActiveGroup.getGroup</literal>, returns the Group form
    associated to the given group object; the method
    <literal>getGroupBytype</literal> defined in the <literal>Group</literal>
    interface does the opposite.</para>

    <para>Below is an example of when and how to use each representation of a
    group:</para>

    
      <para><programlisting lang="java">   // definition of one standard Java object
   // and two active objects
A a1 = new A();
A a2 = (A) ProActive.newActive('A', paramsA[], node);
B b  = (B) ProActive.newActive('B', paramsB[], node);
   // Note that B extends A
   // For management purposes, get the representation
   // as a group given a typed group, created with
   // code on the left column:
Group gA = ProActiveGroup.getGroup(ag1);
   // Now, add objects to the group:
   // Note that active and non-active objects 
   // may be mixed in groups
gA.add(a1);
gA.add(a2);
gA.add(b); 
   // The addition of members to a group immediately
   // reflects on the typed group form,  so a method
   // can be invoked on the typed group  and will
   // reach all its current members
ag1.foo(); // the caller of ag1.foo() may not belong to ag1
   // A new reference to the typed group  
   // can also be built as follows
A ag1new = (A) gA.getGroupByType();</programlisting></para>
    
  </sect1>

  <sect1  id="TypedGroupCommunication_html_result">
    <title>Group as result of group communications</title>

    <para>The particularity of our group communication mechanism is that the
    <emphasis role="bold">result</emphasis> of a typed group communication
    <emphasis role="bold">is also a group</emphasis>. The result group is
    transparently built at invocation time, with a future for each elementary
    reply. It will be dynamically updated with the incoming results, thus
    gathering results. Nevertheless, the result group can be immediately used
    to execute another method call, even if all the results are not available.
    In that case the <emphasis role="bold">wait-by-necessity</emphasis>
    mechanism implemented by ProActive is used.</para>

    
      <para><programlisting lang="java">   // A method call on a group, returning a result
V vg = ag1.bar();
   // vg is a typed group of 'V': operation 
   // below is also a collective operation
   // triggered on results
vg.f1();</programlisting></para>
    

    <para>As said in the Group creation section, groups whose type is based on
    final classes or primitive types cannot be built. So, the construction of
    a dynamic group as a result of a group method call is also limited.
    Consequently, only methods whose return type is either void or is a
    'reifiable type', in the sense of the Meta Object Protocol of ProActive,
    may be called on a group of objects; otherwise, they will raise an
    exception at run-time, because the transparent construction of a group of
    futures of non-reifiable types fails.</para>

    <para>To take advantage with the asynchronous remote method call model of
    ProActive, some new synchronization mechanisms have been added. Static
    methods defined in the <literal>ProActiveGroup</literal> class enable to
    execute various forms of synchronisation. For instance:
    <literal>waitOne</literal>, <literal>waitN</literal>,
    <literal>waitAll</literal>, <literal>waitTheNth</literal>,
    <literal>waitAndGet</literal>. Here is an exemple:</para>

    
      <para><programlisting lang="java">   // A method call on a typed group
V vg = ag1.bar(); 
   // To wait and capture the first returned 
   // member of vg
V v = (V) ProActiveGroup.waitAndGetOne(vg);
   // To wait all the members of vg are arrived
ProActiveGroup.waitAll(vg);
</programlisting></para>
    
  </sect1>

  <sect1  id="TypedGroupCommunication_html_comms" >
    <title>Broadcast vs Dispatching</title>

    <para>Regarding the parameters of a method call towards a group of
    objects, the default behaviour is to broadcast them to all members. But
    sometimes, only a specific portion of the parameters, usually dependent of
    the rank of the member in the group, may be really useful for the method
    execution, and so, parts of the parameter transmissions are useless. In
    other words, in some cases, there is a need to transmit different
    parameters to the various members.</para>

    <para>A common way to achieve the scattering of a global parameter is to
    use the rank of each member of the group, in order to select the
    appropriate part that it should get in order to execute the method. There
    is a natural traduction of this idea inside our group communication
    mechanism:<emphasis role="bold">the use of a group of objects in order to
    represent a parameter of a group method call that must be scattered to its
    members</emphasis>.</para>

    <para>The default behaviour regarding parameters passing for method call
    on a group, is to pass a deep copy of the group of type P to all members.
    Thus, in order to scatter this group of elements of type P instead, the
    programmer must apply the static method <literal>setScatterGroup</literal>
    of the <literal>ProActiveGroup</literal> class to the group. In order to
    switch back to the default behaviour, the static method
    <literal>unsetScatterGroup</literal> is available.</para>

    
      <para><programlisting lang="java">   // Broadcast the group gb to all the members
   // of the group ag1:
ag1.foo(gb);
   // Change the distribution mode of the 
   // parameter group:
ProActiveGroup.setScatterGroup(gb);
   // Scatter the members of gb onto the 
   // members of ag1:
ag1.foo(gb);</programlisting></para>
    

     
 <para>To learn more, see the 
 <!-- This url can only work in the html generated files: in pdf there's no ".." -->
 <ulink os="html" url="../api/org/objectweb/proactive/core/group/package-summary.html">JavaDoc</ulink> 
 <phrase os="pdf">javadoc of org.objectweb.proactive.core.group</phrase>
      and the paper <citation><xref linkend="BBC02" endterm="BBC02.abbrev"/></citation>.
     </para>
  </sect1>
</chapter>